\hypertarget{command-line-parsing}{%
\section{Command-Line Parsing}\label{command-line-parsing}}

Many of the OCaml programs that you'll write will end up as binaries
that need to be run from a command prompt. Any nontrivial command line
should support a collection of basic features:

\begin{itemize}
\item
  Parsing of command-line arguments
\item
  Generation of error messages in response to incorrect inputs
\item
  Help for all the available options
\item
  Interactive autocompletion
\end{itemize}

It's tedious and error-prone to code all of this manually for every
program you write. Core provides the Command library, which simplifies
all of this by letting you declare your command-line options in one
place and by deriving all of the above functionality from these
declarations. \index{command-line
parsing/Command library for}

Command is simple to use for simple applications but also scales well as
your needs grow more complex. In particular, Command provides a
sophisticated subcommand mode that groups related commands together as
the complexity of your user interface grows. You may already be familiar
with this command-line style from the Git or Mercurial version control
systems.

In this chapter, we'll:

\begin{itemize}
\item
  Learn how to use Command to construct basic and grouped command-line
  interfaces
\item
  We will build simple equivalents to the cryptographic
  \passthrough{\lstinline!md5!} and \passthrough{\lstinline!shasum!}
  utilities
\item
  Demonstrate how to declare complex command-line interfaces in a
  type-safe and elegant way \index{combinators/functional combinators}
\end{itemize}

\hypertarget{basic-command-line-parsing}{%
\subsection{Basic Command-Line
Parsing}\label{basic-command-line-parsing}}

Let's start by working through a clone of the
\passthrough{\lstinline!md5sum!} command that is present on most Linux
installations (the equivalent command on macOS is simply
\passthrough{\lstinline!md5!}). The following function defined below
reads in the contents of a file, applies the MD5 one-way cryptographic
hash function to the data, and outputs an ASCII hex representation of
the result: \index{MD5 one-way cryptographic
hash function}\index{command-line parsing/basic approach to}

\begin{lstlisting}[language=Caml]
open Core

let do_hash file =
  Md5.digest_file_blocking file
  |> Md5.to_hex
  |> print_endline
\end{lstlisting}

The \passthrough{\lstinline!do\_hash!} function accepts a
\passthrough{\lstinline!filename!} parameter and prints the
human-readable MD5 string to the console standard output. The first step
toward turning this function into a command-line program is to create a
parser for the command line arguments. The module
\passthrough{\lstinline!Command.Param!} provides a set of combinators
that can be combined together to define a parameter parser for optional
flags and positional arguments, including documentation, the types they
should map to, and whether to take special actions such as pausing for
interactive input if certain inputs are encountered.

\hypertarget{anonymous-arguments}{%
\subsubsection{Defining an anonymous
argument}\label{anonymous-arguments}}

Let's build a parser for a command line UI with a single
\emph{anonymous} argument, i.e., an argument that is passed in without a
flag.

\begin{lstlisting}[language=Caml]
let filename_param =
  let open Command.Param in
  anon ("filename" %: string)
\end{lstlisting}

Here, \passthrough{\lstinline!anon!} is used to signal the parsing of an
anonymous argument, and the expression
\passthrough{\lstinline!("filename" \%: string)!} indicates the textual
name of the argument and specification that describes the kind of value
that is expected. The textual name is used for generating help text, and
the specification is used both to nail down the OCaml type of the
returned value (\passthrough{\lstinline!string!}, in this case) and to
guide features like input validation. The values
\passthrough{\lstinline!anon!}, \passthrough{\lstinline!string!} and
\passthrough{\lstinline!\%:!} all come from the
\passthrough{\lstinline!Command.Param!} module.

\hypertarget{defining-basic-commands}{%
\subsubsection{Defining basic commands}\label{defining-basic-commands}}

Once we've defined a specification, we need to put it to work on real
input. The simplest way is to directly create a command-line interface
with \passthrough{\lstinline!Command.basic!}. \index{Command.basic}

\begin{lstlisting}[language=Caml]
let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    (Command.Param.map filename_param ~f:(fun filename ->
         (fun () -> do_hash filename)))
\end{lstlisting}

The \passthrough{\lstinline!summary!} argument is a one-line description
which goes at the top of the help screen, while the (optional)
\passthrough{\lstinline!readme!} argument is for providing a more
detailed description that will be provided on demand.

The final argument is the most interesting one, which is the parameter
parser. This will be easier to understand if we first learn a bit more
about the type signatures of the various components we've been using.
Let's do that by recreating some of this code in the toplevel.

\begin{lstlisting}[language=Caml]
# let filename_param = Command.Param.(anon ("filename" %: string))
val filename_param : string Command.Spec.param = <abstr>
\end{lstlisting}

The type parameter of \passthrough{\lstinline!filename\_param!} is there
to indicate the type of the value returned by the parser; in this case,
\passthrough{\lstinline!string!}.

But \passthrough{\lstinline!Command.basic!} requires a parameter parser
that returns a value of type \passthrough{\lstinline!unit -> unit!}. We
can see that by using \passthrough{\lstinline!\#show!} to explore the
types.

\begin{lstlisting}[language=Caml]
# #show Command.basic
val basic : unit Command.basic_command
# #show Command.basic_command
type nonrec 'result basic_command =
    summary:string ->
    ?readme:(unit -> string) ->
    (unit -> 'result) Command.Spec.param -> Command.t
\end{lstlisting}

Note that the \passthrough{\lstinline!'result!} parameter of the type
alias \passthrough{\lstinline!basic\_command!} is instantiated as
\passthrough{\lstinline!unit!} for the type of
\passthrough{\lstinline!Command.basic!}.

It makes sense that \passthrough{\lstinline!Command.basic!} wants a
parser that returns a function; after all, in the end, it needs a
function it can run that constitutes the execution of the program. But
how do we get such a parser, given the parser we have returns just a
filename?

The answer is to use a \passthrough{\lstinline!map!} function to change
the value returned by the parser. As you can see below, the type of
\passthrough{\lstinline!Command.Param.map!} is very similar to the code
of \passthrough{\lstinline!List.map!}.

\begin{lstlisting}[language=Caml]
# #show Command.Param.map
val map : 'a Command.Spec.param -> f:('a -> 'b) -> 'b Command.Spec.param
\end{lstlisting}

In our program, we used \passthrough{\lstinline!map!} to convert the
\passthrough{\lstinline!filename\_param!} parser, which returns a string
representing the file name, into a parser that returns a function of
type \passthrough{\lstinline!unit -> unit!} containing the body of the
command.

\hypertarget{running-basic-commands}{%
\subsubsection{Running commands}\label{running-basic-commands}}

Once we've defined the basic command, running it is just one function
call away.

\begin{lstlisting}[language=Caml]
let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

\passthrough{\lstinline!Command.run!} takes a couple of optional
arguments that are useful to identify which version of the binary you
are running in production. You'll need the following
\passthrough{\lstinline!dune!} file:

\begin{lstlisting}
(executable
  (name       md5)
  (libraries  core)
  (preprocess (pps ppx_jane)))
\end{lstlisting}

At which point we can build and execute the program using
\passthrough{\lstinline!dune exec!}. Let's use this to query version
information from the binary.

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe -version
1.0
$ dune exec -- ./md5.exe -build-info
RWO
\end{lstlisting}

The versions that you see in the output were defined via the optional
arguments to \passthrough{\lstinline!Command.run!}. You can leave these
blank in your own programs or get your build system to generate them
directly from your version control system. Dune provides a
\href{https://dune.readthedocs.io/en/stable/executables.html\#embedding-build-information-into-executables}{\passthrough{\lstinline!dune-build-info!}
library} that automates this process for most common workflows.

We can invoke our binary with \passthrough{\lstinline!-help!} to see the
auto-generated help.

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe -help
Generate an MD5 hash of the input data

  md5.exe FILENAME

More detailed information

=== flags ===

  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)
\end{lstlisting}

If you supply the \passthrough{\lstinline!filename!} argument, then
\passthrough{\lstinline!do\_hash!} is called with the argument and the
MD5 output is displayed to the standard output.

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe md5.ml
cd43f59095550dce382f8f3427aa3373
\end{lstlisting}

And that's all it took to build our little MD5 utility! Here's a
complete version of the example we just walked through, made slightly
more succinct by removing intermediate variables.

\begin{lstlisting}[language=Caml]
open Core

let do_hash file =
  Md5.digest_file_blocking file
  |> Md5.to_hex
  |> print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Param.(
     map (anon ("filename" %: string))
       ~f:(fun filename -> (fun () -> do_hash filename)))

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

\hypertarget{multiple-arguments}{%
\subsubsection{Multi-argument commands}\label{multiple-arguments}}

All the examples thus far have involved a single argument, but we can of
course create multi-argument commands as well. We can make a parser for
multiple arguments by binding together simpler parsers, using the
function \passthrough{\lstinline!Command.Param.both!}. Here is its type.

\begin{lstlisting}[language=Caml]
# #show Command.Param.both
val both :
  'a Command.Spec.param ->
  'b Command.Spec.param -> ('a * 'b) Command.Spec.param
\end{lstlisting}

\passthrough{\lstinline!both!} allows us to take two parameter parsers
and combine them into a single parser that returns the two arguments as
a pair. In the following, we rewrite our \passthrough{\lstinline!md5!}
program so it takes two anonymous arguments: the first is an integer
saying how many characters of the hash to print out, and the second is
the filename.

\begin{lstlisting}[language=Caml]
open Core

let do_hash hash_length filename =
  Md5.digest_file_blocking filename
  |> Md5.to_hex
  |> (fun s -> String.prefix s hash_length)
  |> print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Param.(
      map (both
            (anon ("hash_length" %: int))
            (anon ("filename" %: string)))
       ~f:(fun (hash_length,filename) ->
            (fun () -> do_hash hash_length filename)))

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

Building and running this command, we can see that it now indeed expects
two arguments.

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe 5 md5.ml
c45ae
\end{lstlisting}

This works well enough for two parameters, but if you want longer
parameter lists, this approach gets old fast. A better way is to use
let-syntax, which was discussed in
\href{error-handling.html\#bind-and-other-error-handling-idioms}{Error
Handling}.

\begin{lstlisting}[language=Caml]
let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    (let open Command.Let_syntax in
     let open Command.Param in
     let%map
       hash_length = anon ("hash_length" %: int)
     and filename  = anon ("filename" %: string)
     in
     fun () -> do_hash hash_length filename)
\end{lstlisting}

Here, we take advantage of let-syntax's support for parallel let
bindings, using \passthrough{\lstinline!and!} to join the definitions
together. This syntax translates down to the same pattern based on
\passthrough{\lstinline!both!} that we showed above, but it's easier to
read and use, and scales better to more arguments.

The need to open both modules is a little awkward, and the
\passthrough{\lstinline!Param!} module in particular you really only
need on the right-hand-side of the equals-sign. This is achieved
automatically by using the \passthrough{\lstinline!let\%map\_open!}
syntax, demonstrated below.

\begin{lstlisting}[language=Caml]
let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open
        hash_length = anon ("hash_length" %: int)
      and filename  = anon ("filename" %: string)
      in
      fun () -> do_hash hash_length filename)
\end{lstlisting}

Let-syntax is the most common way of writing parsers for
\passthrough{\lstinline!Command!}, and we'll use that idiom from here
on.

Now that we have the basics in place, the rest of the chapter will
examine some of the more advanced features of Command.

\hypertarget{argument-types}{%
\subsection{Argument Types}\label{argument-types}}

You aren't just limited to parsing command lines of strings and ints.
\passthrough{\lstinline!Command.Param!} defines several other conversion
functions (shown in
\href{command-line-parsing.html\#table14_1}{Table14\_1}) that validate
and parse input into various types. \index{arguments/argument
types}\index{command-line parsing/argument types}

\hypertarget{table14_1}{}
\begin{longtable}[]{@{}lll@{}}
\caption{Conversion functions defined in
\passthrough{\lstinline!Command.Param!}}\tabularnewline
\toprule
Argument type & OCaml type & Example\tabularnewline
\midrule
\endfirsthead
\toprule
Argument type & OCaml type & Example\tabularnewline
\midrule
\endhead
\passthrough{\lstinline!string!} & \passthrough{\lstinline!string!} &
\passthrough{\lstinline!foo!}\tabularnewline
\passthrough{\lstinline!int!} & \passthrough{\lstinline!int!} &
\passthrough{\lstinline!123!}\tabularnewline
\passthrough{\lstinline!float!} & \passthrough{\lstinline!float!} &
\passthrough{\lstinline!123.01!}\tabularnewline
\passthrough{\lstinline!bool!} & \passthrough{\lstinline!bool!} &
\passthrough{\lstinline!true!}\tabularnewline
\passthrough{\lstinline!date!} & \passthrough{\lstinline!Date.t!} &
\passthrough{\lstinline!2013-12-25!}\tabularnewline
\passthrough{\lstinline!time\_span!} & \passthrough{\lstinline!Span.t!}
& \passthrough{\lstinline!5s!}\tabularnewline
\passthrough{\lstinline!file!} & \passthrough{\lstinline!string!} &
\passthrough{\lstinline!/etc/passwd!}\tabularnewline
\bottomrule
\end{longtable}

We can tighten up the specification of the command to
\passthrough{\lstinline!Filename.arg\_type!} to reflect that the
argument must be a valid filename, and not just any string.

\begin{lstlisting}[language=Caml]
let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open file = anon ("filename" %: Filename.arg_type) in
      fun () -> do_hash file)
\end{lstlisting}

This doesn't change the validation of the provided value, but it does
enable interactive command-line completion. We'll explain how to enable
that later in the chapter.

\hypertarget{defining-custom-argument-types}{%
\subsubsection{Defining Custom Argument
Types}\label{defining-custom-argument-types}}

We can also define our own argument types if the predefined ones aren't
sufficient. For instance, let's make a
\passthrough{\lstinline!regular\_file!} argument type that ensures that
the input file isn't a character device or some other odd UNIX file type
that can't be fully read. \index{arguments/defining custom types}

\begin{lstlisting}[language=Caml]
open Core

let do_hash file =
  Md5.digest_file_blocking file
  |> Md5.to_hex
  |> print_endline

let regular_file =
  Command.Arg_type.create
    (fun filename ->
       match Sys.is_file filename with
       | `Yes -> filename
       | `No | `Unknown ->
         eprintf "'%s' is not a regular file.\n%!" filename;
         exit 1)

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open filename = anon ("filename" %: regular_file) in
      fun () -> do_hash filename)

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

The \passthrough{\lstinline!regular\_file!} function transforms a
\passthrough{\lstinline!filename!} string parameter into the same string
but first checks that the file exists and is a regular file type. When
you build and run this code, you will see the new error messages if you
try to open a special device such as
\passthrough{\lstinline!/dev/null!}:

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe md5.ml
dcf52e01189f63155410b17f252cf676
$ dune exec -- ./md5.exe /dev/null
'/dev/null' is not a regular file.
[1]
\end{lstlisting}

\hypertarget{optional-and-default-arguments}{%
\subsubsection{Optional and Default
Arguments}\label{optional-and-default-arguments}}

A more realistic \passthrough{\lstinline!md5!} binary could also read
from the standard input if a \passthrough{\lstinline!filename!} isn't
specified. To do this, we need to declare the filename argument as
optional, which we can do with the \passthrough{\lstinline!maybe!}
operator.
\index{arguments/default arguments}\index{default arguments}\index{optional
arguments/and default arguments}\index{arguments/optional arguments}

\begin{lstlisting}[language=Caml]
let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open filename = anon (maybe ("filename" %: string)) in
      fun () -> do_hash filename)
\end{lstlisting}

But building this results in a compile-time error.

\begin{lstlisting}[language=bash]
$ dune build md5.exe
...
File "md5.ml", line 15, characters 24-32:
15 |       fun () -> do_hash filename)
                             ^^^^^^^^
Error: This expression has type string option
       but an expression was expected of type string
[1]
\end{lstlisting}

This is because changing the argument type has also changed the type of
the value that is returned by the parser. It now produces a
\passthrough{\lstinline!string option!} instead of a
\passthrough{\lstinline!string!}, reflecting the optionality of the
argument. We can adapt our example to use the new information and read
from standard input if no file is specified.

\begin{lstlisting}[language=Caml]
open Core

let get_contents = function
  | None | Some "-" ->
    In_channel.input_all In_channel.stdin
  | Some filename ->
    In_channel.read_all filename

let do_hash filename =
  get_contents filename
  |> Md5.digest_string
  |> Md5.to_hex
  |> print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open filename =
        anon (maybe ("filename" %: Filename.arg_type))
      in
      fun () -> do_hash filename)

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

The \passthrough{\lstinline!filename!} parameter to
\passthrough{\lstinline!do\_hash!} is now a
\passthrough{\lstinline!string option!} type. This is resolved into a
string via \passthrough{\lstinline!get\_contents!} to determine whether
to read the standard input or a file, and then the rest of the command
is similar to our previous examples.

\begin{lstlisting}[language=bash]
$ cat md5.ml | dune exec -- ./md5.exe
e533f209e966f6c6c60f909f651fc24d
\end{lstlisting}

Another possible way to handle this would be to supply a dash as the
default filename if one isn't specified. The
\passthrough{\lstinline!maybe\_with\_default!} function can do just
this, with the benefit of not having to change the callback parameter
type.

The following example behaves exactly the same as the previous example,
but replaces \passthrough{\lstinline!maybe!} with
\passthrough{\lstinline!maybe\_with\_default!}:

\begin{lstlisting}[language=Caml]
open Core

let get_contents = function
  | "-"      -> In_channel.input_all In_channel.stdin
  | filename -> In_channel.read_all filename

let do_hash filename =
  get_contents filename
  |> Md5.digest_string
  |> Md5.to_hex
  |> print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open filename =
        anon (maybe_with_default "-" ("filename" %: Filename.arg_type))
      in
      fun () -> do_hash filename)

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

Building and running this confirms that it has the same behavior as
before.

\begin{lstlisting}[language=bash]
$ cat md5.ml | dune exec -- ./md5.exe
560f6fd99e100c7df0ef18161e9e8626
\end{lstlisting}

\hypertarget{sequences-of-arguments}{%
\subsubsection{Sequences of Arguments}\label{sequences-of-arguments}}

Another common way of parsing anonymous arguments is as a variable
length list. As an example, let's modify our MD5 code to take a
collection of files to process on the command line.
\index{arguments/sequences of}

\begin{lstlisting}[language=Caml]
open Core

let get_contents = function
  | "-"      -> In_channel.input_all In_channel.stdin
  | filename -> In_channel.read_all filename

let do_hash filename =
  get_contents filename
  |> Md5.digest_string
  |> Md5.to_hex
  |> fun md5 -> printf "MD5 (%s) = %s\n" filename md5

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -> "More detailed information")
    Command.Let_syntax.(
      let%map_open files =
        anon (sequence ("filename" %: Filename.arg_type))
      in
      fun () ->
        match files with
        | [] -> do_hash "-"
        | _  -> List.iter files ~f:do_hash)

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command
\end{lstlisting}

The callback function is a little more complex now, to handle the extra
options. The \passthrough{\lstinline!files!} are now a
\passthrough{\lstinline!string list!}, and an empty list reverts to
using standard input, just as our previous
\passthrough{\lstinline!maybe!} and
\passthrough{\lstinline!maybe\_with\_default!} examples did. If the list
of files isn't empty, then it opens up each file and runs them through
\passthrough{\lstinline!do\_hash!} sequentially.

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe /etc/services ./_build/default/md5.exe
MD5 (/etc/services) = 6501e9c7bf20b1dc56f015e341f79833
MD5 (./_build/default/md5.exe) = 6602408aa98478ba5617494f7460d3d9
\end{lstlisting}

\hypertarget{adding-labeled-flags}{%
\subsection{Adding Labeled Flags}\label{adding-labeled-flags}}

You aren't limited to anonymous arguments on the command line. A
\emph{flag} is a named field that can be followed by an optional
argument. These flags can appear in any order on the command line, or
multiple times, depending on how they're declared in the specification.
\index{flags}\index{command-line
parsing/labeled flags and}

Let's add two arguments to our \passthrough{\lstinline!md5!} command
that mimics the Mac OS X version. A \passthrough{\lstinline!-s!} flag
specifies the string to be hashed directly on the command line and
\passthrough{\lstinline!-t!} runs a self-test. The complete example
follows.

\begin{lstlisting}[language=Caml]
open Core

let checksum_from_string buf =
  Md5.digest_string buf
  |> Md5.to_hex
  |> print_endline

let checksum_from_file filename =
  let contents = match filename with
    | "-"      -> In_channel.input_all In_channel.stdin
    | filename -> In_channel.read_all filename
  in
  Md5.digest_string contents
  |> Md5.to_hex
  |> print_endline

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    Command.Let_syntax.(
      let%map_open
        use_string = flag "-s" (optional string)
          ~doc:"string Checksum the given string"
      and trial = flag "-t" no_arg ~doc:" run a built-in time trial"
      and filename =
        anon (maybe_with_default "-" ("filename" %: Filename.arg_type))
      in
      fun () ->
        if trial then printf "Running time trial\n"
        else match use_string with
          | Some buf -> checksum_from_string buf
          | None -> checksum_from_file filename)

let () = Command.run command
\end{lstlisting}

The specification now uses the \passthrough{\lstinline!flag!} function
to define the two new labeled, command-line arguments. The
\passthrough{\lstinline!doc!} string is formatted so that the first word
is the short name that appears in the usage text, with the remainder
being the full help text. Notice that the \passthrough{\lstinline!-t!}
flag has no argument, and so we prepend its
\passthrough{\lstinline!doc!} text with a blank space. The help text for
the preceding code looks like this:

\begin{lstlisting}[language=bash]
$ dune exec -- ./md5.exe -help
Generate an MD5 hash of the input data

  md5.exe [FILENAME]

=== flags ===

  [-s string]    Checksum the given string
  [-t]           run a built-in time trial
  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)

$ dune exec -- ./md5.exe -s "ocaml rocks"
5a118fe92ac3b6c7854c595ecf6419cb
\end{lstlisting}

The \passthrough{\lstinline!-s!} flag in our specification requires a
\passthrough{\lstinline!string!} argument and isn't optional. The
Command parser outputs an error message if the flag isn't supplied, as
with the anonymous arguments in earlier examples.
\href{command-line-parsing.html\#table14-2}{Table14 2} contains a list
of some of the functions that you can wrap flags in to control how they
are parsed. \index{flag functions}

\hypertarget{table14-2}{}
\begin{longtable}[]{@{}ll@{}}
\caption{Flag functions}\tabularnewline
\toprule
Flag function & OCaml type\tabularnewline
\midrule
\endfirsthead
\toprule
Flag function & OCaml type\tabularnewline
\midrule
\endhead
\passthrough{\lstinline!required!} \emph{arg} & \emph{arg} and error if
not present\tabularnewline
\passthrough{\lstinline!optional!} \emph{arg} & \emph{arg}
\passthrough{\lstinline!option!}\tabularnewline
\passthrough{\lstinline!optional\_with\_default!} \emph{val} \emph{arg}
& \emph{arg} with default \emph{val} if not present\tabularnewline
\passthrough{\lstinline!listed!} \emph{arg} & \emph{arg}
\passthrough{\lstinline!list!}, flag may appear multiple
times\tabularnewline
\passthrough{\lstinline!no\_arg!} & \passthrough{\lstinline!bool!} that
is true if flag is present\tabularnewline
\bottomrule
\end{longtable}

The flags affect the type of the callback function in exactly the same
way as anonymous arguments do. This lets you change the specification
and ensure that all the callback functions are updated appropriately,
without runtime errors.

\hypertarget{grouping-sub-commands-together}{%
\subsection{Grouping Subcommands
Together}\label{grouping-sub-commands-together}}

You can get pretty far by using flags and anonymous arguments to
assemble complex, command-line interfaces. After a while, though, too
many options can make the program very confusing for newcomers to your
application. One way to solve this is by grouping common operations
together and adding some hierarchy to the command-line interface.
\index{subcommands, grouping
of}\index{OPAM package manager}\index{command-line parsing/subcommand
grouping}

You'll have run across this style already when using the opam package
manager (or, in the non-OCaml world, the Git or Mercurial commands).
opam exposes commands in this form:

\begin{lstlisting}
$ opam config env
$ opam remote list -k git
$ opam install --help
$ opam install core --verbose
\end{lstlisting}

The \passthrough{\lstinline!config!}, \passthrough{\lstinline!remote!},
and \passthrough{\lstinline!install!} keywords form a logical grouping
of commands that factor out a set of flags and arguments. This lets you
prevent flags that are specific to a particular subcommand from leaking
into the general configuration space.
\index{install keyword}\index{remote keyword}

This usually only becomes a concern when your application organically
grows features. Luckily, it's simple to extend your application to do
this in Command: just use \passthrough{\lstinline!Command.group!}, which
lets you merge a collection of \passthrough{\lstinline!Command.t!}'s
into one. \index{Command.group}

\begin{lstlisting}[language=Caml]
# Command.group
- : summary:string ->
    ?readme:(unit -> string) ->
    ?preserve_subcommand_order:unit ->
    ?body:(path:string list -> unit) ->
    (string * Command.t) list -> Command.t
= <fun>
\end{lstlisting}

The \passthrough{\lstinline!group!} signature accepts a list of basic
\passthrough{\lstinline!Command.t!} values and their corresponding
names. When executed, it looks for the appropriate subcommand from the
name list, and dispatches it to the right command handler.

Let's build the outline of a calendar tool that does a few operations
over dates from the command line. We first need to define a command that
adds days to an input date and prints the resulting date:

\begin{lstlisting}[language=Caml]
open Core

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Let_syntax.(
      let%map_open
        base = anon ("base" %: date)
      and days = anon ("days" %: int)
      in
      fun () ->
       Date.add_days base days
       |> Date.to_string
       |> print_endline)

let () = Command.run add
\end{lstlisting}

Everything in this command should be familiar to you by now, and it
works as you might expect.

\begin{lstlisting}[language=bash]
$ dune exec -- ./cal.exe -help
Add [days] to the [base] date and print day

  cal.exe BASE DAYS

=== flags ===

  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)

$ dune exec -- ./cal.exe 2012-12-25 40
2013-02-03
\end{lstlisting}

Now, let's also add the ability to take the difference between two
dates, but, instead of creating a new binary, we'll group both
operations as subcommands using \passthrough{\lstinline!Command.group!}.

\begin{lstlisting}[language=Caml]
open Core

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date"
    Command.Let_syntax.(
      let%map_open base = anon ("base" %: date)
      and days = anon ("days" %: int)
      in
      fun () ->
        Date.add_days base days
        |> Date.to_string
        |> print_endline)

let diff =
  Command.basic
    ~summary:"Show days between [date1] and [date2]"
    Command.Let_syntax.(
      let%map_open
        date1 = anon ("date1" %: date)
      and date2 = anon ("date2" %: date)
      in
      fun () ->
        Date.diff date1 date2
        |> printf "%d days\n")

let command =
  Command.group ~summary:"Manipulate dates"
    [ "add", add
    ; "diff", diff ]

let () = Command.run command
\end{lstlisting}

And that's all you really need to add subcommand support! Let's build
the example first in the usual way and inspect the help output, which
now reflects the subcommands we just added.

\begin{lstlisting}
(executable
  (name       cal)
  (libraries  core)
  (preprocess (pps ppx_jane)))
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ dune exec -- ./cal.exe -help
Manipulate dates

  cal.exe SUBCOMMAND

=== subcommands ===

  add      Add [days] to the [base] date
  diff     Show days between [date1] and [date2]
  version  print version information
  help     explain a given subcommand (perhaps recursively)
\end{lstlisting}

We can invoke the two commands we just defined to verify that they work
and see the date parsing in action:

\begin{lstlisting}[language=bash]
$ dune exec -- ./cal.exe add 2012-12-25 40
2013-02-03
$ dune exec -- ./cal.exe diff 2012-12-25 2012-11-01
54 days
\end{lstlisting}

\hypertarget{prompting-for-interactive-input}{%
\subsection{Prompting for Interactive
Input}\label{prompting-for-interactive-input}}

Sometimes, if a value isn't provided on the command line, you want to
prompt for it instead. Let's return to the calendar tool we built
before. \index{interactive input/prompts for}

\begin{lstlisting}[language=Caml]
open Core

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Let_syntax.(
      let%map_open
        base = anon ("base" %: date)
      and days = anon ("days" %: int)
      in
      fun () ->
       Date.add_days base days
       |> Date.to_string
       |> print_endline)

let () = Command.run add
\end{lstlisting}

This program requires you to specify both the
\passthrough{\lstinline!base!} date and the number of
\passthrough{\lstinline!days!} to add onto it. If
\passthrough{\lstinline!days!} isn't supplied on the command line, an
error is output. Now let's modify it to interactively prompt for a
number of days if only the \passthrough{\lstinline!base!} date is
supplied.

\begin{lstlisting}[language=Caml]
open Core

let add_days base days =
  Date.add_days base days
  |> Date.to_string
  |> print_endline

let prompt_for_string name of_string =
  printf "enter %s: %!" name;
  match In_channel.input_line In_channel.stdin with
  | None -> failwith "no value entered. aborting."
  | Some line -> of_string line

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Let_syntax.(
      let%map_open
        base = anon ("base" %: date)
      and days = anon (maybe ("days" %: int))
      in
      let days =
        match days with
        | Some x -> x
        | None -> prompt_for_string "days" Int.of_string
      in
      fun () ->
        add_days base days)

let () = Command.run add
\end{lstlisting}

The \passthrough{\lstinline!days!} anonymous argument is now an optional
integer in the spec, and when it isn't there, we simply prompt for the
value as part of the ordinary execution of our program.

Sometimes, it's convenient to pack the prompting behavior into the
parser itself. For one thing, this would allow you to easily share the
prompting behavior among multiple commands. This is easy enough to do by
adding a new function, \passthrough{\lstinline!anon\_prompt!}, which
creates a parser that automatically prompts if the value isn't provided.

\begin{lstlisting}[language=Caml]
let anon_prompt name of_string =
  let arg = Command.Arg_type.create of_string in
  Command.Let_syntax.(
    let%map_open value = anon (maybe (name %: arg)) in
    match value with
    | Some v -> v
    | None -> prompt_for_string name of_string)

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Let_syntax.(
      let%map_open
        base = anon ("base" %: date)
      and days = anon_prompt "days" Int.of_string
      in
      fun () ->
        add_days base days)
\end{lstlisting}

We can see the prompting behavior if we run the program without
providing the second argument.

\begin{lstlisting}[language=bash]
$ echo 35 | dune exec -- ./cal.exe 2013-12-01
enter days: 2014-01-05
\end{lstlisting}

\hypertarget{command-line-auto-completion-with-bash}{%
\subsection{Command-Line Autocompletion with
bash}\label{command-line-auto-completion-with-bash}}

Modern UNIX shells usually have a tab-completion feature to
interactively help you figure out how to build a command line. These
work by pressing the Tab key in the middle of typing a command, and
seeing the options that pop up. You've probably used this most often to
find the files in the current directory, but it can actually be extended
for other parts of the command, too.
\index{tab-autocompletion}\index{autocompletion}\index{command-line
parsing/autocompletion with bash}

The precise mechanism for autocompletion varies depending on what shell
you are using, but we'll assume you are using the most common one:
\passthrough{\lstinline!bash!}. This is the default interactive shell on
most Linux distributions and Mac OS X, but you may need to switch to it
on *BSD or Windows (when using Cygwin). The rest of this section assumes
that you're using \passthrough{\lstinline!bash!}. \index{bash
autocompletion}

Bash autocompletion isn't always installed by default, so check your OS
package manager to see if you have it available.

\begin{longtable}[]{@{}lll@{}}
\toprule
Operating system & Package manager & Package\tabularnewline
\midrule
\endhead
Debian Linux & \passthrough{\lstinline!apt!} &
\passthrough{\lstinline!bash-completion!}\tabularnewline
Mac OS X & Homebrew &
\passthrough{\lstinline!bash-completion!}\tabularnewline
FreeBSD & Ports system &
/usr/ports/shells/bash-completion\tabularnewline
\bottomrule
\end{longtable}

Once \emph{bash} completion is installed and configured, check that it
works by typing the \passthrough{\lstinline!ssh!} command and pressing
the Tab key. This should show you the list of known hosts from your
\emph{\textasciitilde/.ssh/known\_hosts} file. If it lists some hosts
that you've recently connected to, you can continue on. If it lists the
files in your current directory instead, then check your OS
documentation to configure completion correctly.

One last bit of information you'll need to find is the location of the
bash\_completion.d directory. This is where all the shell fragments that
contain the completion logic are held. On Linux, this is often in
/etc/bash\_completion.d, and in Homebrew on Mac OS X, it would be
/usr/local/etc/bash\_completion.d by default.

\hypertarget{generating-completion-fragments-from-command}{%
\subsubsection{Generating Completion Fragments from
Command}\label{generating-completion-fragments-from-command}}

The Command library has a declarative description of all the possible
valid options, and it can use this information to generate a shell
script that provides completion support for that command. To generate
the fragment, just run the command with the
\passthrough{\lstinline!COMMAND\_OUTPUT\_INSTALLATION\_BASH!}
environment variable set to any value.

For example, let's try it on our MD5 example from earlier, assuming that
the binary is called \passthrough{\lstinline!md5!} in the current
directory:

\begin{lstlisting}[language=bash]
$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 dune exec -- ./md5.exe
function _jsautocom_16984 {
  export COMP_CWORD
  COMP_WORDS[0]=./md5.exe
  if type readarray > /dev/null
  then readarray -t COMPREPLY < <("${COMP_WORDS[@]}")
  else IFS="
" read -d "\0" -A COMPREPLY < <("${COMP_WORDS[@]}")
  fi
}
complete -F _jsautocom_16984 ./md5.exe
\end{lstlisting}

Recall that we used the \passthrough{\lstinline!Arg\_type.file!} to
specify the argument type. This also supplies the completion logic so
that you can just press Tab to complete files in your current directory.

\hypertarget{installing-the-completion-fragment}{%
\subsubsection{Installing the Completion
Fragment}\label{installing-the-completion-fragment}}

You don't need to worry about what the preceding output script actually
does (unless you have an unhealthy fascination with shell scripting
internals, that is). Instead, redirect the output to a file in your
current directory and source it into your current shell:

\begin{lstlisting}
$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native > cal.cmd
$ . cal.cmd
$ ./cal_add_sub_days.native <tab>
add      diff     help     version
\end{lstlisting}

Command completion support works for flags and grouped commands and is
very useful when building larger command-line interfaces. Don't forget
to install the shell fragment into your global bash\_completion.d
directory if you want it to be loaded in all of your login shells.
\index{completion handlers}

\hypertarget{installing-a-generic-completion-handler}{%
\paragraph{Installing a Generic Completion
Handler}\label{installing-a-generic-completion-handler}}

Sadly, \passthrough{\lstinline!bash!} doesn't support installing a
generic handler for all Command-based applications. This means you have
to install the completion script for every application, but you should
be able to automate this in the build and packaging system for your
application.

It will help to check out how other applications install tab-completion
scripts and follow their lead, as the details are very OS-specific.

\hypertarget{alternative-command-line-parsers}{%
\subsection{Alternative Command-Line
Parsers}\label{alternative-command-line-parsers}}

This rounds up our tour of the Command library. This isn't the only way
to parse command-line arguments of course; there are several
alternatives available on OPAM. Three of the most prominent ones follow:
\index{Cmdliner}\index{OCaml toolchain/ocaml-getopt}\index{Arg
module}\index{command-line parsing/alternatives to Command
library}\index{OPAM package manager}

\begin{description}
\tightlist
\item[The \texttt{Arg} module]
The \passthrough{\lstinline!Arg!} module is from the OCaml standard
library, which is used by the compiler itself to handle its command-line
interface. Command is generally more featureful than Arg (mainly via
support for subcommands, the \passthrough{\lstinline!step!} combinator
to transform inputs, and help generation), but there's absolutely
nothing wrong with using Arg either. You can use the
\passthrough{\lstinline!Command.Spec.flags\_of\_args\_exn!} function to
convert Arg specifications into ones compatible with Command. This is
quite often used to help port older non-Core code into the Core standard
library world.
\item[\href{https://forge.ocamlcore.org/projects/ocaml-getopt/}{ocaml-getopt}]
\passthrough{\lstinline!ocaml-getopt!} provides the general command-line
syntax of GNU \passthrough{\lstinline!getopt!} and
\passthrough{\lstinline!getopt\_long!}. The GNU conventions are widely
used in the open source world, and this library lets your OCaml programs
obey the same rules.
\item[\href{http://erratique.ch/software/cmdliner}{Cmdliner}]
Cmdliner is a mix between the Command and Getopt libraries. It allows
for the declarative definition of command-line interfaces but exposes a
more \passthrough{\lstinline!getopt!}-like interface. It also automates
the generation of UNIX man pages as part of the specification. Cmdliner
is the parser used by OPAM to manage its command line.
\end{description}
