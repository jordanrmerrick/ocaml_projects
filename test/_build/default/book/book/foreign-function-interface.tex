\hypertarget{foreign-function-interface}{%
\section{Foreign Function Interface}\label{foreign-function-interface}}

OCaml has several options available to interact with non-OCaml code. The
compiler can link with external system libraries via C code and also can
produce standalone native object files that can be embedded within other
non-OCaml
applications.\index{programming/language interfaces}\index{foreign
function interface (FFI)/basics of}\protect\hypertarget{INTERffi}{}{interfaces/foreign
function interface (FFI)}

The mechanism by which code in one programming language can invoke
routines in a different programming language is called a \emph{foreign
function interface}. This chapter will:

\begin{itemize}
\item
  Show how to call routines in C libraries directly from your OCaml code
\item
  Teach you how to build higher-level abstractions in OCaml from the
  low-level C bindings
\item
  Work through some full examples for binding a terminal interface and
  UNIX date/time functions
\end{itemize}

The simplest foreign function interface in OCaml doesn't even require
you to write any C code at all! The Ctypes library lets you define the C
interface in pure OCaml, and the library then takes care of loading the
C symbols and invoking the foreign function
call.\index{libffi library}\index{Ncurses terminal
toolkit}\index{Ctypes library/installation of}

Let's dive straight into a realistic example to show you how the library
looks. We'll create a binding to the Ncurses terminal toolkit, as it's
widely available on most systems and doesn't have any complex
dependencies.

\hypertarget{installing-the-ctypes-library}{%
\subsection{Installing the Ctypes
Library}\label{installing-the-ctypes-library}}

If you want to use Ctypes interactively, you'll also need to install the
\href{https://github.com/atgreen/libffi}{\passthrough{\lstinline!libffi!}}
library as a prerequisite to using Ctypes. It's a fairly popular library
and should be available in your OS package manager. Try
\passthrough{\lstinline!opam depext -ui ctypes-foreign!}.

Once that's done, Ctypes is available via OPAM as usual:

\begin{lstlisting}
$ brew install libffi     # for MacOS X users
$ opam install ctypes ctypes-foreign
$ utop
# require "ctypes-foreign" ;;
\end{lstlisting}

You'll also need the Ncurses library for the first example. This comes
preinstalled on many operating systems such as Mac OS X, and Debian
Linux provides it as the \passthrough{\lstinline!libncurses5-dev!}
package.

\hypertarget{example-a-terminal-interface}{%
\subsection{Example: A Terminal
Interface}\label{example-a-terminal-interface}}

Ncurses is a library to help build terminal-independent text interfaces
in a reasonably efficient way. It's used in console mail clients like
Mutt and Pine, and console web browsers such as
Lynx.\protect\hypertarget{FFItermint}{}{foreign function interface
(FFI)/terminal interface example}

The full C interface is quite large and is explained in the online
\href{http://www.gnu.org/software/ncurses/}{documentation}. We'll just
use the small excerpt, since we just want to demonstrate Ctypes in
action:\index{Ctypes
library/terminal interface example}

\begin{lstlisting}
typedef struct _win_st WINDOW;
typedef unsigned int chtype;

WINDOW *initscr   (void);
WINDOW *newwin    (int, int, int, int);
void    endwin    (void);
void    refresh   (void);
void    wrefresh  (WINDOW *);
void    addstr (const char *);
int     mvwaddch  (WINDOW *, int, int, const chtype);
void    mvwaddstr (WINDOW *, int, int, char *);
void    box (WINDOW *, chtype, chtype);
int     cbreak (void);
\end{lstlisting}

The Ncurses functions either operate on the current pseudoterminal or on
a window that has been created via \passthrough{\lstinline!newwin!}. The
\passthrough{\lstinline!WINDOW!} structure holds the internal library
state and is considered abstract outside of Ncurses. Ncurses clients
just need to store the pointer somewhere and pass it back to Ncurses
library calls, which in turn dereference its contents.

Note that there are over 200 library calls in Ncurses, so we're only
binding a select few for this example. The
\passthrough{\lstinline!initscr!} and \passthrough{\lstinline!newwin!}
create \passthrough{\lstinline!WINDOW!} pointers for the global and
subwindows, respectively. The \passthrough{\lstinline!mvwaddrstr!} takes
a window, x/y offsets, and a string and writes to the screen at that
location. The terminal is only updated after
\passthrough{\lstinline!refresh!} or \passthrough{\lstinline!wrefresh!}
are called.

Ctypes provides an OCaml interface that lets you map these C functions
to equivalent OCaml functions. The library takes care of converting
OCaml function calls and arguments into the C calling convention,
invoking the foreign call within the C library and finally returning the
result as an OCaml value.

Let's begin by defining the basic values we need, starting with the
\passthrough{\lstinline!WINDOW!} state pointer:

\begin{lstlisting}[language=Caml]
open Ctypes

type window = unit ptr
let window : window typ = ptr void
\end{lstlisting}

We don't know the internal representation of the window pointer, so we
treat it as a C void pointer. We'll improve on this later on in the
chapter, but it's good enough for now. The second statement defines an
OCaml value that represents the \passthrough{\lstinline!WINDOW!} C
pointer. This value is used later in the Ctypes function definitions:

\begin{lstlisting}[language=Caml]
open Foreign

let initscr =
  foreign "initscr" (void @-> returning window)
\end{lstlisting}

That's all we need to invoke our first function call to
\passthrough{\lstinline!initscr!} to initialize the terminal. The
\passthrough{\lstinline!foreign!} function accepts two parameters:

\begin{itemize}
\item
  The C function call name, which is looked up using the
  \passthrough{\lstinline!dlsym!} POSIX function.
\item
  A value that defines the complete set of C function arguments and its
  return type. The \passthrough{\lstinline!@->!} operator adds an
  argument to the C parameter list, and
  \passthrough{\lstinline!returning!} terminates the parameter list with
  the return type.
\end{itemize}

The remainder of the Ncurses binding simply expands on these
definitions:

\begin{lstlisting}[language=Caml]
let newwin =
  foreign "newwin"
    (int @-> int @-> int @-> int @-> returning window)

let endwin =
  foreign "endwin" (void @-> returning void)

let refresh =
  foreign "refresh" (void @-> returning void)

let wrefresh =
  foreign "wrefresh" (window @-> returning void)

let addstr =
  foreign "addstr" (string @-> returning void)

let mvwaddch =
  foreign "mvwaddch"
    (window @-> int @-> int @-> char @-> returning void)

let mvwaddstr =
  foreign "mvwaddstr"
    (window @-> int @-> int @-> string @-> returning void)

let box =
  foreign "box" (window @-> char @-> char @-> returning void)

let cbreak =
  foreign "cbreak" (void @-> returning int)
\end{lstlisting}

These definitions are all straightforward mappings from the C
declarations in the Ncurses header file. Note that the
\passthrough{\lstinline!string!} and \passthrough{\lstinline!int!}
values here are nothing to do with OCaml type declarations; instead,
they are values that come from opening the
\passthrough{\lstinline!Ctypes!} module at the top of the file.

Most of the parameters in the Ncurses example represent fairly simple
scalar C types, except for \passthrough{\lstinline!window!} (a pointer
to the library state) and \passthrough{\lstinline!string!}, which maps
from OCaml strings that have a specific length onto C character buffers
whose length is defined by a terminating null character that immediately
follows the string data.

The module signature for \passthrough{\lstinline!ncurses.mli!} looks
much like a normal OCaml signature. You can infer it directly from the
\passthrough{\lstinline!ncurses.ml!} by running a special build target:

\begin{lstlisting}[language=bash]
$ corebuild -pkg ctypes-foreign ncurses.inferred.mli
$ cp _build/ncurses.inferred.mli .
\end{lstlisting}

The \passthrough{\lstinline!inferred.mli!} target instructs the compiler
to generate the default signature for a module file and places it in the
\passthrough{\lstinline!\_build!} directory as a normal output. You
should normally copy it out into your source directory and customize it
to improve its safety for external callers by making some of its
internals more abstract.

Here's the customized interface that we can safely use from other
libraries:

\begin{lstlisting}[language=Caml]
type window
val window : window Ctypes.typ
val initscr : unit -> window
val endwin : unit -> unit
val refresh : unit -> unit
val wrefresh : window -> unit
val newwin : int -> int -> int -> int -> window
val mvwaddch : window -> int -> int -> char -> unit
val addstr : string -> unit
val mvwaddstr : window -> int -> int -> string -> unit
val box : window -> char -> char -> unit
val cbreak : unit -> int
\end{lstlisting}

The \passthrough{\lstinline!window!} type is left abstract in the
signature to ensure that window pointers can only be constructed via the
\passthrough{\lstinline!Ncurses.initscr!} function. This prevents void
pointers obtained from other sources from being mistakenly passed to an
Ncurses library call.

Now compile a ``hello world'' terminal drawing program to tie this all
together:

\begin{lstlisting}[language=Caml]
open Ncurses

let () =
  let main_window = initscr () in
  ignore(cbreak ());
  let small_window = newwin 10 10 5 5 in
  mvwaddstr main_window 1 2 "Hello";
  mvwaddstr small_window 2 2 "World";
  box small_window '\000' '\000';
  refresh ();
  Unix.sleep 1;
  wrefresh small_window;
  Unix.sleep 5;
  endwin ()
\end{lstlisting}

The \passthrough{\lstinline!hello!} executable is compiled by linking
with the \passthrough{\lstinline!ctypes-foreign!} OCamlfind package:

\begin{lstlisting}
(executable
  (name      hello)
  (libraries ctypes-foreign.threaded)
  (flags     :standard -cclib -lncurses))
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ dune build hello.exe
\end{lstlisting}

Running \passthrough{\lstinline!./hello.native!} should now display a
Hello World in your terminal!
\index{Ctypes library/build directives for}

Ctypes wouldn't be very useful if it were limited to only defining
simple C types, of course. It provides full support for C pointer
arithmetic, pointer conversions, and reading and writing through
pointers, using OCaml functions as function pointers to C code, as well
as struct and union definitions.

We'll go over some of these features in more detail for the remainder of
the chapter by using some POSIX date functions as running examples.~

\hypertarget{basic-scalar-c-types}{%
\subsection{Basic Scalar C Types}\label{basic-scalar-c-types}}

First, let's look at how to define basic scalar C types. Every C type is
represented by an OCaml equivalent via the single type
definition:\index{scalar C
types}\index{foreign function interface (FFI)/basic scalar C types}

\begin{lstlisting}[language=Caml]
type 'a typ
\end{lstlisting}

\passthrough{\lstinline!Ctypes.typ!} is the type of values that
represents C types to OCaml. There are two types associated with each
instance of \passthrough{\lstinline!typ!}:

\begin{itemize}
\item
  The C type used to store and pass values to the foreign library.
\item
  The corresponding OCaml type. The \passthrough{\lstinline!'a!} type
  parameter contains the OCaml type such that a value of type
  \passthrough{\lstinline!t typ!} is used to read and write OCaml values
  of type \passthrough{\lstinline!t!}.
\end{itemize}

There are various other uses of \passthrough{\lstinline!typ!} values
within Ctypes, such as:

\begin{itemize}
\item
  Constructing function types for binding native functions
\item
  Constructing pointers for reading and writing locations in C-managed
  storage
\item
  Describing component fields of structures, unions, and arrays
\end{itemize}

Here are the definitions for most of the standard C99 scalar types,
including some platform-dependent ones: \index{C99 scalar types}

\begin{lstlisting}[language=Caml]
val void      : unit typ
val char      : char typ
val schar     : int typ
val short     : int typ
val int       : int typ
val long      : long typ
val llong     : llong typ
val nativeint : nativeint typ

val int8_t    : int typ
val int16_t   : int typ
val int32_t   : int32 typ
val int64_t   : int64 typ
val uchar     : uchar typ
val uint8_t   : uint8 typ
val uint16_t  : uint16 typ
val uint32_t  : uint32 typ
val uint64_t  : uint64 typ
val size_t    : size_t typ
val ushort    : ushort typ
val uint      : uint typ
val ulong     : ulong typ
val ullong    : ullong typ

val float     : float typ
val double    : float typ

val complex32 : Complex.t typ
val complex64 : Complex.t typ
\end{lstlisting}

These values are all of type \passthrough{\lstinline!'a typ!}, where the
value name (e.g., \passthrough{\lstinline!void!}) tells you the C type
and the \passthrough{\lstinline!'a!} component (e.g.,
\passthrough{\lstinline!unit!}) is the OCaml representation of that C
type. Most of the mappings are straightforward, but some of them need a
bit more explanation:

\begin{itemize}
\item
  Void values appear in OCaml as the \passthrough{\lstinline!unit!}
  type. Using \passthrough{\lstinline!void!} in an argument or result
  type specification produces an OCaml function that accepts or returns
  \passthrough{\lstinline!unit!}. Dereferencing a pointer to
  \passthrough{\lstinline!void!} is an error, as in C, and will raise
  the \passthrough{\lstinline!IncompleteType!} exception.
\item
  The C \passthrough{\lstinline!size\_t!} type is an alias for one of
  the unsigned integer types. The actual size and alignment requirements
  for \passthrough{\lstinline!size\_t!} varies between platforms. Ctypes
  provides an OCaml \passthrough{\lstinline!size\_t!} type that is
  aliased to the appropriate integer type.
\item
  OCaml only supports double-precision floating-point numbers, and so
  the C \passthrough{\lstinline!float!} and
  \passthrough{\lstinline!double!} types both map onto the OCaml
  \passthrough{\lstinline!float!} type, and the C
  \passthrough{\lstinline!float complex!} and
  \passthrough{\lstinline!double complex!} types both map onto the OCaml
  double-precision \passthrough{\lstinline!Complex.t!} type.
\end{itemize}

\hypertarget{pointers-and-arrays}{%
\subsection{Pointers and Arrays}\label{pointers-and-arrays}}

Pointers are at the heart of C, so they are necessarily part of Ctypes,
which provides support for pointer arithmetic, pointer conversions,
reading and writing through pointers, and passing and returning pointers
to and from
functions.\index{POSIX functions}\index{arrays/pointers and}\index{pointers/support
for in Ctypes}\index{foreign function interface (FFI)/pointers and
arrays}

We've already seen a simple use of pointers in the Ncurses example.
Let's start a new example by binding the following POSIX functions:

\begin{lstlisting}
time_t time(time_t *);
double difftime(time_t, time_t);
char *ctime(const time_t *timep);
\end{lstlisting}

The \passthrough{\lstinline!time!} function returns the current calendar
time and is a simple start. The first step is to open some of the Ctypes
modules:

\begin{description}
\tightlist
\item[\texttt{Ctypes}]
The \passthrough{\lstinline!Ctypes!} module provides functions for
describing C types in OCaml.
\item[\texttt{PosixTypes}]
The \passthrough{\lstinline!PosixTypes!} module includes some extra
POSIX-specific types (such as \passthrough{\lstinline!time\_t!}).
\item[\texttt{Foreign}]
The \passthrough{\lstinline!Foreign!} module exposes the
\passthrough{\lstinline!foreign!} function that makes it possible to
invoke C functions.
\end{description}

We can now create a binding to \passthrough{\lstinline!time!} directly
from the toplevel.

\begin{lstlisting}[language=Caml]
# #require "ctypes-foreign.threaded"
# #require "ctypes.top"
# open Ctypes
# open PosixTypes
# open Foreign
# let time = foreign "time" (ptr time_t @-> returning time_t)
val time : time_t Ctypes_static.ptr -> time_t = <fun>
\end{lstlisting}

The \passthrough{\lstinline!foreign!} function is the main link between
OCaml and C. It takes two arguments: the name of the C function to bind,
and a value describing the type of the bound function. In the
\passthrough{\lstinline!time!} binding, the function type specifies one
argument of type \passthrough{\lstinline!ptr time\_t!} and a return type
of \passthrough{\lstinline!time\_t!}.

We can now call \passthrough{\lstinline!time!} immediately in the same
toplevel. The argument is actually optional, so we'll just pass a null
pointer that has been coerced into becoming a null pointer to
\passthrough{\lstinline!time\_t!}:

\begin{lstlisting}[language=Caml]
# let cur_time = time (from_voidp time_t null)
...
\end{lstlisting}

Since we're going to call \passthrough{\lstinline!time!} a few times,
let's create a wrapper function that passes the null pointer through:

\begin{lstlisting}[language=Caml]
# let time' () = time (from_voidp time_t null)
val time' : unit -> time_t = <fun>
\end{lstlisting}

Since \passthrough{\lstinline!time\_t!} is an abstract type, we can't
actually do anything useful with it directly. We need to bind a second
function to do anything useful with the return values from
\passthrough{\lstinline!time!}. We'll move on to
\passthrough{\lstinline!difftime!}; the second C function in our
prototype list:

\begin{lstlisting}[language=Caml]
# let difftime =
  foreign "difftime" (time_t @-> time_t @-> returning double)
val difftime : time_t -> time_t -> float = <fun>
# let t1 =
    time' () in
  Unix.sleep 2;
  let t2 = time' () in
  difftime t2 t1
- : float = 2.
\end{lstlisting}

The binding to \passthrough{\lstinline!difftime!} above is sufficient to
compare two \passthrough{\lstinline!time\_t!} values.

\hypertarget{allocating-typed-memory-for-pointers}{%
\subsubsection{Allocating Typed Memory for
Pointers}\label{allocating-typed-memory-for-pointers}}

Let's look at a slightly less trivial example where we pass a nonnull
pointer to a function. Continuing with the theme from earlier, we'll
bind to the \passthrough{\lstinline!ctime!} function, which converts a
\passthrough{\lstinline!time\_t!} value to a human-readable
string:\index{memory/allocation for pointers}\index{pointers/allocating typed
memory for}

\begin{lstlisting}[language=Caml]
# let ctime = foreign "ctime" (ptr time_t @-> returning string)
val ctime : time_t Ctypes_static.ptr -> string = <fun>
\end{lstlisting}

The binding is continued in the toplevel to add to our growing
collection. However, we can't just pass the result of
\passthrough{\lstinline!time!} to \passthrough{\lstinline!ctime!}:

\begin{lstlisting}[language=Caml]
# ctime (time' ())
Line 1, characters 7-17:
Error: This expression has type time_t but an expression was expected of type
         time_t Ctypes_static.ptr = (time_t, [ `C ]) pointer
\end{lstlisting}

This is because \passthrough{\lstinline!ctime!} needs a pointer to the
\passthrough{\lstinline!time\_t!} rather than passing it by value. We
thus need to allocate some memory for the
\passthrough{\lstinline!time\_t!} and obtain its memory address:

\begin{lstlisting}[language=Caml]
# let t_ptr = allocate time_t (time' ())
...
\end{lstlisting}

The \passthrough{\lstinline!allocate!} function takes the type of the
memory to be allocated and the initial value and it returns a suitably
typed pointer. We can now call \passthrough{\lstinline!ctime!} passing
the pointer as an argument:

\begin{lstlisting}[language=Caml]
# ctime t_ptr
...
\end{lstlisting}

\hypertarget{using-views-to-map-complex-values}{%
\subsubsection{Using Views to Map Complex
Values}\label{using-views-to-map-complex-values}}

While scalar types typically have a 1:1 representation, other C types
require extra work to convert them into OCaml. Views create new C type
descriptions that have special behavior when used to read or write C
values.
\index{mapping/complex values with views}\index{values/mapping complex with
views}

We've already used one view in the definition of
\passthrough{\lstinline!ctime!} earlier. The
\passthrough{\lstinline!string!} view wraps the C type
\passthrough{\lstinline!char *!} (written in OCaml as
\passthrough{\lstinline!ptr char!}) and converts between the C and OCaml
string representations each time the value is written or read.

Here is the type signature of the \passthrough{\lstinline!Ctypes.view!}
function:

\begin{lstlisting}[language=Caml]
val view :
  read:('a -> 'b) ->
  write:('b -> 'a) ->
  'a typ -> 'b typ
\end{lstlisting}

Ctypes has some internal low-level conversion functions that map between
an OCaml \passthrough{\lstinline!string!} and a C character buffer by
copying the contents into the respective data structure. They have the
following type signature:

\begin{lstlisting}[language=Caml]
val string_of_char_ptr : char ptr -> string
val char_ptr_of_string : string -> char ptr
\end{lstlisting}

Given these functions, the definition of the
\passthrough{\lstinline!Ctypes.string!} value that uses views is quite
simple:

\begin{lstlisting}[language=Caml]
let string =
  view (char ptr)
    ~read:string_of_char_ptr
    ~write:char_ptr_of_string
\end{lstlisting}

The type of this \passthrough{\lstinline!string!} function is a normal
\passthrough{\lstinline!typ!} with no external sign of the use of the
view function:

\begin{lstlisting}[language=Caml]
val string    : string.typ
\end{lstlisting}

\hypertarget{ocaml-strings-versus-c-character-buffers}{%
\paragraph{OCaml Strings Versus C Character
Buffers}\label{ocaml-strings-versus-c-character-buffers}}

Although OCaml strings may look like C character buffers from an
interface perspective, they're very different in terms of their memory
representations.

OCaml strings are stored in the OCaml heap with a header that explicitly
defines their length. C buffers are also fixed-length, but by
convention, a C string is terminated by a null (a
\passthrough{\lstinline!\\0!} byte) character. The C string functions
calculate their length by scanning the buffer until the first null
character is encountered.

This means that you need to be careful that OCaml strings that you pass
to C functions don't contain any null values, since the first occurrence
of a null character will be treated as the end of the C string. Ctypes
also defaults to a \emph{copying} interface for strings, which means
that you shouldn't use them when you want the library to mutate the
buffer in-place. In that situation, use the Ctypes
\passthrough{\lstinline!Bigarray!} support to pass memory by reference
instead.

\hypertarget{structs-and-unions}{%
\subsection{Structs and Unions}\label{structs-and-unions}}

The C constructs \passthrough{\lstinline!struct!} and
\passthrough{\lstinline!union!} make it possible to build new types from
existing types. Ctypes contains counterparts that work
similarly.\index{unions}\index{structs and unions/structure
definition}\index{foreign function interface (FFI)/structs and unions}

\hypertarget{defining-a-structure}{%
\subsubsection{Defining a Structure}\label{defining-a-structure}}

Let's improve the timer function that we wrote earlier. The POSIX
function \passthrough{\lstinline!gettimeofday!} retrieves the time with
microsecond resolution. The signature of
\passthrough{\lstinline!gettimeofday!} is as follows, including the
structure definitions:

\begin{lstlisting}
struct timeval {
  long tv_sec;
  long tv_usec;
};

int gettimeofday(struct timeval *, struct timezone *tv);
\end{lstlisting}

Using Ctypes, we can describe this type as follows in our toplevel,
continuing on from the previous definitions:

\begin{lstlisting}[language=Caml]
# type timeval
type timeval
# let timeval : timeval structure typ = structure "timeval"
val timeval : timeval structure typ =
  Ctypes_static.Struct
   {Ctypes_static.tag = "timeval";
    spec = Ctypes_static.Incomplete {Ctypes_static.isize = 0}; fields = []}
\end{lstlisting}

The first command defines a new OCaml type
\passthrough{\lstinline!timeval!} that we'll use to instantiate the
OCaml version of the struct. This is a \emph{phantom type} that exists
only to distinguish the underlying C type from other pointer types. The
particular \passthrough{\lstinline!timeval!} structure now has a
distinct type from other structures we define elsewhere, which helps to
avoid getting them mixed up.

The second command calls \passthrough{\lstinline!structure!} to create a
fresh structure type. At this point, the structure type is incomplete:
we can add fields but cannot yet use it in
\passthrough{\lstinline!foreign!} calls or use it to create values.

\hypertarget{adding-fields-to-structures}{%
\subsubsection{Adding Fields to
Structures}\label{adding-fields-to-structures}}

The \passthrough{\lstinline!timeval!} structure definition still doesn't
have any fields, so we need to add those next:
\index{fields/adding to structures}\index{structs and
unions/field addition}

\begin{lstlisting}[language=Caml]
# let tv_sec  = field timeval "tv_sec" long
val tv_sec : (Signed.long, timeval structure) field =
  {Ctypes_static.ftype = Ctypes_static.Primitive Ctypes_primitive_types.Long;
   foffset = 0; fname = "tv_sec"}
# let tv_usec = field timeval "tv_usec" long
val tv_usec : (Signed.long, timeval structure) field =
  {Ctypes_static.ftype = Ctypes_static.Primitive Ctypes_primitive_types.Long;
   foffset = 8; fname = "tv_usec"}
# seal timeval
- : unit = ()
\end{lstlisting}

The \passthrough{\lstinline!field!} function appends a field to the
structure, as shown with \passthrough{\lstinline!tv\_sec!} and
\passthrough{\lstinline!tv\_usec!}. Structure fields are typed accessors
that are associated with a particular structure, and they correspond to
the labels in C.

Every field addition mutates the structure variable and records a new
size (the exact value of which depends on the type of the field that was
just added). Once we \passthrough{\lstinline!seal!} the structure, we
will be able to create values using it, but adding fields to a sealed
structure is an error.

\hypertarget{incomplete-structure-definitions}{%
\subsubsection{Incomplete Structure
Definitions}\label{incomplete-structure-definitions}}

Since \passthrough{\lstinline!gettimeofday!} needs a
\passthrough{\lstinline!struct timezone!} pointer for its second
argument, we also need to define a second structure type:
\index{structs and
unions/incomplete structure definitions}

\begin{lstlisting}[language=Caml]
# type timezone
type timezone
# let timezone : timezone structure typ = structure "timezone"
val timezone : timezone structure typ =
  Ctypes_static.Struct
   {Ctypes_static.tag = "timezone";
    spec = Ctypes_static.Incomplete {Ctypes_static.isize = 0}; fields = []}
\end{lstlisting}

We don't ever need to create \passthrough{\lstinline!struct timezone!}
values, so we can leave this struct as incomplete without adding any
fields or sealing it. If you ever try to use it in a situation where its
concrete size needs to be known, the library will raise an
\passthrough{\lstinline!IncompleteType!} exception.

We're finally ready to bind to \passthrough{\lstinline!gettimeofday!}
now:

\begin{lstlisting}[language=Caml]
# let gettimeofday = foreign "gettimeofday" ~check_errno:true
  (ptr timeval @-> ptr timezone @-> returning int)
val gettimeofday :
  timeval structure Ctypes_static.ptr ->
  timezone structure Ctypes_static.ptr -> int = <fun>
\end{lstlisting}

There's one other new feature here: the
\passthrough{\lstinline!returning\_checking\_errno!} function behaves
like \passthrough{\lstinline!returning!}, except that it checks whether
the bound C function modifies the C error flag. Changes to
\passthrough{\lstinline!errno!} are mapped into OCaml exceptions and
raise a \passthrough{\lstinline!Unix.Unix\_error!} exception just as the
standard library functions do.

As before, we can create a wrapper to make
\passthrough{\lstinline!gettimeofday!} easier to use. The functions
\passthrough{\lstinline!make!}, \passthrough{\lstinline!addr!}, and
\passthrough{\lstinline!getf!} create a structure value, retrieve the
address of a structure value, and retrieve the value of a field from a
structure:

\begin{lstlisting}[language=Caml]
# let gettimeofday' () =
    let tv = make timeval in
    ignore(gettimeofday (addr tv) (from_voidp timezone null) : int);
    let secs = Signed.Long.(to_int (getf tv tv_sec)) in
    let usecs = Signed.Long.(to_int (getf tv tv_usec)) in
    Caml.Pervasives.(float secs +. float usecs /. 1000000.0)
val gettimeofday' : unit -> float = <fun>
# gettimeofday' ()
- : float = 1516746708.884176
\end{lstlisting}

You need to be a little careful not to get all the open modules mixed up
here. Both \passthrough{\lstinline!Pervasives!} and
\passthrough{\lstinline!Ctypes!} define different
\passthrough{\lstinline!float!} functions. The
\passthrough{\lstinline!Ctypes!} module we opened up earlier overrides
the \passthrough{\lstinline!Pervasives!} definition. As seen previously
though, you just need to locally open
\passthrough{\lstinline!Pervasives!} again to bring the usual
\passthrough{\lstinline!float!} function back in scope.

\hypertarget{recap-a-time-printing-command}{%
\paragraph{Recap: A time-printing
command}\label{recap-a-time-printing-command}}

We built up a lot of bindings in the previous section, so let's recap
them with a complete example that ties it together with a command-line
frontend: \index{structs and unions/time-printing command}

\begin{lstlisting}[language=Caml]
open Core
open Ctypes
open PosixTypes
open Foreign

let time     = foreign "time" (ptr time_t @-> returning time_t)
let difftime = foreign "difftime" (time_t @-> time_t @-> returning double)
let ctime    = foreign "ctime" (ptr time_t @-> returning string)

type timeval
let timeval : timeval structure typ = structure "timeval"
let tv_sec   = field timeval "tv_sec" long
let tv_usec  = field timeval "tv_usec" long
let ()       = seal timeval

type timezone
let timezone : timezone structure typ = structure "timezone"

let gettimeofday = foreign "gettimeofday" ~check_errno:true
    (ptr timeval @-> ptr timezone @-> returning int)

let time' () = time (from_voidp time_t null)

let gettimeofday' () =
  let tv = make timeval in
  ignore(gettimeofday (addr tv) (from_voidp timezone null));
  let secs = Signed.Long.(to_int (getf tv tv_sec)) in
  let usecs = Signed.Long.(to_int (getf tv tv_usec)) in
  Pervasives.(float secs +. float usecs /. 1_000_000.)

let float_time () = printf "%f%!\n" (gettimeofday' ())

let ascii_time () =
  let t_ptr = allocate time_t (time' ()) in
  printf "%s%!" (ctime t_ptr)

let () =
  let open Command in
  basic_spec ~summary:"Display the current time in various formats"
    Spec.(empty +> flag "-a" no_arg ~doc:" Human-readable output format")
    (fun human -> if human then ascii_time else float_time)
  |> Command.run
\end{lstlisting}

This can be compiled and run in the usual way:
\index{returning function}

\begin{lstlisting}
(executable
  (name      datetime)
  (libraries core ctypes-foreign.threaded))
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ dune build datetime.exe
$ ./_build/default/datetime.exe
1520339271.364367
$ ./_build/default/datetime.exe -a
Tue Mar  6 13:27:51 2018
\end{lstlisting}

\hypertarget{why-do-we-need-to-use-returning}{%
\subparagraph{Why Do We Need to Use
returning?}\label{why-do-we-need-to-use-returning}}

The alert reader may be curious about why all these function definitions
have to be terminated by \passthrough{\lstinline!returning!}:

\begin{lstlisting}[language=Caml]
(* correct types *)
val time: ptr time_t @-> returning time_t
val difftime: time_t @-> time_t @-> returning double
\end{lstlisting}

The \passthrough{\lstinline!returning!} function may appear superfluous
here. Why couldn't we simply give the types as follows?

\begin{lstlisting}[language=Caml]
(* incorrect types *)
val time: ptr time_t @-> time_t
val difftime: time_t @-> time_t @-> double
\end{lstlisting}

The reason involves higher types and two differences between the way
that functions are treated in OCaml and C. Functions are first-class
values in OCaml, but not in C. For example, in C it is possible to
return a function pointer from a function, but not to return an actual
function.

Secondly, OCaml functions are typically defined in a curried style. The
signature of a two-argument function is written as follows:

\begin{lstlisting}[language=Caml]
val curried : int -> int -> int
\end{lstlisting}

but this really means:

\begin{lstlisting}[language=Caml]
val curried : int -> (int -> int)
\end{lstlisting}

and the arguments can be supplied one at a time to create a closure. In
contrast, C functions receive their arguments all at once. The
equivalent C function type is the following:

\begin{lstlisting}
int uncurried_C(int, int);
\end{lstlisting}

and the arguments must always be supplied together:

\begin{lstlisting}
uncurried_C(3, 4);
\end{lstlisting}

A C function that's written in curried style looks very different:

\begin{lstlisting}
/* A function that accepts an int, and returns a function
   pointer that accepts a second int and returns an int. */
typedef int (function_t)(int);
function_t *curried_C(int);

/* supply both arguments */
curried_C(3)(4);

/* supply one argument at a time */
function_t *f = curried_C(3); f(4);
\end{lstlisting}

The OCaml type of \passthrough{\lstinline!uncurried\_C!} when bound by
Ctypes is \passthrough{\lstinline!int -> int -> int!}: a two-argument
function. The OCaml type of \passthrough{\lstinline!curried\_C!} when
bound by \passthrough{\lstinline!ctypes!} is
\passthrough{\lstinline!int -> (int -> int)!}: a one-argument function
that returns a one-argument function.

In OCaml, of course, these types are absolutely equivalent. Since the
OCaml types are the same but the C semantics are quite different, we
need some kind of marker to distinguish the cases. This is the purpose
of \passthrough{\lstinline!returning!} in function definitions.

\hypertarget{defining-arrays}{%
\subsubsection{Defining Arrays}\label{defining-arrays}}

Arrays in C are contiguous blocks of the same type of value. Any of the
basic types defined previously can be allocated as blocks via the
\passthrough{\lstinline!Array!} module:
\index{arrays/definition of}\index{structs and unions/array definition}

\begin{lstlisting}[language=Caml]
module Array : sig
  type 'a t = 'a array

  val get : 'a t -> int -> 'a
  val set : 'a t -> int -> 'a -> unit
  val of_list : 'a typ -> 'a list -> 'a t
  val to_list : 'a t -> 'a list
  val length : 'a t -> int
  val start : 'a t -> 'a ptr
  val from_ptr : 'a ptr -> int -> 'a t
  val make : 'a typ -> ?initial:'a -> int -> 'a t
end
\end{lstlisting}

The array functions are similar to those in the standard library
\passthrough{\lstinline!Array!} module except that they operate on
arrays stored using the flat C representation rather than the OCaml
representation described in
\href{runtime-memory-layout.html\#memory-representation-of-values}{Memory
Representation Of Values}.

As with standard OCaml arrays, the conversion between arrays and lists
requires copying the values, which can be expensive for large data
structures. Notice that you can also convert an array into a
\passthrough{\lstinline!ptr!} pointer to the head of the underlying
buffer, which can be useful if you need to pass the pointer and size
arguments separately to a C function.

Unions in C are named structures that can be mapped onto the same
underlying memory. They are also fully supported in Ctypes, but we won't
go into more detail here.
\index{operators/controlling pointers}\index{pointers/operators
controlling}

\hypertarget{pointer-operators-for-dereferencing-and-arithmetic}{%
\subparagraph{Pointer Operators for Dereferencing and
Arithmetic}\label{pointer-operators-for-dereferencing-and-arithmetic}}

Ctypes defines a number of operators that let you manipulate pointers
and arrays just as you would in C. The Ctypes equivalents do have the
benefit of being more strongly typed, of course (see
\href{foreign-function-interface.html\#Table19sub1}{Table19sub1}).

\hypertarget{Table19sub1}{}
\begin{longtable}[]{@{}ll@{}}
\caption{Operators for manipulating pointers and arrays}\tabularnewline
\toprule
\begin{minipage}[b]{0.50\columnwidth}\raggedright
Operator\strut
\end{minipage} & \begin{minipage}[b]{0.44\columnwidth}\raggedright
Purpose\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.50\columnwidth}\raggedright
Operator\strut
\end{minipage} & \begin{minipage}[b]{0.44\columnwidth}\raggedright
Purpose\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.50\columnwidth}\raggedright
\passthrough{\lstinline"!@ p"}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright
Dereference the pointer \passthrough{\lstinline!p!}.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.50\columnwidth}\raggedright
\passthrough{\lstinline!p <-@ v!}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright
Write the value \passthrough{\lstinline!v!} to the address
\passthrough{\lstinline!p!}.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.50\columnwidth}\raggedright
\passthrough{\lstinline!p +@ n!}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright
If \passthrough{\lstinline!p!} points to an array element, then compute
the address of the \passthrough{\lstinline!n!}th next element.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.50\columnwidth}\raggedright
\passthrough{\lstinline!p -@ n!}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright
If \passthrough{\lstinline!p!} points to an array element, then compute
the address of the \passthrough{\lstinline!n!}th previous element.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

There are also other useful nonoperator functions available (see the
Ctypes documentation), such as pointer differencing and comparison.

\hypertarget{passing-functions-to-c}{%
\subsection{Passing Functions to C}\label{passing-functions-to-c}}

It's also straightforward to pass OCaml function values to C. The C
standard library function \passthrough{\lstinline!qsort!} sorts arrays
of elements using a comparison function passed in as a function pointer.
The signature for \passthrough{\lstinline!qsort!}
is:\index{functions/passing to C}\index{foreign function interface (FFI)/passing
functions to C}

\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size,
           int(*compar)(const void *, const void *));
\end{lstlisting}

C programmers often use \passthrough{\lstinline!typedef!} to make type
definitions involving function pointers easier to read. Using a typedef,
the type of \passthrough{\lstinline!qsort!} looks a little more
palatable:

\begin{lstlisting}
typedef int(compare_t)(const void *, const void *);

void qsort(void *base, size_t nmemb, size_t size, compare_t *);
\end{lstlisting}

This also happens to be a close mapping to the corresponding Ctypes
definition. Since type descriptions are regular values, we can just use
\passthrough{\lstinline!let!} in place of
\passthrough{\lstinline!typedef!} and end up with working OCaml bindings
to \passthrough{\lstinline!qsort!}:

\begin{lstlisting}[language=Caml]
# open Ctypes
# open PosixTypes
# open Foreign
# let compare_t = ptr void @-> ptr void @-> returning int
val compare_t : (unit Ctypes_static.ptr -> unit Ctypes_static.ptr -> int) fn =
  Ctypes_static.Function (Ctypes_static.Pointer Ctypes_static.Void,
   Ctypes_static.Function (Ctypes_static.Pointer Ctypes_static.Void,
    Ctypes_static.Returns
     (Ctypes_static.Primitive Ctypes_primitive_types.Int)))
# let qsort = foreign "qsort"
                (ptr void @-> size_t @-> size_t @->
  funptr compare_t @-> returning void)
val qsort :
  unit Ctypes_static.ptr ->
  size_t ->
  size_t -> (unit Ctypes_static.ptr -> unit Ctypes_static.ptr -> int) -> unit =
  <fun>
\end{lstlisting}

We only use \passthrough{\lstinline!compare\_t!} once (in the
\passthrough{\lstinline!qsort!} definition), so you can choose to inline
it in the OCaml code if you prefer. As the type shows, the resulting
\passthrough{\lstinline!qsort!} value is a higher-order function, since
the fourth argument is itself a function. As before, let's define a
wrapper function to make \passthrough{\lstinline!qsort!} easier to use.
The second and third arguments to \passthrough{\lstinline!qsort!}
specify the length (number of elements) of the array and the element
size.

Arrays created using Ctypes have a richer runtime structure than C
arrays, so we don't need to pass size information around. Furthermore,
we can use OCaml polymorphism in place of the unsafe
\passthrough{\lstinline!void ptr!} type.

\hypertarget{example-a-command-line-quicksort}{%
\subsubsection{Example: A Command-Line
Quicksort}\label{example-a-command-line-quicksort}}

The following is a command-line tool that uses the
\passthrough{\lstinline!qsort!} binding to sort all of the integers
supplied on the standard input: \index{qsort binding}

\begin{lstlisting}[language=Caml]
open Core
open Ctypes
open PosixTypes
open Foreign

let compare_t = ptr void @-> ptr void @-> returning int

let qsort = foreign "qsort"
    (ptr void @-> size_t @-> size_t @-> funptr compare_t @->
       returning void)

let qsort' cmp arr =
  let open Unsigned.Size_t in
  let ty = CArray.element_type arr in
  let len = of_int (CArray.length arr) in
  let elsize = of_int (sizeof ty) in
  let start = to_voidp (CArray.start arr) in
  let compare l r = cmp (!@ (from_voidp ty l)) (!@ (from_voidp ty r)) in
  qsort start len elsize compare;
  arr

let sort_stdin () =
  In_channel.input_lines In_channel.stdin
  |> List.map ~f:int_of_string
  |> CArray.of_list int
  |> qsort' Int.compare
  |> CArray.to_list
  |> List.iter ~f:(fun a -> printf "%d\n" a)

let () =
  Command.basic_spec ~summary:"Sort integers on standard input"
    Command.Spec.empty sort_stdin
  |> Command.run
\end{lstlisting}

Compile it in the usual way with \emph{dune} and test it against some
input data, and also build the inferred interface so we can examine it
more closely:

\begin{lstlisting}
(executable
  (name      qsort)
  (libraries core ctypes-foreign.threaded))
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ dune build qsort.exe
$ cat input.txt
2
4
1
3
$ ./_build/default/qsort.exe < input.txt
1
2
3
4
$ corebuild -pkg ctypes-foreign qsort.inferred.mli
ocamlfind ocamldep -package ctypes-foreign -package core -ppx 'ppx-jane -as-ppx' -modules qsort.ml > qsort.ml.depends
ocamlfind ocamlc -i -thread -short-paths -package ctypes-foreign -package core -ppx 'ppx-jane -as-ppx' qsort.ml > qsort.inferred.mli
$ cp _build/qsort.inferred.mli qsort.mli
\end{lstlisting}

The inferred interface shows us the types of the raw
\passthrough{\lstinline!qsort!} binding and also the
\passthrough{\lstinline!qsort'!} wrapper function:

\begin{lstlisting}[language=Caml]
val compare_t :
  (unit Ctypes_static.ptr -> unit Ctypes_static.ptr -> int) Ctypes_static.fn
val qsort :
  unit Ctypes_static.ptr ->
  PosixTypes.size_t ->
  PosixTypes.size_t ->
  (unit Ctypes_static.ptr -> unit Ctypes_static.ptr -> int) -> unit
val qsort' :
  ('a -> 'a -> int) -> 'a Ctypes_static.carray -> 'a Ctypes_static.carray
val sort_stdin : unit -> unit
\end{lstlisting}

The \passthrough{\lstinline!qsort'!} wrapper function has a much more
canonical OCaml interface than the raw binding. It accepts a comparator
function and a Ctypes array, and returns the same Ctypes array. It's not
strictly required that it returns the array, since it modifies it
in-place, but it makes it easier to chain the function using the
\passthrough{\lstinline!|>!} operator (as
\passthrough{\lstinline!sort\_stdin!} does in the example).

Using \passthrough{\lstinline!qsort'!} to sort arrays is
straightforward. Our example code reads the standard input as a list,
converts it to a C array, passes it through qsort, and outputs the
result to the standard output. Again, remember to not confuse the
\passthrough{\lstinline!Ctypes.Array!} module with the
\passthrough{\lstinline!Core.Array!} module: the former is in scope
since we opened \passthrough{\lstinline!Ctypes!} at the start of the
file.\index{memory/and allocated
Ctypes}\index{Ctypes library/lifetime of allocated Ctypes}\index{garbage
collection/of allocated Ctypes}

\hypertarget{lifetime-of-allocated-ctypes}{%
\subparagraph{Lifetime of Allocated
Ctypes}\label{lifetime-of-allocated-ctypes}}

Values allocated via Ctypes (i.e., using
\passthrough{\lstinline!allocate!},
\passthrough{\lstinline!Array.make!}, and so on) will not be
garbage-collected as long as they are reachable from OCaml values. The
system memory they occupy is freed when they do become unreachable, via
a finalizer function registered with the garbage collector (GC).

The definition of reachability for Ctypes values is a little different
from conventional OCaml values, though. The allocation functions return
an OCaml-managed pointer to the value, and as long as some derivative
pointer is still reachable by the GC, the value won't be collected.

``Derivative'' means a pointer that's computed from the original pointer
via arithmetic, so a reachable reference to an array element or a
structure field protects the whole object from collection.

A corollary of the preceding rule is that pointers written into the C
heap don't have any effect on reachability. For example, if you have a
C-managed array of pointers to structs, then you'll need some additional
way of keeping the structs themselves around to protect them from
collection. You could achieve this via a global array of values on the
OCaml side that would keep them live until they're no longer needed.

Functions passed to C have similar considerations regarding lifetime. On
the OCaml side, functions created at runtime may be collected when they
become unreachable. As we've seen, OCaml functions passed to C are
converted to function pointers, and function pointers written into the C
heap have no effect on the reachability of the OCaml functions they
reference. With \passthrough{\lstinline!qsort!} things are
straightforward, since the comparison function is only used during the
call to \passthrough{\lstinline!qsort!} itself. However, other C
libraries may store function pointers in global variables or elsewhere,
in which case you'll need to take care that the OCaml functions you pass
to them aren't prematurely garbage-collected.

\hypertarget{learning-more-about-c-bindings}{%
\subsection{Learning More About C
Bindings}\label{learning-more-about-c-bindings}}

The Ctypes \href{http://github.com/ocamllabs/ocaml-ctypes}{distribution}
contains a number of larger-scale examples, including:
\index{foreign function interface
(FFI)/C bindings}

\begin{itemize}
\item
  Bindings to the POSIX \passthrough{\lstinline!fts!} API, which
  demonstrates C callbacks more comprehensively
\item
  A more complete Ncurses binding than the example we opened the chapter
  with
\item
  A comprehensive test suite that covers the complete library, and can
  provide useful snippets for your own bindings
\end{itemize}

This chapter hasn't really needed you to understand the innards of OCaml
at all. Ctypes does its best to make function bindings easy, but the
rest of this part will also fill you in about interactions with OCaml
memory layout in
\href{runtime-memory-layout.html\#memory-representation-of-values}{Memory
Representation Of Values} and automatic memory management in
\href{garbage-collector.html\#understanding-the-garbage-collector}{Understanding
The Garbage Collector}.

Ctypes gives OCaml programs access to the C representation of values,
shielding you from the details of the OCaml value representation, and
introduces an abstraction layer that hides the details of foreign calls.
While this covers a wide variety of situations, it's sometimes necessary
to look behind the abstraction to obtain finer control over the details
of the interaction between the two languages.

You can find more information about the C interface in several places:

\begin{itemize}
\item
  The standard OCaml foreign function interface allows you to glue OCaml
  and C together from the other side of the boundary, by writing C
  functions that operate on the OCaml representation of values. You can
  find details of the standard interface in the
  \href{http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual033.html}{OCaml
  manual} and in the book
  \href{http://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf}{\emph{Developing
  Applications with Objective Caml}}.
\item
  Florent Monnier maintains an excellent online
  \href{http://www.linux-nantes.org/~fmonnier/ocaml/ocaml-wrapping-c.html}{OCaml}
  that provides examples of how to call OCaml functions from C. This
  covers a wide variety of OCaml data types and also more complex
  callbacks between C and OCaml.
\item
  \href{http://www.swig.org}{SWIG} is a tool that connects programs
  written in C/C++ to a variety of higher-level programming languages,
  including OCaml. The SWIG manual has examples of converting library
  specifications into OCaml bindings.
\end{itemize}

\hypertarget{struct-memory-layout}{%
\subsubsection{Struct Memory Layout}\label{struct-memory-layout}}

The C language gives implementations a certain amount of freedom in
choosing how to lay out structs in memory. There may be padding between
members and at the end of the struct, in order to satisfy the memory
alignment requirements of the host platform. Ctypes uses
platform-appropriate size and alignment information to replicate the
struct layout process. OCaml and C will have consistent views about the
layout of the struct as long as you declare the fields of a struct in
the same order and with the same types as the C library you're binding
to. \index{memory/layout for structs}\index{structs and
unions/memory layout of}

However, this approach can lead to difficulties when the fields of a
struct aren't fully specified in the interface of a library. The
interface may list the fields of a structure without specifying their
order, or make certain fields available only on certain platforms, or
insert undocumented fields into struct definitions for performance
reasons. For example, the \passthrough{\lstinline!struct timeval!}
definition used in this chapter accurately describes the layout of the
struct on common platforms, but implementations on some more unusual
architectures include additional padding members that will lead to
strange behavior in the examples.

The Cstubs subpackage of Ctypes addresses this issue. Rather than simply
assuming that struct definitions given by the user accurately reflect
the actual definitions of structs used in C libraries, Cstubs generates
code that uses the C library headers to discover the layout of the
struct. The good news is that the code that you write doesn't need to
change much. Cstubs provides alternative implementations of the
\passthrough{\lstinline!field!} and \passthrough{\lstinline!seal!}
functions that you've already used to describe
\passthrough{\lstinline!struct timeval!}; instead of computing member
offsets and sizes appropriate for the platform, these implementations
obtain them directly from C.

The details of using Cstubs are available in the online
\href{https://ocamllabs.github.io/ocaml-ctypes}{documentation}, along
with instructions on integration with \passthrough{\lstinline!autoconf!}
platform portability instructions.~
