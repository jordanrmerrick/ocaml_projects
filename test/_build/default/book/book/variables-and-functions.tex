\hypertarget{variables-and-functions}{%
\section{Variables and Functions}\label{variables-and-functions}}

Variables and functions are fundamental ideas that show up in virtually
all programming languages. OCaml has a different take on these concepts
than most languages you're likely to have encountered, so this chapter
will cover OCaml's approach to variables and functions in some detail,
starting with the basics of how to define a variable, and ending with
the intricacies of functions with labeled and optional arguments.

Don't be discouraged if you find yourself overwhelmed by some of the
details, especially toward the end of the chapter. The concepts here are
important, but if they don't connect for you on your first read, you
should return to this chapter after you've gotten a better sense of the
rest of the language.

\hypertarget{variables}{%
\subsection{Variables}\label{variables}}

At its simplest, a variable is an identifier whose meaning is bound to a
particular value. In OCaml these bindings are often introduced using the
\passthrough{\lstinline!let!} keyword. We can type a so-called
\emph{top-level}\passthrough{\lstinline!let!} binding with the following
syntax. Note that variable names must start with a lowercase letter or
an underscore.
\index{bindings/top-level}\index{top-level bindings}\index{let
syntax/top-level bindings}

\begin{lstlisting}
let <variable> = <expr>
\end{lstlisting}

As we'll see when we get to the module system in
\href{files-modules-and-programs.html\#files-modules-and-programs}{Files
Modules And Programs}, this same syntax is used for
\passthrough{\lstinline!let!} bindings at the top level of a module.

Every variable binding has a \emph{scope}, which is the portion of the
code that can refer to that binding. When using
\passthrough{\lstinline!utop!}, the scope of a top-level
\passthrough{\lstinline!let!} binding is everything that follows it in
the session. When it shows up in a module, the scope is the remainder of
that module.\index{variables/scope
of}\index{bindings/scope of}\index{scope}

Here's a simple example.

\begin{lstlisting}[language=Caml]
# open Base
# let x = 3
val x : int = 3
# let y = 4
val y : int = 4
# let z = x + y
val z : int = 7
\end{lstlisting}

\passthrough{\lstinline!let!} can also be used to create a variable
binding whose scope is limited to a particular expression, using the
following syntax.

\begin{lstlisting}
let <variable> = <expr1> in <expr2>
\end{lstlisting}

This first evaluates \emph{\passthrough{\lstinline!expr1!}} and then
evaluates \emph{\passthrough{\lstinline!expr2!}} with
\emph{\passthrough{\lstinline!variable!}} bound to whatever value was
produced by the evaluation of \emph{\passthrough{\lstinline!expr1!}}.
Here's how it looks in practice.

\begin{lstlisting}[language=Caml]
# let languages = "OCaml,Perl,C++,C"
val languages : string = "OCaml,Perl,C++,C"
# let dashed_languages =
    let language_list = String.split languages ~on:',' in
    String.concat ~sep:"-" language_list
val dashed_languages : string = "OCaml-Perl-C++-C"
\end{lstlisting}

Note that the scope of \passthrough{\lstinline!language\_list!} is just
the expression
\passthrough{\lstinline!String.concat \~sep:"-" language\_list!} and is
not available at the toplevel, as we can see if we try to access it now.

\begin{lstlisting}[language=Caml]
# language_list
Line 1, characters 1-14:
Error: Unbound value language_list
\end{lstlisting}

A \passthrough{\lstinline!let!} binding in an inner scope can
\emph{shadow}, or hide, the definition from an outer scope. So, for
example, we could have written the
\passthrough{\lstinline!dashed\_languages!} example as follows.
\index{variables/shadowing of}\index{shadowing}

\begin{lstlisting}[language=Caml]
# let languages = "OCaml,Perl,C++,C"
val languages : string = "OCaml,Perl,C++,C"
# let dashed_languages =
    let languages = String.split languages ~on:',' in
    String.concat ~sep:"-" languages
val dashed_languages : string = "OCaml-Perl-C++-C"
\end{lstlisting}

This time, in the inner scope we called the list of strings
\passthrough{\lstinline!languages!} instead of
\passthrough{\lstinline!language\_list!}, thus hiding the original
definition of \passthrough{\lstinline!languages!}. But once the
definition of \passthrough{\lstinline!dashed\_languages!} is complete,
the inner scope has closed and the original definition of languages is
still available.

\begin{lstlisting}[language=Caml]
# languages
- : string = "OCaml,Perl,C++,C"
\end{lstlisting}

One common idiom is to use a series of nested
\passthrough{\lstinline!let!}/\passthrough{\lstinline!in!} expressions
to build up the components of a larger computation. Thus, we might
write. \index{let
syntax/nested bindings}\index{nested let binding}

\begin{lstlisting}[language=Caml]
# let area_of_ring inner_radius outer_radius =
    let pi = Float.pi in
    let area_of_circle r = pi *. r *. r in
    area_of_circle outer_radius -. area_of_circle inner_radius
val area_of_ring : float -> float -> float = <fun>
# area_of_ring 1. 3.
- : float = 25.132741228718345
\end{lstlisting}

It's important not to confuse a sequence of
\passthrough{\lstinline!let!} bindings with the modification of a
mutable variable. For example, consider how
\passthrough{\lstinline!area\_of\_ring!} would work if we had instead
written this purposefully confusing bit of code:

\begin{lstlisting}[language=Caml]
# let area_of_ring inner_radius outer_radius =
    let pi = Float.pi in
    let area_of_circle r = pi *. r *. r in
    let pi = 0. in
    area_of_circle outer_radius -. area_of_circle inner_radius
Line 4, characters 9-11:
Warning 26: unused variable pi.
val area_of_ring : float -> float -> float = <fun>
\end{lstlisting}

Here, we redefined \passthrough{\lstinline!pi!} to be zero after the
definition of \passthrough{\lstinline!area\_of\_circle!}. You might
think that this would mean that the result of the computation would now
be zero, but in fact, the behavior of the function is unchanged. That's
because the original definition of \passthrough{\lstinline!pi!} wasn't
changed; it was just shadowed, which means that any subsequent reference
to \passthrough{\lstinline!pi!} would see the new definition of
\passthrough{\lstinline!pi!} as \passthrough{\lstinline!0!}, but earlier
references would still see the old one. But there is no later use of
\passthrough{\lstinline!pi!}, so the binding of
\passthrough{\lstinline!pi!} to \passthrough{\lstinline!0.!} made no
difference at all. This explains the warning produced by the toplevel
telling us that there is an unused variable.

In OCaml, \passthrough{\lstinline!let!} bindings are immutable. There
are many kinds of mutable values in OCaml, which we'll discuss in
\href{imperative-programming.html\#imperative-programming-1}{Imperative
Programming}, but there are no mutable variables.

\hypertarget{why-dont-variables-vary}{%
\subsubsection{Why Don't Variables
Vary?}\label{why-dont-variables-vary}}

One source of confusion for people new to OCaml is the fact that
variables are immutable. This seems pretty surprising even on linguistic
terms. Isn't the whole point of a variable that it can
vary?\index{variables/immutability
of}

The answer to this is that variables in OCaml (and generally in
functional languages) are really more like variables in an equation than
a variable in an imperative language. If you think about the
mathematical identity \passthrough{\lstinline!x(y + z) = xy + xz!},
there's no notion of mutating the variables \passthrough{\lstinline!x!},
\passthrough{\lstinline!y!}, and \passthrough{\lstinline!z!}. They vary
in the sense that you can instantiate this equation with different
numbers for those variables, and it still holds.

The same is true in a functional language. A function can be applied to
different inputs, and thus its variables will take on different values,
even without mutation.

\hypertarget{pattern-matching-and-let}{%
\subsubsection{Pattern Matching and
let}\label{pattern-matching-and-let}}

Another useful feature of \passthrough{\lstinline!let!} bindings is that
they support the use of \emph{patterns} on the left-hand side. Consider
the following code, which uses \passthrough{\lstinline!List.unzip!}, a
function for converting a list of pairs into a pair of
lists.\index{pattern matching/and let}\index{let syntax/pattern
matching}\index{variables/pattern matching in}

\begin{lstlisting}[language=Caml]
# let (ints,strings) = List.unzip [(1,"one"); (2,"two"); (3,"three")]
val ints : int list = [1; 2; 3]
val strings : string list = ["one"; "two"; "three"]
\end{lstlisting}

Here, \passthrough{\lstinline!(ints,strings)!} is a pattern, and the
\passthrough{\lstinline!let!} binding assigns values to both of the
identifiers that show up in that pattern. A pattern is essentially a
description of the shape of a data structure, where some components are
names to be bound to values. As we saw in
\href{guided-tour.html\#tuples-lists-options-and-pattern-matching}{Tuples
Lists Options And Pattern Matching}, OCaml has patterns for a variety of
different data types.

Using a pattern in a \passthrough{\lstinline!let!} binding makes the
most sense for a pattern that is \emph{irrefutable}, \emph{i.e.}, where
any value of the type in question is guaranteed to match the pattern.
Tuple and record patterns are irrefutable, but list patterns are not.
Consider the following code that implements a function for upper casing
the first element of a comma-separated list.\index{irrefutable
patterns}

\begin{lstlisting}[language=Caml]
# let upcase_first_entry line =
    let (first :: rest) = String.split ~on:',' line in
    String.concat ~sep:"," (String.uppercase first :: rest)
Lines 2-3, characters 5-60:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
val upcase_first_entry : string -> string = <fun>
\end{lstlisting}

This case can't really come up in practice, because
\passthrough{\lstinline!String.split!} always returns a list with at
least one element, even when given the empty string.

\begin{lstlisting}[language=Caml]
# upcase_first_entry "one,two,three"
- : string = "ONE,two,three"
# upcase_first_entry ""
- : string = ""
\end{lstlisting}

But the compiler doesn't know this, and so it emits the warning. It's
generally better to use a \passthrough{\lstinline!match!} statement to
handle such cases explicitly.

\begin{lstlisting}[language=Caml]
# let upcase_first_entry line =
    match String.split ~on:',' line with
    | [] -> assert false (* String.split returns at least one element *)
    | first :: rest -> String.concat ~sep:"," (String.uppercase first :: rest)
val upcase_first_entry : string -> string = <fun>
\end{lstlisting}

Note that this is our first use of \passthrough{\lstinline!assert!},
which is useful for marking cases that should be impossible. We'll
discuss \passthrough{\lstinline!assert!} in more detail in
\href{error-handling.html\#error-handling}{Error Handling}.

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

Given that OCaml is a functional language, it's no surprise that
functions are important and pervasive. Indeed, functions have come up in
almost every example we've done so far. This section will go into more
depth, explaining the details of how OCaml's functions work. As you'll
see, functions in OCaml differ in a variety of ways from what you'll
find in most mainstream languages.

\hypertarget{anonymous-functions}{%
\subsubsection{Anonymous Functions}\label{anonymous-functions}}

We'll start by looking at the most basic style of function declaration
in OCaml: the \emph{anonymous function}. An anonymous function is a
function that is declared without being named. These can be declared
using the \passthrough{\lstinline!fun!} keyword, as shown here.
\index{fun keyword/anonymous functions}\index{anonymous
functions}\index{functions/anonymous functions}

\begin{lstlisting}[language=Caml]
# (fun x -> x + 1)
- : int -> int = <fun>
\end{lstlisting}

Anonymous functions operate in much the same way as named functions. For
example, we can apply an anonymous function to an argument.

\begin{lstlisting}[language=Caml]
# (fun x -> x + 1) 7
- : int = 8
\end{lstlisting}

Or pass it to another function. Passing functions to iteration functions
like \passthrough{\lstinline!List.map!} is probably the most common use
case for anonymous functions.

\begin{lstlisting}[language=Caml]
# List.map ~f:(fun x -> x + 1) [1;2;3]
- : int list = [2; 3; 4]
\end{lstlisting}

You can even stuff a function into a data structure, like a list.

\begin{lstlisting}[language=Caml]
# let transforms = [ String.uppercase; String.lowercase ]
val transforms : (string -> string) list = [<fun>; <fun>]
# List.map ~f:(fun g -> g "Hello World") transforms
- : string list = ["HELLO WORLD"; "hello world"]
\end{lstlisting}

It's worth stopping for a moment to puzzle this example out, since this
kind of higher-order use of functions can be a bit obscure at first.
Notice that \passthrough{\lstinline!(fun g -> g "Hello World")!} is a
function that takes a function as an argument, and then applies that
function to the string \passthrough{\lstinline!"Hello World"!}. The
invocation of \passthrough{\lstinline!List.map!} applies
\passthrough{\lstinline!(fun g -> g "Hello World")!} to the elements of
\passthrough{\lstinline!transforms!}, which are themselves functions.
The returned list containing the results of these function applications.

The key thing to understand is that functions are ordinary values in
OCaml, and you can do everything with them that you'd do with an
ordinary value, including passing them to and returning them from other
functions and storing them in data structures. We even name functions in
the same way that we name other values, by using a
\passthrough{\lstinline!let!} binding.

\begin{lstlisting}[language=Caml]
# let plusone = (fun x -> x + 1)
val plusone : int -> int = <fun>
# plusone 3
- : int = 4
\end{lstlisting}

Defining named functions is so common that there is some syntactic sugar
for it. Thus, the following definition of
\passthrough{\lstinline!plusone!} is equivalent to the previous
definition.

\begin{lstlisting}[language=Caml]
# let plusone x = x + 1
val plusone : int -> int = <fun>
\end{lstlisting}

This is the most common and convenient way to declare a function, but
syntactic niceties aside, the two styles of function definition are
equivalent.

\hypertarget{let-and-fun}{%
\paragraph{let and fun}\label{let-and-fun}}

Functions and \passthrough{\lstinline!let!} bindings have a lot to do
with each other. In some sense, you can think of the parameter of a
function as a variable being bound to the value passed by the caller.
Indeed, the following two expressions are nearly equivalent.
\index{let syntax/functions and}

\begin{lstlisting}[language=Caml]
# (fun x -> x + 1) 7
- : int = 8
# let x = 7 in x + 1
- : int = 8
\end{lstlisting}

This connection is important, and will come up more when programming in
a monadic style, as we'll see in
\href{concurrent-programming.html\#concurrent-programming-with-async}{Concurrent
Programming With Async}.

\hypertarget{multi-argument-functions}{%
\subsubsection{Multiargument functions}\label{multi-argument-functions}}

OCaml of course also supports multiargument functions, such
as:\index{fun
keyword/multi-argument functions}\index{multi-argument
functions}\index{functions/multi-argument functions}

\begin{lstlisting}[language=Caml]
# let abs_diff x y = abs (x - y)
val abs_diff : int -> int -> int = <fun>
# abs_diff 3 4
- : int = 1
\end{lstlisting}

You may find the type signature of \passthrough{\lstinline!abs\_diff!}
with all of its arrows a little hard to parse. To understand what's
going on, let's rewrite \passthrough{\lstinline!abs\_diff!} in an
equivalent form, using the \passthrough{\lstinline!fun!} keyword.

\begin{lstlisting}[language=Caml]
# let abs_diff =
  (fun x -> (fun y -> abs (x - y)))
val abs_diff : int -> int -> int = <fun>
\end{lstlisting}

This rewrite makes it explicit that \passthrough{\lstinline!abs\_diff!}
is actually a function of one argument that returns another function of
one argument, which itself returns the final result. Because the
functions are nested, the inner expression
\passthrough{\lstinline!abs (x - y)!} has access to both
\passthrough{\lstinline!x!}, which was bound by the outer function
application, and \passthrough{\lstinline!y!}, which was bound by the
inner one.

This style of function is called a \emph{curried} function. (Currying is
named after Haskell Curry, a logician who had a significant impact on
the design and theory of programming languages.) The key to interpreting
the type signature of a curried function is the observation that
\passthrough{\lstinline!->!} is right-associative. The type signature of
\passthrough{\lstinline!abs\_diff!} can therefore be parenthesized as
follows. \index{curried functions}\index{functions/curried
functions}

\begin{lstlisting}[language=Caml]
val abs_diff : int -> (int -> int)
\end{lstlisting}

The parentheses don't change the meaning of the signature, but they make
it easier to see the currying.

Currying is more than just a theoretical curiosity. You can make use of
currying to specialize a function by feeding in some of the arguments.
Here's an example where we create a specialized version of
\passthrough{\lstinline!abs\_diff!} that measures the distance of a
given number from \passthrough{\lstinline!3!}.

\begin{lstlisting}[language=Caml]
# let dist_from_3 = abs_diff 3
val dist_from_3 : int -> int = <fun>
# dist_from_3 8
- : int = 5
# dist_from_3 (-1)
- : int = 4
\end{lstlisting}

The practice of applying some of the arguments of a curried function to
get a new function is called \emph{partial
application}.\index{partial application}

Note that the \passthrough{\lstinline!fun!} keyword supports its own
syntax for currying, so the following definition of
\passthrough{\lstinline!abs\_diff!} is equivalent to the previous
one.\index{fun
keyword/currying syntax}

\begin{lstlisting}[language=Caml]
# let abs_diff = (fun x y -> abs (x - y))
val abs_diff : int -> int -> int = <fun>
\end{lstlisting}

You might worry that curried functions are terribly expensive, but this
is not the case. In OCaml, there is no penalty for calling a curried
function with all of its arguments. (Partial application,
unsurprisingly, does have a small extra cost.)

Currying is not the only way of writing a multiargument function in
OCaml. It's also possible to use the different parts of a tuple as
different arguments. So, we could write.

\begin{lstlisting}[language=Caml]
# let abs_diff (x,y) = abs (x - y)
val abs_diff : int * int -> int = <fun>
# abs_diff (3,4)
- : int = 1
\end{lstlisting}

OCaml handles this calling convention efficiently as well. In particular
it does not generally have to allocate a tuple just for the purpose of
sending arguments to a tuple-style function. You can't, however, use
partial application for this style of function.

There are small trade-offs between these two approaches, but most of the
time, one should stick to currying, since it's the default style in the
OCaml world.

\hypertarget{recursive-functions}{%
\subsubsection{Recursive Functions}\label{recursive-functions}}

A function is \emph{recursive} if it refers to itself in its definition.
Recursion is important in any programming language, but is particularly
important in functional languages, because it is the way that you build
looping constructs. (As will be discussed in more detail in
\href{imperative-programming.html\#imperative-programming-1}{Imperative
Programming 1}, OCaml also supports imperative looping constructs like
\passthrough{\lstinline!for!} and \passthrough{\lstinline!while!}, but
these are only useful when using OCaml's imperative
features.)\index{recursive
functions/definition of}\index{functions/recursive functions}

In order to define a recursive function, you need to mark the
\passthrough{\lstinline!let!} binding as recursive with the
\passthrough{\lstinline!rec!} keyword, as shown in this function for
finding the first sequentially repeated element in a
list.\index{rec keyword}

\begin{lstlisting}[language=Caml]
# let rec find_first_repeat list =
    match list with
    | [] | [_] ->
      (* only zero or one elements, so no repeats *)
      None
    | x :: y :: tl ->
      if x = y then Some x else find_first_repeat (y::tl)
val find_first_repeat : int list -> int option = <fun>
\end{lstlisting}

The pattern \passthrough{\lstinline![] | [\_]!} is itself a disjunction
of multiple patterns, otherwise known as an \emph{or-pattern}. An
or-pattern matches if any of the sub-patterns match. In this case,
\passthrough{\lstinline![]!} matches the empty list, and
\passthrough{\lstinline![\_]!} matches any single element list. The
\passthrough{\lstinline!\_!} is there so we don't have to put an
explicit name on that single element.\index{or-patterns}

We can also define multiple mutually recursive values by using
\passthrough{\lstinline!let rec!} combined with the
\passthrough{\lstinline!and!} keyword. Here's a (gratuitously
inefficient) example.

\begin{lstlisting}[language=Caml]
# let rec is_even x =
    if x = 0 then true else is_odd (x - 1)
  and is_odd x =
    if x = 0 then false else is_even (x - 1)
val is_even : int -> bool = <fun>
val is_odd : int -> bool = <fun>
# List.map ~f:is_even [0;1;2;3;4;5]
- : bool list = [true; false; true; false; true; false]
# List.map ~f:is_odd [0;1;2;3;4;5]
- : bool list = [false; true; false; true; false; true]
\end{lstlisting}

OCaml distinguishes between nonrecursive definitions (using
\passthrough{\lstinline!let!}) and recursive definitions (using
\passthrough{\lstinline!let rec!}) largely for technical reasons: the
type-inference algorithm needs to know when a set of function
definitions are mutually recursive, and these have to be marked
explicitly by the programmer.
\index{let syntax/nonrecursive vs. recursive functions}

But this decision has some good effects. For one thing, recursive (and
especially mutually recursive) definitions are harder to reason about
than nonrecursive ones. It's therefore useful that, in the absence of an
explicit \passthrough{\lstinline!rec!}, you can assume that a
\passthrough{\lstinline!let!} binding is nonrecursive, and so can only
build upon previous definitions.

In addition, having a nonrecursive form makes it easier to create a new
definition that extends and supersedes an existing one by shadowing it.

\hypertarget{prefix-and-infix-operators}{%
\subsubsection{Prefix and Infix
Operators}\label{prefix-and-infix-operators}}

So far, we've seen examples of functions used in both prefix and infix
style.\index{operators/prefix and infix operators}\index{infix
operators}\index{prefix operators}\protect\hypertarget{FNCprf}{}{functions/prefix
and infix operators}

\begin{lstlisting}[language=Caml]
# Int.max 3 4  (* prefix *)
- : int = 4
# 3 + 4        (* infix  *)
- : int = 7
\end{lstlisting}

You might not have thought of the second example as an ordinary
function, but it very much is. Infix operators like
\passthrough{\lstinline!+!} really only differ syntactically from other
functions. In fact, if we put parentheses around an infix operator, you
can use it as an ordinary prefix function.

\begin{lstlisting}[language=Caml]
# (+) 3 4
- : int = 7
# List.map ~f:((+) 3) [4;5;6]
- : int list = [7; 8; 9]
\end{lstlisting}

In the second expression, we've partially applied
\passthrough{\lstinline!(+)!} to create a function that increments its
single argument by \passthrough{\lstinline!3!}.

A function is treated syntactically as an operator if the name of that
function is chosen from one of a specialized set of identifiers. This
set includes identifiers that are sequences of characters from the
following set:

\begin{lstlisting}
! $ % & * + - . / : < = > ? @ ^ | ~
\end{lstlisting}

or is one of a handful of predetermined strings, including
\passthrough{\lstinline!mod!}, the modulus operator, and
\passthrough{\lstinline!lsl!}, for ``logical shift left,'' a
bit-shifting operation.

We can define (or redefine) the meaning of an operator. Here's an
example of a simple vector-addition operator on
\passthrough{\lstinline!int!} pairs.

\begin{lstlisting}[language=Caml]
# let (+!) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)
val ( +! ) : int * int -> int * int -> int * int = <fun>
# (3,2) +! (-2,4)
- : int * int = (1, 6)
\end{lstlisting}

Note that you have to be careful when dealing with operators containing
\passthrough{\lstinline!*!}. Consider the following example.

\begin{lstlisting}[language=Caml]
# let (***) x y = (x **. y) **. y
Line 1, characters 18-19:
Error: This expression has type int but an expression was expected of type
         float
\end{lstlisting}

What's going on is that \passthrough{\lstinline!(***)!} isn't
interpreted as an operator at all; it's read as a comment! To get this
to work properly, we need to put spaces around any operator that begins
or ends with \passthrough{\lstinline!*!}.

\begin{lstlisting}[language=Caml]
# let ( *** ) x y = (x **. y) **. y
val ( *** ) : float -> float -> float = <fun>
\end{lstlisting}

The syntactic role of an operator is typically determined by its first
character or two, though there are a few exceptions.
\href{variables-and-functions.html\#table2_1}{Table2\_1} breaks the
different operators and other syntactic forms into groups from highest
to lowest precedence, explaining how each behaves syntactically. We
write \passthrough{\lstinline"!"}\ldots{} to indicate the class of
operators beginning with \passthrough{\lstinline"!"}.

\hypertarget{table2_1}{}
\begin{longtable}[]{@{}ll@{}}
\caption{Precedence and associativity}\tabularnewline
\toprule
Operator prefix & Associativity\tabularnewline
\midrule
\endfirsthead
\toprule
Operator prefix & Associativity\tabularnewline
\midrule
\endhead
\passthrough{\lstinline"!"}\ldots, \passthrough{\lstinline!?!}\ldots,
\passthrough{\lstinline!\~!}\ldots{} & Prefix\tabularnewline
\passthrough{\lstinline!.!}, \passthrough{\lstinline!.(!},
\passthrough{\lstinline!.[!} & -\tabularnewline
function application, constructor, \passthrough{\lstinline!assert!},
\passthrough{\lstinline!lazy!} & Left associative\tabularnewline
\passthrough{\lstinline!-!}, \passthrough{\lstinline!-.!} &
Prefix\tabularnewline
\passthrough{\lstinline!**!}\ldots, \passthrough{\lstinline!lsl!},
\passthrough{\lstinline!lsr!}, \passthrough{\lstinline!asr!} & Right
associative\tabularnewline
\passthrough{\lstinline!*!}\ldots, \passthrough{\lstinline!/!}\ldots,
\passthrough{\lstinline!\%!}\ldots, \passthrough{\lstinline!mod!},
\passthrough{\lstinline!land!}, \passthrough{\lstinline!lor!},
\passthrough{\lstinline!lxor!} & Left associative\tabularnewline
\passthrough{\lstinline!+!}\ldots, \passthrough{\lstinline!-!}\ldots{} &
Left associative\tabularnewline
\passthrough{\lstinline!::!} & Right associative\tabularnewline
\passthrough{\lstinline!@!}\ldots, \passthrough{\lstinline!^!}\ldots{} &
Right associative\tabularnewline
\passthrough{\lstinline!=!}\ldots, \passthrough{\lstinline!<!}\ldots,
\passthrough{\lstinline!>!}\ldots, \passthrough{\lstinline!|!}\ldots,
\passthrough{\lstinline!\&!}\ldots, \passthrough{\lstinline!$!}\ldots{}
& Left associative\tabularnewline
\passthrough{\lstinline!\&!}, \passthrough{\lstinline!\&\&!} & Right
associative\tabularnewline
\passthrough{\lstinline!or!}, \passthrough{\lstinline!||!} & Right
associative\tabularnewline
\passthrough{\lstinline!,!} & -\tabularnewline
\passthrough{\lstinline!<-!}, \passthrough{\lstinline!:=!} & Right
associative\tabularnewline
\passthrough{\lstinline!if!} & -\tabularnewline
\passthrough{\lstinline!;!} & Right associative\tabularnewline
\bottomrule
\end{longtable}

There's one important special case: \passthrough{\lstinline!-!} and
\passthrough{\lstinline!-.!}, which are the integer and floating-point
subtraction operators, and can act as both prefix operators (for
negation) and infix operators (for subtraction). So, both
\passthrough{\lstinline!-x!} and \passthrough{\lstinline!x - y!} are
meaningful expressions. Another thing to remember about negation is that
it has lower precedence than function application, which means that if
you want to pass a negative value, you need to wrap it in parentheses,
as you can see in this code.\index{operators/negation
operators}\index{operators/subtraction operators}\index{subtraction
operators}\index{negation operators}

\begin{lstlisting}[language=Caml]
# Int.max 3 (-4)
- : int = 3
# Int.max 3 -4
Line 1, characters 1-10:
Error: This expression has type int -> int
       but an expression was expected of type int
\end{lstlisting}

Here, OCaml is interpreting the second expression as equivalent to.

\begin{lstlisting}[language=Caml]
# (Int.max 3) - 4
Line 1, characters 1-12:
Error: This expression has type int -> int
       but an expression was expected of type int
\end{lstlisting}

which obviously doesn't make sense.

Here's an example of a very useful operator from the standard library
whose behavior depends critically on the precedence rules described
previously.

\begin{lstlisting}[language=Caml]
# let (|>) x f = f x
val ( |> ) : 'a -> ('a -> 'b) -> 'b = <fun>
\end{lstlisting}

It's not quite obvious at first what the purpose of this operator is: it
just takes a value and a function and applies the function to the value.
Despite that bland-sounding description, it has the useful role of a
sequencing operator, similar in spirit to using the pipe character in
the UNIX shell. Consider, for example, the following code for printing
out the unique elements of your \passthrough{\lstinline!PATH!}. Note
that \passthrough{\lstinline!List.dedup\_and\_sort!} that follows
removes duplicates from a list by sorting the list using the provided
comparison function.\index{lists/duplicate removal}\index{duplicates,
removing}\index{List.dedup\_and\_sort}\index{operators/sequencing
operators}

\begin{lstlisting}[language=Caml]
# open Stdio
# let path = "/usr/bin:/usr/local/bin:/bin:/sbin:/usr/bin"
val path : string = "/usr/bin:/usr/local/bin:/bin:/sbin:/usr/bin"
# String.split ~on:':' path
  |> List.dedup_and_sort ~compare:String.compare
  |> List.iter ~f:print_endline
/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
\end{lstlisting}

We can do this without \passthrough{\lstinline!|>!} by naming the
intermediate values, but the result is a bit more verbose.

\begin{lstlisting}[language=Caml]
# let split_path = String.split ~on:':' path in
  let deduped_path = List.dedup_and_sort ~compare:String.compare split_path in
  List.iter ~f:print_endline deduped_path
/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
\end{lstlisting}

An important part of what's happening here is partial application. For
example, \passthrough{\lstinline!List.iter!} takes two arguments: a
function to be called on each element of the list, and the list to
iterate over. We can call \passthrough{\lstinline!List.iter!} with all
its arguments. \index{partial application}

\begin{lstlisting}[language=Caml]
# List.iter ~f:print_endline ["Two"; "lines"]
Two
lines
- : unit = ()
\end{lstlisting}

Or, we can pass it just the function argument, leaving us with a
function for printing out a list of strings.

\begin{lstlisting}[language=Caml]
# List.iter ~f:print_endline
- : string list -> unit = <fun>
\end{lstlisting}

It is this later form that we're using in the preceding
\passthrough{\lstinline!|>!} pipeline.

But \passthrough{\lstinline!|>!} only works in the intended way because
it is left-associative. Let's see what happens if we try using a
right-associative operator, like (\^{}\textgreater).

\begin{lstlisting}[language=Caml]
# let (^>) x f = f x
val ( ^> ) : 'a -> ('a -> 'b) -> 'b = <fun>
# String.split ~on:':' path
  ^> List.dedup_and_sort ~compare:String.compare
  ^> List.iter ~f:print_endline
Line 3, characters 6-32:
Error: This expression has type string list -> unit
       but an expression was expected of type
         (string list -> string list) -> 'a
       Type string list is not compatible with type
         string list -> string list
\end{lstlisting}

The type error is a little bewildering at first glance. What's going on
is that, because \passthrough{\lstinline!^>!} is right associative, the
operator is trying to feed the value
\passthrough{\lstinline!List.dedup\_and\_sort \~compare:String.compare!}
to the function \passthrough{\lstinline!List.iter \~f:print\_endline!}.
But \passthrough{\lstinline!List.iter \~f:print\_endline!} expects a
list of strings as its input, not a function.

The type error aside, this example highlights the importance of choosing
the operator you use with care, particularly with respect to
associativity.~

\hypertarget{declaring-functions-with-function}{%
\subsubsection{\texorpdfstring{Declaring Functions with
\texttt{function}}{Declaring Functions with function}}\label{declaring-functions-with-function}}

Another way to define a function is using the
\passthrough{\lstinline!function!} keyword. Instead of having syntactic
support for declaring multiargument (curried) functions,
\passthrough{\lstinline!function!} has built-in pattern matching. Here's
an example.\index{functions/defining}\index{function
keyword}\index{functions/declaring with function keyword}

\begin{lstlisting}[language=Caml]
# let some_or_zero = function
    | Some x -> x
    | None -> 0
val some_or_zero : int option -> int = <fun>
# List.map ~f:some_or_zero [Some 3; None; Some 4]
- : int list = [3; 0; 4]
\end{lstlisting}

This is equivalent to combining an ordinary function definition with a
\passthrough{\lstinline!match!}.

\begin{lstlisting}[language=Caml]
# let some_or_zero num_opt =
    match num_opt with
    | Some x -> x
    | None -> 0
val some_or_zero : int option -> int = <fun>
\end{lstlisting}

We can also combine the different styles of function declaration
together, as in the following example, where we declare a two-argument
(curried) function with a pattern match on the second argument.

\begin{lstlisting}[language=Caml]
# let some_or_default default = function
    | Some x -> x
    | None -> default
val some_or_default : 'a -> 'a option -> 'a = <fun>
# some_or_default 3 (Some 5)
- : int = 5
# List.map ~f:(some_or_default 100) [Some 3; None; Some 4]
- : int list = [3; 100; 4]
\end{lstlisting}

Also, note the use of partial application to generate the function
passed to \passthrough{\lstinline!List.map!}. In other words,
\passthrough{\lstinline!some\_or\_default 100!} is a function that was
created by feeding just the first argument to
\passthrough{\lstinline!some\_or\_default!}.

\hypertarget{labeled-arguments}{%
\subsubsection{Labeled Arguments}\label{labeled-arguments}}

Up until now, the functions we've defined have specified their arguments
positionally, \emph{i.e.}, by the order in which the arguments are
passed to the function. OCaml also supports labeled arguments, which let
you identify a function argument by name. Indeed, we've already
encountered functions from \passthrough{\lstinline!Base!} like
\passthrough{\lstinline!List.map!} that use labeled arguments. Labeled
arguments are marked by a leading tilde, and a label (followed by a
colon) is put in front of the variable to be labeled. Here's an
example.\index{labeled
arguments}\index{arguments/labeled arguments}\index{functions/labeled
arguments}

\begin{lstlisting}[language=Caml]
# let ratio ~num ~denom = Float.of_int num /. Float.of_int denom
val ratio : num:int -> denom:int -> float = <fun>
\end{lstlisting}

We can then provide a labeled argument using a similar convention. As
you can see, the arguments can be provided in any order.

\begin{lstlisting}[language=Caml]
# ratio ~num:3 ~denom:10
- : float = 0.3
# ratio ~denom:10 ~num:3
- : float = 0.3
\end{lstlisting}

OCaml also supports \emph{label punning}, meaning that you get to drop
the text after the \passthrough{\lstinline!:!} if the name of the label
and the name of the variable being used are the same. We were actually
already using label punning when defining
\passthrough{\lstinline!ratio!}. The following shows how punning can be
used when invoking a function.\index{punning}\index{label punning}

\begin{lstlisting}[language=Caml]
# let num = 3 in
  let denom = 4 in
  ratio ~num ~denom
- : float = 0.75
\end{lstlisting}

Labeled arguments are useful in a few different cases:

\begin{itemize}
\item
  When defining a function with lots of arguments. Beyond a certain
  number, arguments are easier to remember by name than by
  position.\index{functions/with
  multiple arguments}\index{multi-argument functions}
\item
  When the meaning of a particular argument is unclear from the type
  alone. Consider a function for creating a hash table whose first
  argument is the initial size of the array backing the hash table, and
  the second is a Boolean flag, which indicates whether that array will
  ever shrink when elements are removed.
\end{itemize}

\begin{lstlisting}[language=Caml]
val create_hashtable : int -> bool -> ('a,'b) Hashtable.t
\end{lstlisting}

The signature makes it hard to divine the meaning of those two
arguments. but with labeled arguments, we can make the intent
immediately clear.

\begin{lstlisting}[language=Caml]
val create_hashtable :
  init_size:int -> allow_shrinking:bool -> ('a,'b) Hashtable.t
\end{lstlisting}

Choosing label names well is especially important for Boolean values,
since it's often easy to get confused about whether a value being true
is meant to enable or disable a given feature.

\begin{itemize}
\tightlist
\item
  When defining functions that have multiple arguments that might get
  confused with each other. This is most at issue when the arguments are
  of the same type. For example, consider this signature for a function
  that extracts a substring.
\end{itemize}

\begin{lstlisting}[language=Caml]
val substring: string -> int -> int -> string
\end{lstlisting}

Here, the two \passthrough{\lstinline!ints!} are the starting position
and length of the substring to extract, respectively, but you wouldn't
know that from the type signature. We can make the signature more
informative by adding labels.

\begin{lstlisting}[language=Caml]
val substring: string -> pos:int -> len:int -> string
\end{lstlisting}

This improves the readability of both the signature and of client code
that makes use of \passthrough{\lstinline!substring!} and makes it
harder to accidentally swap the position and the length.

\begin{itemize}
\tightlist
\item
  When you want flexibility on the order in which arguments are passed.
  Consider a function like \passthrough{\lstinline!List.iter!}, which
  takes two arguments. a function and a list of elements to call that
  function on. A common pattern is to partially apply
  \passthrough{\lstinline!List.iter!} by giving it just the function, as
  in the following example from earlier in the chapter.
\end{itemize}

\begin{lstlisting}[language=Caml]
# String.split ~on:':' path
  |> List.dedup_and_sort ~compare:String.compare
  |> List.iter ~f:print_endline
/bin
/sbin
/usr/bin
/usr/local/bin
- : unit = ()
\end{lstlisting}

This requires that we put the function argument first. In other cases,
you want to put the function argument second. One common reason is
readability. In particular, a multiline function passed as an argument
to another function is easiest to read when it is the final argument to
that function.

\hypertarget{higher-order-functions-and-labels}{%
\paragraph{Higher-order functions and
labels}\label{higher-order-functions-and-labels}}

One surprising gotcha with labeled arguments is that while order doesn't
matter when calling a function with labeled arguments, it does matter in
a higher-order context, \emph{e.g.}, when passing a function with
labeled arguments to another function. Here's an
example.\index{higher-order functions, and
labels}\index{functions/higher-order and labels}

\begin{lstlisting}[language=Caml]
# let apply_to_tuple f (first,second) = f ~first ~second
val apply_to_tuple : (first:'a -> second:'b -> 'c) -> 'a * 'b -> 'c = <fun>
\end{lstlisting}

Here, the definition of \passthrough{\lstinline!apply\_to\_tuple!} sets
up the expectation that its first argument is a function with two
labeled arguments, \passthrough{\lstinline!first!} and
\passthrough{\lstinline!second!}, listed in that order. We could have
defined \passthrough{\lstinline!apply\_to\_tuple!} differently to change
the order in which the labeled arguments were listed.

\begin{lstlisting}[language=Caml]
# let apply_to_tuple_2 f (first,second) = f ~second ~first
val apply_to_tuple_2 : (second:'a -> first:'b -> 'c) -> 'b * 'a -> 'c = <fun>
\end{lstlisting}

It turns out this order matters. In particular, if we define a function
that has a different order

\begin{lstlisting}[language=Caml]
# let divide ~first ~second = first / second
val divide : first:int -> second:int -> int = <fun>
\end{lstlisting}

we'll find that it can't be passed in to
\passthrough{\lstinline!apply\_to\_tuple\_2!}.

\begin{lstlisting}[language=Caml]
# apply_to_tuple_2 divide (3,4)
Line 1, characters 18-24:
Error: This expression has type first:int -> second:int -> int
       but an expression was expected of type second:'a -> first:'b -> 'c
\end{lstlisting}

But, it works smoothly with the original
\passthrough{\lstinline!apply\_to\_tuple!}.

\begin{lstlisting}[language=Caml]
# let apply_to_tuple f (first,second) = f ~first ~second
val apply_to_tuple : (first:'a -> second:'b -> 'c) -> 'a * 'b -> 'c = <fun>
# apply_to_tuple divide (3,4)
- : int = 0
\end{lstlisting}

As a result, when passing labeled functions as arguments, you need to
take care to be consistent in your ordering of labeled arguments.

\hypertarget{optional-arguments}{%
\subsubsection{Optional Arguments}\label{optional-arguments}}

An optional argument is like a labeled argument that the caller can
choose whether or not to provide. Optional arguments are passed in using
the same syntax as labeled arguments, and, like labeled arguments, can
be provided in any
order.\protect\hypertarget{ARGopt}{}{arguments/optional
arguments}\protect\hypertarget{FNCopt}{}{functions/optional arguments}

Here's an example of a string concatenation function with an optional
separator. This function uses the \passthrough{\lstinline!^!} operator
for pairwise string concatenation.

\begin{lstlisting}[language=Caml]
# let concat ?sep x y =
    let sep = match sep with None -> "" | Some x -> x in
    x ^ sep ^ y
val concat : ?sep:string -> string -> string -> string = <fun>
# concat "foo" "bar"             (* without the optional argument *)
- : string = "foobar"
# concat ~sep:":" "foo" "bar"    (* with the optional argument    *)
- : string = "foo:bar"
\end{lstlisting}

Here, \passthrough{\lstinline!?!} is used in the definition of the
function to mark \passthrough{\lstinline!sep!} as optional. And while
the caller can pass a value of type \passthrough{\lstinline!string!} for
\passthrough{\lstinline!sep!}, internally to the function,
\passthrough{\lstinline!sep!} is seen as a
\passthrough{\lstinline!string option!}, with
\passthrough{\lstinline!None!} appearing when
\passthrough{\lstinline!sep!} is not provided by the caller.

The preceding example needed a bit of boilerplate to choose a default
separator when none was provided. This is a common enough pattern that
there's an explicit syntax for providing a default value, which allows
us to write \passthrough{\lstinline!concat!} more concisely.

\begin{lstlisting}[language=Caml]
# let concat ?(sep="") x y = x ^ sep ^ y
val concat : ?sep:string -> string -> string -> string = <fun>
\end{lstlisting}

Optional arguments are very useful, but they're also easy to abuse. The
key advantage of optional arguments is that they let you write functions
with multiple arguments that users can ignore most of the time, only
worrying about them when they specifically want to invoke those options.
They also allow you to extend an API with new functionality without
changing existing code.

The downside is that the caller may be unaware that there is a choice to
be made, and so may unknowingly (and wrongly) pick the default behavior.
Optional arguments really only make sense when the extra concision of
omitting the argument outweighs the corresponding loss of explicitness.

This means that rarely used functions should not have optional
arguments. A good rule of thumb is to avoid optional arguments for
functions internal to a module, \emph{i.e.}, functions that are not
included in the module's interface, or \passthrough{\lstinline!mli!}
file. We'll learn more about \passthrough{\lstinline!mli!}s in
\href{files-modules-and-programs.html\#files-modules-and-programs}{Files
Modules And Programs}.

\hypertarget{explicit-passing-of-an-optional-argument}{%
\paragraph{Explicit passing of an optional
argument}\label{explicit-passing-of-an-optional-argument}}

Under the covers, a function with an optional argument receives
\passthrough{\lstinline!None!} when the caller doesn't provide the
argument, and \passthrough{\lstinline!Some!} when it does. But the
\passthrough{\lstinline!Some!} and \passthrough{\lstinline!None!} are
normally not explicitly passed in by the caller.

But sometimes, passing in \passthrough{\lstinline!Some!} or
\passthrough{\lstinline!None!} explicitly is exactly what you want.
OCaml lets you do this by using \passthrough{\lstinline!?!} instead of
\passthrough{\lstinline!\~!} to mark the argument. Thus, the following
two lines are equivalent ways of specifying the
\passthrough{\lstinline!sep!} argument to
\passthrough{\lstinline!concat!}.\index{optional arguments/explicit passing of}

\begin{lstlisting}[language=Caml]
# concat ~sep:":" "foo" "bar" (* provide the optional argument *)
- : string = "foo:bar"
# concat ?sep:(Some ":") "foo" "bar" (* pass an explicit [Some] *)
- : string = "foo:bar"
\end{lstlisting}

And the following two lines are equivalent ways of calling
\passthrough{\lstinline!concat!} without specifying
\passthrough{\lstinline!sep!}.

\begin{lstlisting}[language=Caml]
# concat "foo" "bar" (* don't provide the optional argument *)
- : string = "foobar"
# concat ?sep:None "foo" "bar" (* explicitly pass `None` *)
- : string = "foobar"
\end{lstlisting}

One use case for this is when you want to define a wrapper function that
mimics the optional arguments of the function it's wrapping. For
example, imagine we wanted to create a function called
\passthrough{\lstinline!uppercase\_concat!}, which is the same as
\passthrough{\lstinline!concat!} except that it converts the first
string that it's passed to uppercase. We could write the function as
follows.

\begin{lstlisting}[language=Caml]
# let uppercase_concat ?(sep="") a b = concat ~sep (String.uppercase a) b
val uppercase_concat : ?sep:string -> string -> string -> string = <fun>
# uppercase_concat "foo" "bar"
- : string = "FOObar"
# uppercase_concat "foo" "bar" ~sep:":"
- : string = "FOO:bar"
\end{lstlisting}

In the way we've written it, we've been forced to separately make the
decision as to what the default separator is. Thus, if we later change
\passthrough{\lstinline!concat!}'s default behavior, we'll need to
remember to change \passthrough{\lstinline!uppercase\_concat!} to match
it.

Instead, we can have \passthrough{\lstinline!uppercase\_concat!} simply
pass through the optional argument to \passthrough{\lstinline!concat!}
using the \passthrough{\lstinline!?!} syntax.

\begin{lstlisting}[language=Caml]
# let uppercase_concat ?sep a b = concat ?sep (String.uppercase a) b
val uppercase_concat : ?sep:string -> string -> string -> string = <fun>
\end{lstlisting}

Now, if someone calls \passthrough{\lstinline!uppercase\_concat!}
without an argument, an explicit \passthrough{\lstinline!None!} will be
passed to \passthrough{\lstinline!concat!}, leaving
\passthrough{\lstinline!concat!} to decide what the default behavior
should be.

\hypertarget{inference-of-labeled-and-optional-arguments}{%
\paragraph{Inference of labeled and optional
arguments}\label{inference-of-labeled-and-optional-arguments}}

One subtle aspect of labeled and optional arguments is how they are
inferred by the type system. Consider the following example for
computing numerical derivatives of a function of two real variables. The
function takes an argument \passthrough{\lstinline!delta!}, which
determines the scale at which to compute the derivative; values
\passthrough{\lstinline!x!} and \passthrough{\lstinline!y!}, which
determine at which point to compute the derivative; and the function
\passthrough{\lstinline!f!}, whose derivative is being computed. The
function \passthrough{\lstinline!f!} itself takes two labeled arguments,
\passthrough{\lstinline!x!} and \passthrough{\lstinline!y!}. Note that
you can use an apostrophe as part of a variable name, so
\passthrough{\lstinline!x'!} and \passthrough{\lstinline!y'!} are just
ordinary variables.\index{functions/argument inference}\index{labeled
arguments}\index{arguments/inference of}\index{optional arguments/inference
of}

\begin{lstlisting}[language=Caml]
# let numeric_deriv ~delta ~x ~y ~f =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~x:x' ~y -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
val numeric_deriv :
  delta:float ->
  x:float -> y:float -> f:(x:float -> y:float -> float) -> float * float =
  <fun>
\end{lstlisting}

In principle, it's not obvious how the order of the arguments to
\passthrough{\lstinline!f!} should be chosen. Since labeled arguments
can be passed in arbitrary order, it seems like it could as well be
\passthrough{\lstinline!y:float -> x:float -> float!} as it is
\passthrough{\lstinline!x:float -> y:float -> float!}.

Even worse, it would be perfectly consistent for
\passthrough{\lstinline!f!} to take an optional argument instead of a
labeled one, which could lead to this type signature for
\passthrough{\lstinline!numeric\_deriv!}.

\begin{lstlisting}[language=Caml]
val numeric_deriv :
  delta:float ->
  x:float -> y:float -> f:(?x:float -> y:float -> float) -> float * float
\end{lstlisting}

Since there are multiple plausible types to choose from, OCaml needs
some heuristic for choosing between them. The heuristic the compiler
uses is to prefer labels to options and to choose the order of arguments
that shows up in the source code.

Note that these heuristics might at different points in the source
suggest different types. Here's a version of
\passthrough{\lstinline!numeric\_deriv!} where different invocations of
\passthrough{\lstinline!f!} list the arguments in different orders.

\begin{lstlisting}[language=Caml]
# let numeric_deriv ~delta ~x ~y ~f =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~y ~x:x' -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
Line 5, characters 15-16:
Error: This function is applied to arguments
       in an order different from other calls.
       This is only allowed when the real type is known.
\end{lstlisting}

As suggested by the error message, we can get OCaml to accept the fact
that \passthrough{\lstinline!f!} is used with different argument orders
if we provide explicit type information. Thus, the following code
compiles without error, due to the type annotation on
\passthrough{\lstinline!f!}.\index{type annotations}

\begin{lstlisting}[language=Caml]
# let numeric_deriv ~delta ~x ~y ~(f: x:float -> y:float -> float) =
    let x' = x +. delta in
    let y' = y +. delta in
    let base = f ~x ~y in
    let dx = (f ~y ~x:x' -. base) /. delta in
    let dy = (f ~x ~y:y' -. base) /. delta in
    (dx,dy)
val numeric_deriv :
  delta:float ->
  x:float -> y:float -> f:(x:float -> y:float -> float) -> float * float =
  <fun>
\end{lstlisting}

\hypertarget{optional-arguments-and-partial-application}{%
\paragraph{Optional arguments and partial
application}\label{optional-arguments-and-partial-application}}

Optional arguments can be tricky to think about in the presence of
partial application. We can of course partially apply the optional
argument itself.

\begin{lstlisting}[language=Caml]
# let colon_concat = concat ~sep:":"
val colon_concat : string -> string -> string = <fun>
# colon_concat "a" "b"
- : string = "a:b"
\end{lstlisting}

But what happens if we partially apply just the first argument?

\begin{lstlisting}[language=Caml]
# let prepend_pound = concat "# "
val prepend_pound : string -> string = <fun>
# prepend_pound "a BASH comment"
- : string = "# a BASH comment"
\end{lstlisting}

The optional argument \passthrough{\lstinline!?sep!} has now
disappeared, or been \emph{erased}. Indeed, if we try to pass in that
optional argument now, it will be rejected.

\begin{lstlisting}[language=Caml]
# prepend_pound "a BASH comment" ~sep:":"
Line 1, characters 1-14:
Error: This function has type Base.String.t -> Base.String.t
       It is applied to too many arguments; maybe you forgot a `;'.
\end{lstlisting}

So when does OCaml decide to erase an optional argument?

The rule is: an optional argument is erased as soon as the first
positional (i.e., neither labeled nor optional) argument defined
\emph{after} the optional argument is passed in. That explains the
behavior of \passthrough{\lstinline!prepend\_pound!}. But if we had
instead defined \passthrough{\lstinline!concat!} with the optional
argument in the second position.

\begin{lstlisting}[language=Caml]
# let concat x ?(sep="") y = x ^ sep ^ y
val concat : string -> ?sep:string -> string -> string = <fun>
\end{lstlisting}

then application of the first argument would not cause the optional
argument to be erased.

\begin{lstlisting}[language=Caml]
# let prepend_pound = concat "# "
val prepend_pound : ?sep:string -> string -> string = <fun>
# prepend_pound "a BASH comment"
- : string = "# a BASH comment"
# prepend_pound "a BASH comment" ~sep:"--- "
- : string = "# --- a BASH comment"
\end{lstlisting}

However, if all arguments to a function are presented at once, then
erasure of optional arguments isn't applied until all of the arguments
are passed in. This preserves our ability to pass in optional arguments
anywhere on the argument list. Thus, we can write.

\begin{lstlisting}[language=Caml]
# concat "a" "b" ~sep:"="
- : string = "a=b"
\end{lstlisting}

An optional argument that doesn't have any following positional
arguments can't be erased at all, which leads to a compiler warning.

\begin{lstlisting}[language=Caml]
# let concat x y ?(sep="") = x ^ sep ^ y
Line 1, characters 18-24:
Warning 16: this optional argument cannot be erased.
val concat : string -> string -> ?sep:string -> string = <fun>
\end{lstlisting}

And indeed, when we provide the two positional arguments, the
\passthrough{\lstinline!sep!} argument is not erased, instead returning
a function that expects the \passthrough{\lstinline!sep!} argument to be
provided.

\begin{lstlisting}[language=Caml]
# concat "a" "b"
- : ?sep:string -> string = <fun>
\end{lstlisting}

As you can see, OCaml's support for labeled and optional arguments is
not without its complexities. But don't let these complexities obscure
the usefulness of these features. Labels and optional arguments are very
effective tools for making your APIs both more convenient and safer, and
it's worth the effort of learning how to use them effectively.~~
