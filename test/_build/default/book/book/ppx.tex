\hypertarget{preprocessing-with-ppx}{%
\section{Preprocessing with ppx}\label{preprocessing-with-ppx}}

One powerful feature in OCaml is a facility to extend the standard
language via \emph{extension points}. These represent placeholders in
the OCaml syntax tree and are ignored by the standard compiler tooling,
beyond being delimited and stored in the abstract syntax tree alongside
the normal parsed source code. They are intended to be expanded by
external tools that select extension nodes that can interpret them. The
external tools can choose to generate further OCaml code by transforming
the input syntax tree, thus forming the basis of an extensible
preprocessor for the language.

There are two primary forms of extension points in OCaml:
\emph{attributes} and \emph{extension nodes}. Let's first run through
some examples of what they look like, and then see how to use them in
your own code.

\hypertarget{extension-attributes}{%
\subsection{Extension Attributes}\label{extension-attributes}}

Attributes supply additional information that is attached to a node in
the OCaml syntax tree, and subsequently interpreted and expanded by
external tools.

The basic form of an attribute is the \passthrough{\lstinline![@ ... ]!}
syntax. The number of \passthrough{\lstinline!@!} symbols defines which
part of the syntax tree the attribute is bound to:

\begin{itemize}
\tightlist
\item
  a single \passthrough{\lstinline![@!} binds to expressions and
  individual type definitions.
\item
  a double \passthrough{\lstinline![@@!} binds to blocks of code, such
  as module definitions, type declarations or class fields.
\item
  a triple \passthrough{\lstinline![@@@!} appears as a standalone entry
  in a module implementation or signature, and are not tied to any
  specific source code node.
\end{itemize}

The OCaml compiler has some useful builtin attributes that we can use to
illustrate their use without requiring any external tools. Let's first
look at the use of the standalone attribute
\passthrough{\lstinline!@@@warning!} to toggle an OCaml compiler
warning.

\begin{lstlisting}[language=Caml]
# module Abc = struct

  [@@@warning "+10"]
  let a = Sys.get_argv (); ()

  [@@@warning "-10"]
  let b = Sys.get_argv (); ()
  end
Line 4, characters 11-26:
Warning 10: this expression should have type unit.
module Abc : sig val a : unit val b : unit end
\end{lstlisting}

The warning number in our example is taken from the
\href{https://caml.inria.fr/pub/docs/manual-ocaml/native.html}{compiler
manual page}. In this case, warning 10 emits a message if the expression
in a sequence doesn't have type \passthrough{\lstinline!unit!}. The
\passthrough{\lstinline!@@@warning!} nodes in the module implementation
cause the compiler to change its behaviour within the scope of that
structure only.

An annotation can also be more narrowly attached to a block of code. For
example, a module implementation can be annotated with
\passthrough{\lstinline!@@deprecated!} to indicate that it should not be
used in new code:

\begin{lstlisting}[language=Caml]
# module Planets = struct
    let earth = true
    let pluto = true
  end [@@deprecated "Sorry, Pluto is no longer a planet. Use the Planets2016 module instead."]
module Planets : sig val earth : bool val pluto : bool end
# module Planets2016 = struct
    let earth = true
    let pluto = false
  end
module Planets2016 : sig val earth : bool val pluto : bool end
\end{lstlisting}

In this example, the \passthrough{\lstinline!@@deprecated!} annotation
is only attached to the \passthrough{\lstinline!Planets!} module, and
the human-readable argument string redirects developers to the newer
code. Now if we try to use the value that has been marked as deprecated,
the compiler will issue a warning.

\begin{lstlisting}[language=Caml]
# let is_pluto_a_planet = Planets.pluto
Line 1, characters 25-38:
Alert deprecated: module Planets
Sorry, Pluto is no longer a planet. Use the Planets2016 module instead.
val is_pluto_a_planet : bool = true
# let is_pluto_a_planet = Planets2016.pluto
val is_pluto_a_planet : bool = false
\end{lstlisting}

Finally, an attribute can also be attached to an individual expression.
In the next example, the
\passthrough{\lstinline!@warn\_on\_literal\_pattern!} attribute
indicates that the argument to the type constructor should not be
pattern matched upon with a constant literal.

\begin{lstlisting}[language=Caml]
# type program_result =
  | Error of string [@warn_on_literal_pattern]
  | Exit_code of int
type program_result = Error of string | Exit_code of int
# let exit_with = function
  | Error "It blew up" -> 1
  | Exit_code code -> code
  | Error _ -> 100
Line 2, characters 11-23:
Warning 52: Code should not depend on the actual values of
this constructor's arguments. They are only for information
and may change in future versions. (See manual section 9.5)
val exit_with : program_result -> int = <fun>
\end{lstlisting}

\hypertarget{commonly-used-extension-attributes}{%
\paragraph{Commonly used extension
attributes}\label{commonly-used-extension-attributes}}

We have already used extension points in
\href{data-serialization.html\#data-serialization-with-s-expressions}{Data
Serialization With S Expressions} to generate boilerplate code for
handling s-expressions.

TODO

\#\#\#~Extension Nodes

While extension points are useful for annotating existing source code,
we also need a mechanism to store generic placeholders within the OCaml
AST for code generation. OCaml provides this facility via the
\emph{extension node} syntax.

The general syntax for an extension node is
\passthrough{\lstinline![\%id expr]!}, where
\passthrough{\lstinline!id!} is an identifier for a particular extension
node rewriter and \passthrough{\lstinline!expr!} is the payload for the
rewriter to parse.

\#\#~Using ppx extensions

\hypertarget{ppx-in-the-compiler}{%
\subsubsection{ppx in the compiler}\label{ppx-in-the-compiler}}

\hypertarget{building-your-first-ppx-extension}{%
\subsection{Building your first ppx
extension}\label{building-your-first-ppx-extension}}

\hypertarget{the-ast-mapper-and-hello-world}{%
\subsubsection{The AST Mapper and hello
world}\label{the-ast-mapper-and-hello-world}}

\begin{itemize}
\tightlist
\item
  replace \passthrough{\lstinline![\%calc 1+2]!} with a constant integer
\end{itemize}

\hypertarget{ppxlib}{%
\subsubsection{ppxlib}\label{ppxlib}}

Why use ppxlib over direct use of AST-mapper
