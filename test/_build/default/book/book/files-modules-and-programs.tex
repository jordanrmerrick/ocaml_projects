\hypertarget{files-modules-and-programs}{%
\section{Files, Modules, and
Programs}\label{files-modules-and-programs}}

We've so far experienced OCaml largely through the toplevel. As you move
from exercises to real-world programs, you'll need to leave the toplevel
behind and start building programs from files. Files are more than just
a convenient way to store and manage your code; in OCaml, they also
correspond to modules, which act as boundaries that divide your program
into conceptual units.

In this chapter, we'll show you how to build an OCaml program from a
collection of files, as well as the basics of working with modules and
module signatures.

\hypertarget{single-file-programs}{%
\subsection{Single-File Programs}\label{single-file-programs}}

We'll start with an example: a utility that reads lines from
\passthrough{\lstinline!stdin!}, computes a frequency count of the
lines, and prints out the ten most frequent lines. We'll start with a
simple implementation, which we'll save as the file \emph{freq.ml}.
\protect\hypertarget{FILEsnglprog}{}{files/single-file
programs}\protect\hypertarget{Psingfil}{}{programs/single-file programs}

This implementation will use two functions from the
\passthrough{\lstinline!List.Assoc!} module, which provides utility
functions for interacting with \emph{association lists}, \emph{i.e.},
lists of key/value pairs. In particular, we use the function
\passthrough{\lstinline!List.Assoc.find!}, which looks up a key in an
association list; and \passthrough{\lstinline!List.Assoc.add!}, which
adds a new binding to an association list, as shown here:
\index{List.Assoc module/List.Assoc.add}\index{List.Assoc
module/List.Assoc.find}\index{lists/adding new bindings
in}\index{lists/finding key associations in}

\begin{lstlisting}[language=Caml]
# open Base
# let assoc = [("one", 1); ("two",2); ("three",3)]
val assoc : (string * int) list = [("one", 1); ("two", 2); ("three", 3)]
# List.Assoc.find ~equal:String.equal assoc "two"
- : int option = Some 2
# List.Assoc.add ~equal:String.equal assoc "four" 4 (* add a new key *)
- : (string, int) Base.List.Assoc.t =
[("four", 4); ("one", 1); ("two", 2); ("three", 3)]
# List.Assoc.add ~equal:String.equal assoc "two"  4 (* overwrite an existing key *)
- : (string, int) Base.List.Assoc.t = [("two", 4); ("one", 1); ("three", 3)]
\end{lstlisting}

Note that \passthrough{\lstinline!List.Assoc.add!} doesn't modify the
original list, but instead allocates a new list with the requisite
key/value pair added.

Now we can write \passthrough{\lstinline!freq.ml!}.

\begin{lstlisting}[language=Caml]
open Base
open Stdio

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:[] ~f:(fun counts line ->
    let count =
      match List.Assoc.find ~equal:String.equal counts line with
      | None -> 0
      | Some x -> x
    in
    List.Assoc.add ~equal:String.equal counts line (count + 1)
  )

let () =
  build_counts ()
  |> List.sort ~compare:(fun (_,x) (_,y) -> Int.descending x y)
  |> (fun l -> List.take l 10)
  |> List.iter ~f:(fun (line,count) -> printf "%3d: %s\n" count line)
\end{lstlisting}

The function \passthrough{\lstinline!build\_counts!} reads in lines from
\passthrough{\lstinline!stdin!}, constructing from those lines an
association list with the frequencies of each line. It does this by
invoking \passthrough{\lstinline!In\_channel.fold\_lines!} (similar to
the function \passthrough{\lstinline!List.fold!} described in
\href{lists-and-patterns.html\#lists-and-patterns}{Lists And Patterns}),
which reads through the lines one by one, calling the provided
\passthrough{\lstinline!fold!} function for each line to update the
accumulator. That accumulator is initialized to the empty list.

With \passthrough{\lstinline!build\_counts!} defined, we then call the
function to build the association list, sort that list by frequency in
descending order, grab the first 10 elements off the list, and then
iterate over those 10 elements and print them to the screen. These
operations are tied together using the \passthrough{\lstinline!|>!}
operator described in
\href{variables-and-functions.html\#prefix-and-infix-operators}{Variables
And Functions}. \index{let ( ) declaration}\index{main function}

\hypertarget{where-is-main}{%
\subsubsection{\texorpdfstring{Where Is
\texttt{main}?}{Where Is main?}}\label{where-is-main}}

Unlike programs in C, Java or C\#, programs in OCaml don't have a unique
\passthrough{\lstinline!main!} function. When an OCaml program is
evaluated, all the statements in the implementation files are evaluated
in the order in which they were linked together. These implementation
files can contain arbitrary expressions, not just function definitions.
In this example, the declaration starting with
\passthrough{\lstinline!let () =!} plays the role of the
\passthrough{\lstinline!main!} function, kicking off the processing. But
really the entire file is evaluated at startup, and so in some sense the
full codebase is one big \passthrough{\lstinline!main!} function.

The idiom of writing \passthrough{\lstinline!let () =!} may seem a bit
odd, but it has a purpose. The \passthrough{\lstinline!let!} binding
here is a pattern-match to a value of type
\passthrough{\lstinline!unit!}, which is there to ensure that the
expression on the righthand side returns \passthrough{\lstinline!unit!},
as is common for functions that operate primarily by side effect.

If we weren't using \passthrough{\lstinline!Base!} or any other external
libraries, we could build the executable like this:

\begin{lstlisting}[language=bash]
$ ocamlc freq.ml -o freq.byte
File "freq.ml", line 1, characters 5-9:
1 | open Base
         ^^^^
Error: Unbound module Base
[2]
\end{lstlisting}

But as you can see, it fails because it can't find
\passthrough{\lstinline!Base!} and \passthrough{\lstinline!Stdio!}. We
need a somewhat more complex invocation to get them linked in:
\index{OCaml
toolchain/ocamlc}\index{OCaml toolchain/ocamlfind}\index{Base standard
library/finding with ocamlfind}

\begin{lstlisting}[language=bash]
$ ocamlfind ocamlc -linkpkg -package base -package stdio freq.ml -o freq.byte
\end{lstlisting}

This uses \passthrough{\lstinline!ocamlfind!}, a tool which itself
invokes other parts of the OCaml toolchain (in this case,
\passthrough{\lstinline!ocamlc!}) with the appropriate flags to link in
particular libraries and packages. Here,
\passthrough{\lstinline!-package base!} is asking
\passthrough{\lstinline!ocamlfind!} to link in the
\passthrough{\lstinline!Base!} library;
\passthrough{\lstinline!-linkpkg!} asks ocamlfind to link in the
packages as is necessary for building an executable. {-linkpkg}

While this works well enough for a one-file project, more complicated
projects require a tool to orchestrate the build. One good tool for this
task is \passthrough{\lstinline!dune!}. To invoke
\passthrough{\lstinline!dune!}, you need to have a
\passthrough{\lstinline!dune!} file that specifies the details of the
build. \index{dune}

\begin{lstlisting}
(executable
  (name      freq)
  (libraries base stdio))
\end{lstlisting}

With that in place, we can invoke \passthrough{\lstinline!dune!} as
follows.

\begin{lstlisting}[language=bash]
$ dune build freq.bc
\end{lstlisting}

We can run the resulting executable, \passthrough{\lstinline!freq.bc!},
from the command line. Executables built with
\passthrough{\lstinline!dune!} will be left in the
\passthrough{\lstinline!\_build/default!} directory, from which they can
be invoked. The specific invocation below will count the words that come
up in the file \passthrough{\lstinline!freq.ml!} itself.
\index{OCaml toolchain/dune}

\begin{lstlisting}[language=bash]
$ grep -Eo '[[:alpha:]]+' freq.ml | ./_build/default/freq.bc
  5: line
  5: List
  5: counts
  4: count
  4: fun
  4: x
  4: equal
  3: let
  2: f
  2: l
\end{lstlisting}

Conveniently, \passthrough{\lstinline!dune!} allows us to combine the
building and running an executable into a single operation, which we can
do using \passthrough{\lstinline!dune exec!}.

\begin{lstlisting}[language=bash]
$ grep -Eo '[[:alpha:]]+' freq.ml | dune exec ./freq.bc
  5: line
  5: List
  5: counts
  4: count
  4: fun
  4: x
  4: equal
  3: let
  2: f
  2: l
\end{lstlisting}

\hypertarget{bytecode-versus-native-code}{%
\subsubsection{Bytecode Versus Native
Code}\label{bytecode-versus-native-code}}

OCaml ships with two compilers: the \passthrough{\lstinline!ocamlc!}
bytecode compiler and the \passthrough{\lstinline!ocamlopt!} native-code
compiler. Programs compiled with \passthrough{\lstinline!ocamlc!} are
interpreted by a virtual machine, while programs compiled with
\passthrough{\lstinline!ocamlopt!} are compiled to native machine code
to be run on a specific operating system and processor architecture.
With \passthrough{\lstinline!dune!}, targets ending with
\passthrough{\lstinline!.bc!} are built as bytecode executables, and
those ending with \passthrough{\lstinline!.exe!} are built as native
code.

Aside from performance, executables generated by the two compilers have
nearly identical behavior. There are a few things to be aware of. First,
the bytecode compiler can be used on more architectures, and has some
tools that are not available for native code. For example, the OCaml
debugger only works with bytecode (although
\passthrough{\lstinline!gdb!}, the GNU Debugger, works with OCaml
native-code applications). The bytecode compiler is also quicker than
the native-code compiler. In addition, in order to run a bytecode
executable, you typically need to have OCaml installed on the system in
question. That's not strictly required, though, since you can build a
bytecode executable with an embedded runtime, using the
\passthrough{\lstinline!-custom!} compiler flag.

As a general matter, production executables should usually be built
using the native-code compiler, but it sometimes makes sense to use
bytecode for development builds. And, of course, bytecode makes sense
when targeting a platform not supported by the native-code compiler.
We'll cover both compilers in more detail in
\href{compiler-backend.html\#the-compiler-backend-byte-code-and-native-code}{The
Compiler Backend: Byte Code And Native Code}.

\hypertarget{multi-file-programs-and-modules}{%
\subsection{Multifile Programs and
Modules}\label{multi-file-programs-and-modules}}

Source files in OCaml are tied into the module system, with each file
compiling down into a module whose name is derived from the name of the
file. We've encountered modules before, such as when we used functions
like \passthrough{\lstinline!find!} and \passthrough{\lstinline!add!}
from the \passthrough{\lstinline!List.Assoc!} module. At its simplest,
you can think of a module as a collection of definitions that are stored
within a namespace. \index{modules/basics of}\index{files/multi-file
programs}\index{programs/multi-file programs}

Let's consider how we can use modules to refactor the implementation of
\passthrough{\lstinline!freq.ml!}. Remember that the variable
\passthrough{\lstinline!counts!} contains an association list
representing the counts of the lines seen so far. But updating an
association list takes time linear in the length of the list, meaning
that the time complexity of processing a file is quadratic in the number
of distinct lines in the file.

We can fix this problem by replacing association lists with a more
efficient data structure. To do that, we'll first factor out the key
functionality into a separate module with an explicit interface. We can
consider alternative (and more efficient) implementations once we have a
clear interface to program against.

We'll start by creating a file, \passthrough{\lstinline!counter.ml!},
that contains the logic for maintaining the association list used to
represent the frequency counts. The key function, called
\passthrough{\lstinline!touch!}, bumps the frequency count of a given
line by one.

\begin{lstlisting}[language=Caml]
open Base

let touch counts line =
  let count =
    match List.Assoc.find ~equal:String.equal counts line with
    | None -> 0
    | Some x -> x
  in
  List.Assoc.add ~equal:String.equal counts line (count + 1)
\end{lstlisting}

The file \emph{counter.ml} will be compiled into a module named
\passthrough{\lstinline!Counter!}, where the name of the module is
derived automatically from the filename. The module name is capitalized
even if the file is not. Indeed, module names are always capitalized.
\index{modules/naming of}

We can now rewrite \passthrough{\lstinline!freq.ml!} to use
\passthrough{\lstinline!Counter!}.

\begin{lstlisting}[language=Caml]
open Base
open Stdio

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:[] ~f:Counter.touch

let () =
  build_counts ()
  |> List.sort ~compare:(fun (_,x) (_,y) -> Int.descending x y)
  |> (fun l -> List.take l 10)
  |> List.iter ~f:(fun (line,count) -> printf "%3d: %s\n" count line)
\end{lstlisting}

The resulting code can still be built with
\passthrough{\lstinline!dune!}, which will discover dependencies and
realize that \passthrough{\lstinline!counter.ml!} needs to be compiled.

\begin{lstlisting}[language=bash]
$ dune build freq.bc
\end{lstlisting}

\hypertarget{signatures-and-abstract-types}{%
\subsection{Signatures and Abstract
Types}\label{signatures-and-abstract-types}}

While we've pushed some of the logic to the
\passthrough{\lstinline!Counter!} module, the code in
\passthrough{\lstinline!freq.ml!} can still depend on the details of the
implementation of \passthrough{\lstinline!Counter!}. Indeed, if you look
at the definition of \passthrough{\lstinline!build\_counts!}, you'll see
that it depends on the fact that the empty set of frequency counts is
represented as an empty list. We'd like to prevent this kind of
dependency, so we can change the implementation of
\passthrough{\lstinline!Counter!} without needing to change client code
like that in \passthrough{\lstinline!freq.ml!}.
\index{abstract types}\index{modules/module
type}\index{signatures/abstract types}\index{interfaces/hiding implementation
details with}\index{modules/hiding implementation details}

The implementation details of a module can be hidden by attaching an
\emph{interface}. (Note that in the context of OCaml, the terms
\emph{interface}, \emph{signature}, and \emph{module type} are all used
interchangeably.) A module defined by a file
\passthrough{\lstinline!filename.ml!} can be constrained by a signature
placed in a file called \passthrough{\lstinline!filename.mli!}.
\index{interfaces/synonyms for}

For \passthrough{\lstinline!counter.mli!}, we'll start by writing down
an interface that describes what's currently available in
\passthrough{\lstinline!counter.ml!}, without hiding anything.
\passthrough{\lstinline!val!} declarations are used to specify values in
a signature. The syntax of a \passthrough{\lstinline!val!} declaration
is as follows:

\begin{lstlisting}
val <identifier> : <type>
\end{lstlisting}

Using this syntax, we can write the signature of
\passthrough{\lstinline!counter.ml!} as follows.

\begin{lstlisting}[language=Caml]
open Base

(** Bump the frequency count for the given string. *)
val touch : (string * int) list -> string -> (string * int) list
\end{lstlisting}

Note that \passthrough{\lstinline!dune!} will detect the presence of the
\passthrough{\lstinline!mli!} file automatically and include it in the
build.

To hide the fact that frequency counts are represented as association
lists, we'll need to make the type of frequency counts \emph{abstract}.
A type is abstract if its name is exposed in the interface, but its
definition is not. Here's an abstract interface for
\passthrough{\lstinline!Counter!}:

\begin{lstlisting}[language=Caml]
open Base

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -> string -> t

(** Converts the set of frequency counts to an association list.  A string shows
    up at most once, and the counts are >= 1. *)
val to_list : t -> (string * int) list
\end{lstlisting}

Note that we needed to add \passthrough{\lstinline!empty!} and
\passthrough{\lstinline!to\_list!} to \passthrough{\lstinline!Counter!},
since otherwise there would be no way to create a
\passthrough{\lstinline!Counter.t!} or get data out of one.

We also used this opportunity to document the module. The
\passthrough{\lstinline!mli!} file is the place where you specify your
module's interface, and as such is a natural place to put documentation.
We started our comments with a double asterisk to cause them to be
picked up by the \passthrough{\lstinline!odoc!} tool when generating API
documentation. We'll discuss \passthrough{\lstinline!odoc!} more in
\href{compiler-frontend.html\#the-compiler-frontend-parsing-and-type-checking}{The
Compiler Frontend Parsing And Type Checking}.

Here's a rewrite of \passthrough{\lstinline!counter.ml!} to match the
new \passthrough{\lstinline!counter.mli!}:

\begin{lstlisting}[language=Caml]
open Base

type t = (string * int) list

let empty = []

let to_list x = x

let touch counts line =
  let count =
    match List.Assoc.find ~equal:String.equal counts line with
    | None -> 0
    | Some x -> x
  in
  List.Assoc.add ~equal:String.equal counts line (count + 1)
\end{lstlisting}

If we now try to compile \passthrough{\lstinline!freq.ml!}, we'll get
the following error:

\begin{lstlisting}[language=bash]
$ dune build freq.bc
File "freq.ml", line 5, characters 53-66:
5 |   In_channel.fold_lines In_channel.stdin ~init:[] ~f:Counter.touch
                                                         ^^^^^^^^^^^^^
Error: This expression has type Counter.t -> Base.string -> Counter.t
       but an expression was expected of type
         'a list -> Base.string -> 'a list
       Type Counter.t is not compatible with type 'a list
[1]
\end{lstlisting}

This is because \passthrough{\lstinline!freq.ml!} depends on the fact
that frequency counts are represented as association lists, a fact that
we've just hidden. We just need to fix
\passthrough{\lstinline!build\_counts!} to use
\passthrough{\lstinline!Counter.empty!} instead of
\passthrough{\lstinline![]!} and to use
\passthrough{\lstinline!Counter.to\_list!} to convert the completed
counts to an association list. The resulting implementation is shown
below.

\begin{lstlisting}[language=Caml]
open Base
open Stdio

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:Counter.empty ~f:Counter.touch

let () =
  build_counts ()
  |> Counter.to_list
  |> List.sort ~compare:(fun (_,x) (_,y) -> Int.descending x y)
  |> (fun counts -> List.take counts 10)
  |> List.iter ~f:(fun (line,count) -> printf "%3d: %s\n" count line)
\end{lstlisting}

With this implementation, the build now succeeds!

\begin{lstlisting}[language=bash]
$ dune build freq.bc
\end{lstlisting}

Now we can turn to optimizing the implementation of
\passthrough{\lstinline!Counter!}. Here's an alternate and far more
efficient implementation, based on the \passthrough{\lstinline!Map!}
data structure in \passthrough{\lstinline!Core\_kernel!}.

\begin{lstlisting}[language=Caml]
open Base

type t = (string,int,String.comparator_witness) Map.t

let empty = Map.empty (module String)

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -> 0
    | Some x -> x
  in
  Map.set t ~key:s ~data:(count + 1)
\end{lstlisting}

There's some unfamiliar syntax in the above example, in particular the
use of \passthrough{\lstinline!Map.empty (module String)!} to generate
an empty map. Here, we're making use of a more advanced feature of the
language (specifically, \emph{first-class modules}, which we'll get to
in later chapters). The use of these features for the Map data-structure
in particular is covered in
\href{maps-and-hashtables.html\#maps-and-hash-tables}{Maps And Hash
Tables}.

\hypertarget{concrete-types-in-signatures}{%
\subsection{Concrete Types in
Signatures}\label{concrete-types-in-signatures}}

In our frequency-count example, the module
\passthrough{\lstinline!Counter!} had an abstract type
\passthrough{\lstinline!Counter.t!} for representing a collection of
frequency counts. Sometimes, you'll want to make a type in your
interface \emph{concrete}, by including the type definition in the
interface. \index{concrete types}\index{signatures/concrete
types}

For example, imagine we wanted to add a function to
\passthrough{\lstinline!Counter!} for returning the line with the median
frequency count. If the number of lines is even, then there is no
precise median, and the function would return the lines before and after
the median instead. We'll use a custom type to represent the fact that
there are two possible return values. Here's a possible implementation:

\begin{lstlisting}[language=Caml]
type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings =
    List.sort (Map.to_alist t)
      ~compare:(fun (_,x) (_,y) -> Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith "median: empty frequency count";
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len % 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2 - 1), nth (len/2))
\end{lstlisting}

In the above, we use \passthrough{\lstinline!failwith!} to throw an
exception for the case of the empty list. We'll discuss exceptions more
in \href{error-handling.html\#error-handling}{Error Handling}. Note also
that the function \passthrough{\lstinline!fst!} simply returns the first
element of any two-tuple.

Now, to expose this usefully in the interface, we need to expose both
the function and the type \passthrough{\lstinline!median!} with its
definition. Note that values (of which functions are an example) and
types have distinct namespaces, so there's no name clash here. Adding
the following two lines to \passthrough{\lstinline!counter.mli!} does
the trick.

\begin{lstlisting}[language=Caml]
(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Median of string
              | Before_and_after of string * string

val median : t -> median
\end{lstlisting}

The decision of whether a given type should be abstract or concrete is
an important one. Abstract types give you more control over how values
are created and accessed, and make it easier to enforce invariants
beyond what is enforced by the type itself; concrete types let you
expose more detail and structure to client code in a lightweight way.
The right choice depends very much on the context.

\hypertarget{nested-modules}{%
\subsection{Nested Modules}\label{nested-modules}}

Up until now, we've only considered modules that correspond to files,
like \passthrough{\lstinline!counter.ml!}. But modules (and module
signatures) can be nested inside other modules. As a simple example,
consider a program that needs to deal with multiple identifiers like
usernames and hostnames. If you just represent these as strings, then it
becomes easy to confuse one with the other.
\index{identifiers/dealing with multiple}\index{nested
modules}\index{modules/nested modules}

A better approach is to mint new abstract types for each identifier,
where those types are under the covers just implemented as strings. That
way, the type system will prevent you from confusing a username with a
hostname, and if you do need to convert, you can do so using explicit
conversions to and from the string type.

Here's how you might create such an abstract type, within a submodule:
\index{abstract types}

\begin{lstlisting}[language=Caml]
open Base

module Username : sig
  type t
  val of_string : string -> t
  val to_string : t -> string
  val (=) : t -> t -> bool
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
  let (=) = String.(=)
end
\end{lstlisting}

Note that the \passthrough{\lstinline!to\_string!} and
\passthrough{\lstinline!of\_string!} functions above are implemented
simply as the identity function, which means they have no runtime
effect. They are there purely as part of the discipline that they
enforce on the code through the type system. We also chose to put in an
equality function, so you can check if two usernames match. In a real
application, we might want more functionality, like the ability to hash
and compare usernames, but we've kept this example purposefully simple.

The basic structure of a module declaration like this is:

\begin{lstlisting}
module <name> : <signature> = <implementation>
\end{lstlisting}

We could have written this slightly differently, by giving the signature
its own top-level \passthrough{\lstinline!module type!} declaration,
making it possible to create multiple distinct types with the same
underlying implementation in a lightweight way:

\begin{lstlisting}[language=Caml]
open Base
module Time = Core_kernel.Time

module type ID = sig
  type t
  val of_string : string -> t
  val to_string : t -> string
  val (=) : t -> t -> bool
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
  let (=) = String.(=)
end

module Username : ID = String_id
module Hostname : ID = String_id

type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  Username.(=) s1.user s2.host
\end{lstlisting}

The preceding code has a bug: it compares the username in one session to
the host in the other session, when it should be comparing the usernames
in both cases. Because of how we defined our types, however, the
compiler will flag this bug for us.

\begin{lstlisting}[language=bash]
$ dune build session_info.exe
File "session_info.ml", line 27, characters 23-30:
27 |   Username.(=) s1.user s2.host
                            ^^^^^^^
Error: This expression has type Hostname.t
       but an expression was expected of type Username.t
[1]
\end{lstlisting}

This is a trivial example, but confusing different kinds of identifiers
is a very real source of bugs, and the approach of minting abstract
types for different classes of identifiers is an effective way of
avoiding such issues.

\hypertarget{opening-modules}{%
\subsection{Opening Modules}\label{opening-modules}}

Most of the time, you refer to values and types within a module by using
the module name as an explicit qualifier. For example, you write
\passthrough{\lstinline!List.map!} to refer to the
\passthrough{\lstinline!map!} function in the
\passthrough{\lstinline!List!} module. Sometimes, though, you want to be
able to refer to the contents of a module without this explicit
qualification. That's what the \passthrough{\lstinline!open!} statement
is for. \index{identifiers/open
modules and}\index{modules/opening}

We've encountered \passthrough{\lstinline!open!} already, specifically
where we've written \passthrough{\lstinline!open Base!} to get access to
the standard definitions in the \passthrough{\lstinline!Base!} library.
In general, opening a module adds the contents of that module to the
environment that the compiler looks at to find the definition of various
identifiers. Here's an example:

\begin{lstlisting}[language=Caml]
# open Base
# module M = struct let foo = 3 end
module M : sig val foo : int end
# foo
Line 1, characters 1-4:
Error: Unbound value foo
# open M
# foo
- : int = 3
\end{lstlisting}

\passthrough{\lstinline!open!} is essential when you want to modify your
environment for a standard library like \passthrough{\lstinline!Base!},
but it's generally good style to keep the opening of modules to a
minimum. Opening a module is basically a trade-off between terseness and
explicitness---the more modules you open, the fewer module
qualifications you need, and the harder it is to look at an identifier
and figure out where it comes from.

Here's some general advice on how to deal with
\passthrough{\lstinline!open!}s: \index{local opens}

\begin{itemize}
\item
  Opening modules at the toplevel of a module should be done quite
  sparingly, and generally only with modules that have been specifically
  designed to be opened, like \passthrough{\lstinline!Base!} or
  \passthrough{\lstinline!Option.Monad\_infix!}.
\item
  If you do need to do an open, it's better to do a \emph{local open}.
  There are two syntaxes for local opens. For example, you can write:
\end{itemize}

\begin{lstlisting}[language=Caml]
# let average x y =
    let open Int64 in
    (x + y) / of_int 2
val average : int64 -> int64 -> int64 = <fun>
\end{lstlisting}

Here, \passthrough{\lstinline!of\_int!} and the infix operators are the
ones from the \passthrough{\lstinline!Int64!} module.

There's another, even more lightweight syntax for local
\passthrough{\lstinline!open!}s, which is particularly useful for small
expressions:

\begin{lstlisting}[language=Caml]
# let average x y =
    Int64.((x + y) / of_int 2)
val average : int64 -> int64 -> int64 = <fun>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  An alternative to local \passthrough{\lstinline!open!}s that makes
  your code terser without giving up on explicitness is to locally
  rebind the name of a module. So, when using the
  \passthrough{\lstinline!Counter.median!} type, instead of writing:
\end{itemize}

\begin{lstlisting}[language=Caml]
let print_median m =
  match m with
  | Counter.Median string -> printf "True median:\n   %s\n" string
  | Counter.Before_and_after (before, after) ->
    printf "Before and after median:\n   %s\n   %s\n" before after
\end{lstlisting}

you could write:

\begin{lstlisting}[language=Caml]
let print_median m =
  let module C = Counter in
  match m with
  | C.Median string -> printf "True median:\n   %s\n" string
  | C.Before_and_after (before, after) ->
    printf "Before and after median:\n   %s\n   %s\n" before after
\end{lstlisting}

Because the module name \passthrough{\lstinline!C!} only exists for a
short scope, it's easy to read and remember what
\passthrough{\lstinline!C!} stands for. Rebinding modules to very short
names at the top level of your module is usually a mistake.

\hypertarget{including-modules}{%
\subsection{Including Modules}\label{including-modules}}

While opening a module affects the environment used to search for
identifiers, \emph{including} a module is a way of adding new
identifiers to a module proper. Consider the following simple module for
representing a range of integer values:
\index{modules/including}\index{identifiers/adding to
modules}

\begin{lstlisting}[language=Caml]
# module Interval = struct
    type t = | Interval of int * int
             | Empty

    let create low high =
      if high < low then Empty else Interval (low,high)
  end
module Interval :
  sig type t = Interval of int * int | Empty val create : int -> int -> t end
\end{lstlisting}

We can use the \passthrough{\lstinline!include!} directive to create a
new, extended version of the \passthrough{\lstinline!Interval!} module:

\begin{lstlisting}[language=Caml]
# module Extended_interval = struct
    include Interval

    let contains t x =
      match t with
      | Empty -> false
      | Interval (low,high) -> x >= low && x <= high
  end
module Extended_interval :
  sig
    type t = Interval.t = Interval of int * int | Empty
    val create : int -> int -> t
    val contains : t -> int -> bool
  end
# Extended_interval.contains (Extended_interval.create 3 10) 4
- : bool = true
\end{lstlisting}

The difference between \passthrough{\lstinline!include!} and
\passthrough{\lstinline!open!} is that we've done more than change how
identifiers are searched for: we've changed what's in the module. If
we'd used \passthrough{\lstinline!open!}, we'd have gotten a quite
different result:

\begin{lstlisting}[language=Caml]
# module Extended_interval = struct
    open Interval

    let contains t x =
      match t with
      | Empty -> false
      | Interval (low,high) -> x >= low && x <= high
  end
module Extended_interval :
  sig val contains : Extended_interval.t -> int -> bool end
# Extended_interval.contains (Extended_interval.create 3 10) 4
Line 1, characters 29-53:
Error: Unbound value Extended_interval.create
\end{lstlisting}

To consider a more realistic example, imagine you wanted to build an
extended version of the \passthrough{\lstinline!List!} module, where
you've added some functionality not present in the module as distributed
in \passthrough{\lstinline!Base!}. That's a job for
\passthrough{\lstinline!include!}.

\begin{lstlisting}[language=Caml]
open Base

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -> list
  | x :: y :: tl -> x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List
\end{lstlisting}

Now, how do we write an interface for this new module? It turns out that
\passthrough{\lstinline!include!} works on signatures as well, so we can
pull essentially the same trick to write our
\passthrough{\lstinline!mli!}. The only issue is that we need to get our
hands on the signature for the \passthrough{\lstinline!List!} module.
This can be done using \passthrough{\lstinline!module type of!}, which
computes a signature from a module:

\begin{lstlisting}[language=Caml]
open Base

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -> 'a -> 'a list
\end{lstlisting}

Note that the order of declarations in the \passthrough{\lstinline!mli!}
does not need to match the order of declarations in the
\passthrough{\lstinline!ml!}. The order of declarations in the
\passthrough{\lstinline!ml!} mostly matters insofar as it affects which
values are shadowed. If we wanted to replace a function in
\passthrough{\lstinline!List!} with a new function of the same name, the
declaration of that function in the \passthrough{\lstinline!ml!} would
have to come after the \passthrough{\lstinline!include List!}
declaration.

We can now use \passthrough{\lstinline!Ext\_list!} as a replacement for
\passthrough{\lstinline!List!}. If we want to use
\passthrough{\lstinline!Ext\_list!} in preference to
\passthrough{\lstinline!List!} in our project, we can create a file of
common definitions:

\begin{lstlisting}[language=Caml]
module List = Ext_list
\end{lstlisting}

And if we then put \passthrough{\lstinline!open Common!} after
\passthrough{\lstinline!open Base!} at the top of each file in our
project, then references to \passthrough{\lstinline!List!} will
automatically go to \passthrough{\lstinline!Ext\_list!} instead.

\hypertarget{common-errors-with-modules}{%
\subsection{Common Errors with
Modules}\label{common-errors-with-modules}}

When OCaml compiles a program with an \passthrough{\lstinline!ml!} and
an \passthrough{\lstinline!mli!}, it will complain if it detects a
mismatch between the two. Here are some of the common errors you'll run
into.

\hypertarget{type-mismatches}{%
\subsubsection{Type Mismatches}\label{type-mismatches}}

The simplest kind of error is where the type specified in the signature
does not match the type in the implementation of the module. As an
example, if we replace the \passthrough{\lstinline!val!} declaration in
\passthrough{\lstinline!counter.mli!} by swapping the types of the first
two arguments: \index{errors/module type mismatches}\index{type
mismatches}\index{modules/type mismatches in}

\begin{lstlisting}[language=Caml]
(** Bump the frequency count for the given string. *)
val touch : string -> t -> t
\end{lstlisting}

and we try to compile, we'll get the following error.

\begin{lstlisting}[language=bash]
$ dune build freq.bc
File "counter.ml", line 1:
Error: The implementation counter.ml
       does not match the interface .freq.eobjs/byte/counter.cmi:
       Values do not match:
         val touch :
           ('a, int, 'b) Base.Map.t -> 'a -> ('a, int, 'b) Base.Map.t
       is not included in
         val touch : string -> t -> t
       File "counter.mli", line 16, characters 0-28: Expected declaration
       File "counter.ml", line 9, characters 4-9: Actual declaration
[1]
\end{lstlisting}

\hypertarget{missing-definitions}{%
\subsubsection{Missing Definitions}\label{missing-definitions}}

We might decide that we want a new function in
\passthrough{\lstinline!Counter!} for pulling out the frequency count of
a given string. We can update the \passthrough{\lstinline!mli!} by
adding the following line:
\index{errors/missing module definitions}\index{modules/missing
definitions in}

\begin{lstlisting}[language=Caml]
val count : t -> string -> int
\end{lstlisting}

Now if we try to compile without actually adding the implementation,
we'll get this error.

\begin{lstlisting}[language=bash]
$ dune build counter.bc
Error: Don't know how to build counter.bc
Hint: did you mean counter.ml?
[1]
\end{lstlisting}

A missing type definition will lead to a similar error.

\hypertarget{type-definition-mismatches}{%
\subsubsection{Type Definition
Mismatches}\label{type-definition-mismatches}}

Type definitions that show up in an \passthrough{\lstinline!mli!} need
to match up with corresponding definitions in the
\passthrough{\lstinline!ml!}. Consider again the example of the type
\passthrough{\lstinline!median!}. The order of the declaration of
variants matters to the OCaml compiler, so the definition of
\passthrough{\lstinline!median!} in the implementation listing those
options in a different order:
\index{type definition mismatches}\index{errors/module type
definition mismatches}\index{modules/type definition mismatches}

\begin{lstlisting}[language=Caml]
(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Before_and_after of string * string
              | Median of string

val median : t -> median
\end{lstlisting}

will lead to a compilation error.

\begin{lstlisting}[language=bash]
$ dune build freq.bc
File "counter.ml", line 1:
Error: The implementation counter.ml
       does not match the interface .freq.eobjs/byte/counter.cmi:
       Type declarations do not match:
         type median = Median of string | Before_and_after of string * string
       is not included in
         type median = Before_and_after of string * string | Median of string
       File "counter.mli", lines 21-22, characters 0-32: Expected declaration
       File "counter.ml", lines 18-19, characters 0-51: Actual declaration
       Fields number 1 have different names, Median and Before_and_after.
[1]
\end{lstlisting}

Order is similarly important to other type declarations, including the
order in which record fields are declared and the order of arguments
(including labeled and optional arguments) to a function.

\hypertarget{cyclic-dependencies}{%
\subsubsection{Cyclic Dependencies}\label{cyclic-dependencies}}

In most cases, OCaml doesn't allow cyclic dependencies, i.e., a
collection of definitions that all refer to one another. If you want to
create such definitions, you typically have to mark them specially. For
example, when defining a set of mutually recursive values (like the
definition of \passthrough{\lstinline!is\_even!} and
\passthrough{\lstinline!is\_odd!} in
\href{variables-and-functions.html\#recursive-functions}{Recursive
Functions}), you need to define them using
\passthrough{\lstinline!let rec!} rather than ordinary
\passthrough{\lstinline!let!}.
\index{dependencies, cyclic}\index{cyclic dependencies}\index{errors/cyclic
dependencies}\index{modules/cyclic dependencies}

The same is true at the module level. By default, cyclic dependencies
between modules are not allowed, and cyclic dependencies among files are
never allowed. Recursive modules are possible but are a rare case, and
we won't discuss them further here.

The simplest example of a forbidden circular reference is a module
referring to its own module name. So, if we tried to add a reference to
\passthrough{\lstinline!Counter!} from within
\passthrough{\lstinline!counter.ml!}.

\begin{lstlisting}[language=Caml]
let singleton l = Counter.touch Counter.empty
\end{lstlisting}

we'll see this error when we try to build:

\begin{lstlisting}[language=bash]
$ dune build freq.bc
File "counter.ml", line 18, characters 18-31:
18 | let singleton l = Counter.touch Counter.empty
                       ^^^^^^^^^^^^^
Error: Unbound module Counter
[1]
\end{lstlisting}

The problem manifests in a different way if we create cyclic references
between files. We could create such a situation by adding a reference to
\passthrough{\lstinline!Freq!} from
\passthrough{\lstinline!counter.ml!}, e.g., by adding the following
line.

\begin{lstlisting}[language=Caml]
let _build_counts = Freq.build_counts
\end{lstlisting}

In this case, \passthrough{\lstinline!dune!} will notice the error and
complain explicitly about the cycle:

\begin{lstlisting}[language=bash]
$ dune build freq.bc
Error: Dependency cycle between the following files:
   _build/default/.freq.eobjs/freq.impl.all-deps
-> _build/default/.freq.eobjs/counter.impl.all-deps
-> _build/default/.freq.eobjs/freq.impl.all-deps
[1]
\end{lstlisting}

\hypertarget{designing-with-modules}{%
\subsection{Designing with Modules}\label{designing-with-modules}}

The module system is a key part of how an OCaml program is structured.
As such, we'll close this chapter with some advice on how to think about
designing that structure effectively.

\hypertarget{expose-concrete-types-rarely}{%
\subsubsection{Expose Concrete Types
Rarely}\label{expose-concrete-types-rarely}}

When designing an \passthrough{\lstinline!mli!}, one choice that you
need to make is whether to expose the concrete definition of your types
or leave them abstract. Most of the time, abstraction is the right
choice, for two reasons: it enhances the flexibility of your design, and
it makes it possible to enforce invariants on the use of your module.

Abstraction enhances flexibility by restricting how users can interact
with your types, thus reducing the ways in which users can depend on the
details of your implementation. If you expose types explicitly, then
users can depend on any and every detail of the types you choose. If
they're abstract, then only the specific operations you want to expose
are available. This means that you can freely change the implementation
without affecting clients, as long as you preserve the semantics of
those operations.

In a similar way, abstraction allows you to enforce invariants on your
types. If your types are exposed, then users of the module can create
new instances of that type (or if mutable, modify existing instances) in
any way allowed by the underlying type. That may violate a desired
invariant \emph{i.e.}, a property about your type that is always
supposed to be true. Abstract types allow you to protect invariants by
making sure that you only expose functions that preserves your
invariants.

Despite these benefits, there is a trade-off here. In particular,
exposing types concretely makes it possible to use pattern-matching with
those types, which as we saw in {Lists And Patterns} is a powerful and
important tool. You should generally only expose the concrete
implementation of your types when there's significant value in the
ability to pattern match, and when the invariants that you care about
are already enforced by the data type itself.

\hypertarget{design-for-the-call-site}{%
\subsubsection{Design for the Call
Site}\label{design-for-the-call-site}}

When writing an interface, you should think not just about how easy it
is to understand the interface for someone who reads your carefully
documented \passthrough{\lstinline!mli!} file, but more importantly, you
want the call to be as obvious as possible for someone who is reading it
at the call site.

The reason for this is that most of the time, people interacting with
your API will be doing so by reading and modifying code that uses the
API, not by reading the interface definition. By making your API as
obvious as possible from that perspective, you simplify the lives of
your users.

There are many ways of improving readability at the call site. One
example is labeled arguments (discussed in
\href{variables-and-functions.html\#labeled-arguments}{Labeled
Arguments}), which act as documentation that is available at the call
site.

You can also improve readability simply by choosing good names for your
functions, variant tags and record fields. Good names aren't always
long, to be clear. If you wanted to write an anonymous function for
doubling a number: \passthrough{\lstinline!(fun x -> x * 2)!}, a short
variable name like \passthrough{\lstinline!x!} is best. A good rule of
thumb is that names that have a small scope should be short, whereas
names that have a large scope, like the name of a function in a module
interface, should be longer and more explicit.

There is of course a tradeoff here, in that making your APIs more
explicit tends to make them more verbose as well. Another useful rule of
thumb is that more rarely used names should be longer and more explicit,
since the cost of concision and the benefit of explicitness become more
important the more often a name is used.

\hypertarget{create-uniform-intefaces}{%
\subsubsection{Create Uniform
Interfaces}\label{create-uniform-intefaces}}

Designing the interface of a module is a task that should not be thought
of in isolation. The interfaces that appear in your codebase should play
together harmoniously. Part of achieving that is standardizing aspects
of those interfaces.

\passthrough{\lstinline!Base!}, \passthrough{\lstinline!Core!} and other
libraries from the same family have been designed with a uniform set of
standards in mind around the design of module interfaces. Here are some
of the guidelines that they use.

\begin{itemize}
\item
  \emph{A module for (almost) every type.} You should mint a module for
  almost every type in your program, and the primary type of a given
  module should be called \passthrough{\lstinline!t!}.
\item
  \emph{Put \passthrough{\lstinline!t!} first}. If you have a module
  \passthrough{\lstinline!M!} whose primary type is
  \passthrough{\lstinline!M.t!}, the functions in
  \passthrough{\lstinline!M!} that take a value of
  \passthrough{\lstinline!M.t!} should take it as their first argument.
\item
  Functions that routinely throw an exception should end in
  \passthrough{\lstinline!\_exn!}. Otherwise, errors should be signaled
  by returning an \passthrough{\lstinline!option!} or an
  \passthrough{\lstinline!Or\_error.t!} (both of which are discussed in
  \href{error-handling.html\#error-handling}{Error Handling} ).
\end{itemize}

There are also standards in Base about what the type signature for
specific functions should be. For example, the signature for
\passthrough{\lstinline!map!} is always essentially the same, no matter
what the underlying type it is applied to. This kind of
function-by-function API uniformity is achieved through the use of
\emph{signature includes}, which allow for different modules to share
components of their interface. This approach is described in
\href{functors.html\#using-multiple-interfaces}{Using Multiple
Interfaces}.

Base's standards may or may not fit your projects, but you can improve
the usability of your codebase by finding some consistent set of
standards to apply.

\hypertarget{interfaces-before-implementations}{%
\subsubsection{Interfaces before
implementations}\label{interfaces-before-implementations}}

OCaml's concise and flexible type language enables a type-oriented
approach to software design. Such an approach involves thinking through
and writing out the types you're going to use before embarking on the
implementation itself.

This is a good approach both when working in the core language, where
you would write your type definitions before writing the logic of your
computations, as well as at the module level, where you would write a
first draft of your \passthrough{\lstinline!mli!} before working on the
\passthrough{\lstinline!ml!}.

Of course, the design process goes in both directions. You'll often find
yourself going back and modifying your types in response to things you
learn by working on the implementation. But types and signatures provide
a lightweight tool for constructing a skeleton of your design in a way
that helps clarify your goals and intent, before you spend a lot of time
and effort fleshing it out.
