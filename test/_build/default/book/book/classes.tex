\hypertarget{classes}{%
\section{Classes}\label{classes}}

Programming with objects directly is great for encapsulation, but one of
the main goals of object-oriented programming is code reuse through
inheritance. For inheritance, we need to introduce \emph{classes}. In
object-oriented programming, a class is a ``recipe'' for creating
objects. The recipe can be changed by adding new methods and fields, or
it can be changed by modifying existing methods.
\index{programming/object-oriented programming (OOP)}

\hypertarget{ocaml-classes}{%
\subsection{OCaml Classes}\label{ocaml-classes}}

In OCaml, class definitions must be defined as toplevel statements in a
module. The syntax for a class definition uses the keyword
\passthrough{\lstinline!class!}: \index{classes/basic syntax for}

\begin{lstlisting}[language=Caml]
# open Base
# class istack = object
    val mutable v = [0; 2]

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v
  end
class istack :
  object
    val mutable v : int list
    method pop : int option
    method push : int -> unit
  end
\end{lstlisting}

The \passthrough{\lstinline!class istack : object ... end!} result shows
that we have created a class \passthrough{\lstinline!istack!} with
\emph{class type}\passthrough{\lstinline!object ... end!}. Like module
types, class types are completely separate from regular OCaml types
(e.g., \passthrough{\lstinline!int!}, \passthrough{\lstinline!string!},
and \passthrough{\lstinline!list!}) and, in particular, should not be
confused with object types (e.g.,
\passthrough{\lstinline!< get : int; .. >!}). The class type describes
the class itself rather than the objects that the class creates. This
particular class type specifies that the
\passthrough{\lstinline!istack!} class defines a mutable field
\passthrough{\lstinline!v!}, a method \passthrough{\lstinline!pop!} that
returns an \passthrough{\lstinline!int option!}, and a method
\passthrough{\lstinline!push!} with type
\passthrough{\lstinline!int -> unit!}.

To produce an object, classes are instantiated with the keyword
\passthrough{\lstinline!new!}:

\begin{lstlisting}[language=Caml]
# let s = new istack
val s : istack = <obj>
# s#pop
- : int option = Some 0
# s#push 5
- : unit = ()
# s#pop
- : int option = Some 5
\end{lstlisting}

You may have noticed that the object \passthrough{\lstinline!s!} has
been given the type \passthrough{\lstinline!istack!}. But wait, we've
stressed \emph{classes are not types}, so what's up with that? In fact,
what we've said is entirely true: classes and class names \emph{are not}
types. However, for convenience, the definition of the class
\passthrough{\lstinline!istack!} also defines an object type
\passthrough{\lstinline!istack!} with the same methods as the class.
This type definition is equivalent to:

\begin{lstlisting}[language=Caml]
# type istack = < pop: int option; push: int -> unit >
type istack = < pop : int option; push : int -> unit >
\end{lstlisting}

Note that this type represents any object with these methods: objects
created using the \passthrough{\lstinline!istack!} class will have this
type, but objects with this type may not have been created by the
\passthrough{\lstinline!istack!} class.

\hypertarget{class-parameters-and-polymorphism}{%
\subsection{Class Parameters and
Polymorphism}\label{class-parameters-and-polymorphism}}

A class definition serves as the \emph{constructor} for the class. In
general, a class definition may have parameters that must be provided as
arguments when the object is created with \passthrough{\lstinline!new!}.
\index{polymorphism/class parameters
and}\index{classes/class parameters and polymorphism}

Let's implement a variant of the \passthrough{\lstinline!istack!} class
that can hold any values, not just integers. When defining the class,
the type parameters are placed in square brackets before the class name
in the class definition. We also add a parameter
\passthrough{\lstinline!init!} for the initial contents of the stack:

\begin{lstlisting}[language=Caml]
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v
  end
class ['a] stack :
  'a list ->
  object
    val mutable v : 'a list
    method pop : 'a option
    method push : 'a -> unit
  end
\end{lstlisting}

Note that the type parameter \passthrough{\lstinline!['a]!} in the
definition uses square brackets, but for other uses of the type they are
omitted (or replaced with parentheses if there is more than one type
parameter).

The type annotation on the declaration of \passthrough{\lstinline!v!} is
used to constrain type inference. If we omit this annotation, the type
inferred for the class will be ``too polymorphic'':
\passthrough{\lstinline!init!} could have some type
\passthrough{\lstinline!'b list!}:

\begin{lstlisting}[language=Caml]
# class ['a] stack init = object
    val mutable v = init

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v
  end
Lines 1-13, characters 1-6:
Error: Some type variables are unbound in this type:
         class ['a] stack :
           'b list ->
           object
             val mutable v : 'b list
             method pop : 'b option
             method push : 'b -> unit
           end
       The method pop has type 'b option where 'b is unbound
\end{lstlisting}

In general, we need to provide enough constraints so that the compiler
will infer the correct type. We can add type constraints to the
parameters, to the fields, and to the methods. It is a matter of
preference how many constraints to add. You can add type constraints in
all three places, but the extra text may not help clarity. A convenient
middle ground is to annotate the fields and/or class parameters, and add
constraints to methods only if necessary.

\hypertarget{object-types-as-interfaces}{%
\subsection{Object Types as
Interfaces}\label{object-types-as-interfaces}}

We may wish to traverse the elements on our stack. One common style for
doing this in object-oriented languages is to define a class for an
\passthrough{\lstinline!iterator!} object. An iterator provides a
generic mechanism to inspect and traverse the elements of a collection.
\index{elements/traversing with iterator
objects}\index{iterators}\index{objects/object types as
interfaces}\index{interfaces/object types as}\index{classes/object types as
interfaces}

There are two common styles for defining abstract interfaces like this.
In Java, an iterator would normally be specified with an interface,
which specifies a set of method types:

\begin{lstlisting}[language=Java]
// Java-style iterator, specified as an interface.
interface <T> iterator {
  T Get();
  boolean HasValue();
  void Next();
};
\end{lstlisting}

In languages without interfaces, like C++, the specification would
normally use \emph{abstract} classes to specify the methods without
implementing them (C++ uses the ``= 0'' definition to mean ``not
implemented''):

\begin{lstlisting}[language={C++}]
// Abstract class definition in C++.
template<typename T>
class Iterator {
 public:
  virtual ~Iterator() {}
  virtual T get() const = 0;
  virtual bool has_value() const = 0;
  virtual void next() = 0;
};
\end{lstlisting}

OCaml supports both styles. In fact, OCaml is more flexible than these
approaches because an object type can be implemented by any object with
the appropriate methods; it does not have to be specified by the
object's class \emph{a priori}. We'll leave abstract classes for later.
Let's demonstrate the technique using object types.

First, we'll define an object type \passthrough{\lstinline!iterator!}
that specifies the methods in an iterator:

\begin{lstlisting}[language=Caml]
# type 'a iterator = < get : 'a; has_value : bool; next : unit >
type 'a iterator = < get : 'a; has_value : bool; next : unit >
\end{lstlisting}

Next, we'll define an actual iterator for lists. We can use this to
iterate over the contents of our stack:

\begin{lstlisting}[language=Caml]
# class ['a] list_iterator init = object
    val mutable current : 'a list = init

    method has_value = Poly.(current <> [])

    method get =
      match current with
      | hd :: tl -> hd
      | [] -> raise (Invalid_argument "no value")

    method next =
      match current with
      | hd :: tl -> current <- tl
      | [] -> raise (Invalid_argument "no value")
  end
class ['a] list_iterator :
  'a list ->
  object
    val mutable current : 'a list
    method get : 'a
    method has_value : bool
    method next : unit
  end
\end{lstlisting}

Finally, we add a method \passthrough{\lstinline!iterator!} to the
\passthrough{\lstinline!stack!} class to produce an iterator. To do so,
we construct a \passthrough{\lstinline!list\_iterator!} that refers to
the current contents of the stack:

\begin{lstlisting}[language=Caml]
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v

    method iterator : 'a iterator =
      new list_iterator v
  end
class ['a] stack :
  'a list ->
  object
    val mutable v : 'a list
    method iterator : 'a iterator
    method pop : 'a option
    method push : 'a -> unit
  end
\end{lstlisting}

Now we can build a new stack, push some values to it, and iterate over
them:

\begin{lstlisting}[language=Caml]
# let s = new stack []
val s : '_weak1 stack = <obj>
# s#push 5
- : unit = ()
# s#push 4
- : unit = ()
# let it = s#iterator
val it : int iterator = <obj>
# it#get
- : int = 4
# it#next
- : unit = ()
# it#get
- : int = 5
# it#next
- : unit = ()
# it#has_value
- : bool = false
\end{lstlisting}

\hypertarget{functional-iterators}{%
\subsubsection{Functional Iterators}\label{functional-iterators}}

In practice, most OCaml programmers avoid iterator objects in favor of
functional-style techniques. For example, the alternative
\passthrough{\lstinline!stack!} class that follows takes a function
\passthrough{\lstinline!f!} and applies it to each of the elements on
the stack: \index{functional iterators}

\begin{lstlisting}[language=Caml]
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v

    method iter f =
      List.iter ~f v
  end
class ['a] stack :
  'a list ->
  object
    val mutable v : 'a list
    method iter : ('a -> unit) -> unit
    method pop : 'a option
    method push : 'a -> unit
  end
\end{lstlisting}

What about functional operations like \passthrough{\lstinline!map!} and
\passthrough{\lstinline!fold!}? In general, these methods take a
function that produces a value of some other type than the elements of
the set.

For example, a \passthrough{\lstinline!fold!} method for our
\passthrough{\lstinline!['a] stack!} class should have type
\passthrough{\lstinline!('b -> 'a -> 'b) -> 'b -> 'b!}, where the
\passthrough{\lstinline!'b!} is polymorphic. To express a polymorphic
method type like this, we must use a type quantifier, as shown in the
following example:

\begin{lstlisting}[language=Caml]
# class ['a] stack init = object
    val mutable v : 'a list = init

    method pop =
      match v with
      | hd :: tl ->
        v <- tl;
        Some hd
      | [] -> None

    method push hd =
      v <- hd :: v

    method fold : 'b. ('b -> 'a -> 'b) -> 'b -> 'b =
      (fun f init -> List.fold ~f ~init v)
  end
class ['a] stack :
  'a list ->
  object
    val mutable v : 'a list
    method fold : ('b -> 'a -> 'b) -> 'b -> 'b
    method pop : 'a option
    method push : 'a -> unit
  end
\end{lstlisting}

The type quantifier \passthrough{\lstinline!'b.!} can be read as ``for
all \passthrough{\lstinline!'b!}.'' Type quantifiers can only be used
\emph{directly after} the method name, which means that method
parameters must be expressed using a \passthrough{\lstinline!fun!} or
\passthrough{\lstinline!function!} expression.

\hypertarget{inheritance}{%
\subsection{Inheritance}\label{inheritance}}

Inheritance uses an existing class to define a new one. For example, the
following class definition inherits from our
\passthrough{\lstinline!stack!} class for strings and adds a new method
\passthrough{\lstinline!print!} that prints all the strings on the
stack: \index{inheritance}\index{classes/inheritance in}

\begin{lstlisting}[language=Caml]
# class sstack init = object
    inherit [string] stack init

    method print =
      List.iter ~f:Stdio.print_endline v
  end
class sstack :
  string list ->
  object
    val mutable v : string list
    method pop : string option
    method print : unit
    method push : string -> unit
  end
\end{lstlisting}

A class can override methods from classes it inherits. For example, this
class creates stacks of integers that double the integers before they
are pushed onto the stack:

\begin{lstlisting}[language=Caml]
# class double_stack init = object
    inherit [int] stack init as super

    method push hd =
      super#push (hd * 2)
  end
class double_stack :
  int list ->
  object
    val mutable v : int list
    method pop : int option
    method push : int -> unit
  end
\end{lstlisting}

The preceding \passthrough{\lstinline!as super!} statement creates a
special object called \passthrough{\lstinline!super!} which can be used
to call superclass methods. Note that \passthrough{\lstinline!super!} is
not a real object and can only be used to call methods.

\hypertarget{class-types}{%
\subsection{Class Types}\label{class-types}}

To allow code in a different file or module to inherit from a class, we
must expose it and give it a class type. What is the class type?
\index{classes/class
types}

As an example, let's wrap up our \passthrough{\lstinline!stack!} class
in an explicit module (we'll use explicit modules for illustration, but
the process is similar when we want to define a
\passthrough{\lstinline!.mli!} file). In keeping with the usual style
for modules, we define a type \passthrough{\lstinline!'a t!} to
represent the type of our stacks:

\begin{lstlisting}[language=Caml]
module Stack = struct
  class ['a] stack init = object
    ...
  end

  type 'a t = 'a stack

  let make init = new stack init
end
\end{lstlisting}

We have multiple choices in defining the module type, depending on how
much of the implementation we want to expose. At one extreme, a
maximally abstract signature would completely hide the class
definitions:

\begin{lstlisting}[language=Caml]
module AbstractStack : sig
   type 'a t = < pop: 'a option; push: 'a -> unit >

   val make : unit -> 'a t
end = Stack
\end{lstlisting}

The abstract signature is simple because we ignore the classes. But what
if we want to include them in the signature so that other modules can
inherit from the class definitions? For this, we need to specify types
for the classes, called \emph{class types}.

Class types do not appear in mainstream object-oriented programming
languages, so you may not be familiar with them, but the concept is
pretty simple. A class type specifies the type of each of the visible
parts of the class, including both fields and methods. Just as with
module types, you don't have to give a type for everything; anything you
omit will be hidden:

\begin{lstlisting}[language=Caml]
module VisibleStack : sig

  type 'a t = < pop: 'a option; push: 'a -> unit >

  class ['a] stack : object
    val mutable v : 'a list
    method pop : 'a option
    method push : 'a -> unit
  end

  val make : unit -> 'a t
end = Stack
\end{lstlisting}

In this signature, we've chosen to make everything visible. The class
type for \passthrough{\lstinline!stack!} specifies the types of the
field \passthrough{\lstinline!v!}, as well as the types of each of the
methods.

\hypertarget{open-recursion}{%
\subsection{Open Recursion}\label{open-recursion}}

Open recursion allows an object's methods to invoke other methods on the
same object. These calls are looked up dynamically, allowing a method in
one class to call a method from another class, if both classes are
inherited by the same object. This allows mutually recursive parts of an
object to be defined separately.
\index{recursion/open recursion}\index{open
recursion}\index{classes/open recursion in}

This ability to define mutually recursive methods from separate
components is a key feature of classes: achieving similar functionality
with data types or modules is much more cumbersome and verbose.

For example, consider writing recursive functions over a simple document
format. This format is represented as a tree with three different types
of node:

\begin{lstlisting}[language=Caml]
type doc =
  | Heading of string
  | Paragraph of text_item list
  | Definition of string list_item list

and text_item =
  | Raw of string
  | Bold of text_item list
  | Enumerate of int list_item list
  | Quote of doc

and 'a list_item =
  { tag: 'a;
    text: text_item list }
\end{lstlisting}

It is quite easy to write a function that operates by recursively
traversing this data. However, what if you need to write many similar
recursive functions? How can you factor out the common parts of these
functions to avoid repetitive boilerplate?

The simplest way is to use classes and open recursion. For example, the
following class defines objects that fold over the document data:

\begin{lstlisting}[language=Caml]
open Core

class ['a] folder = object(self)
  method doc acc = function
  | Heading _ -> acc
  | Paragraph text -> List.fold ~f:self#text_item ~init:acc text
  | Definition list -> List.fold ~f:self#list_item ~init:acc list

  method list_item: 'b. 'a -> 'b list_item -> 'a =
    fun acc {tag; text} ->
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc = function
  | Raw _ -> acc
  | Bold text -> List.fold ~f:self#text_item ~init:acc text
  | Enumerate list -> List.fold ~f:self#list_item ~init:acc list
  | Quote doc -> self#doc acc doc
end
\end{lstlisting}

The \passthrough{\lstinline!object (self)!} syntax binds
\passthrough{\lstinline!self!} to the current object, allowing the
\passthrough{\lstinline!doc!}, \passthrough{\lstinline!list\_item!}, and
\passthrough{\lstinline!text\_item!} methods to call each other.

By inheriting from this class, we can create functions that fold over
the document data. For example, the \passthrough{\lstinline!count\_doc!}
function counts the number of bold tags in the document that are not
within a list:

\begin{lstlisting}[language=Caml]
class counter = object
  inherit [int] folder as super

  method list_item acc li = acc

  method text_item acc ti =
    let acc = super#text_item acc ti in
    match ti with
    | Bold _ -> acc + 1
    | _ -> acc
end

let count_doc = (new counter)#doc
\end{lstlisting}

Note how the \passthrough{\lstinline!super!} special object is used in
\passthrough{\lstinline!text\_item!} to call the
\passthrough{\lstinline![int] folder!} class's
\passthrough{\lstinline!text\_item!} method to fold over the children of
the \passthrough{\lstinline!text\_item!} node.

\hypertarget{private-methods}{%
\subsection{Private Methods}\label{private-methods}}

Methods can be declared \emph{private}, which means that they may be
called by subclasses, but they are not visible otherwise (similar to a
\emph{protected} method in C++).
\index{methods/private methods}\index{protected
methods}\index{private methods}\index{classes/private methods for}

For example, we may want to include methods in our
\passthrough{\lstinline!folder!} class for handling each of the
different cases in \passthrough{\lstinline!doc!} and
\passthrough{\lstinline!text\_item!}. However, we may not want to force
subclasses of \passthrough{\lstinline!folder!} to expose these methods,
as they probably shouldn't be called directly:

\begin{lstlisting}[language=Caml]
class ['a] folder2 = object(self)
  method doc acc = function
  | Heading str -> self#heading acc str
  | Paragraph text -> self#paragraph acc text
  | Definition list -> self#definition acc list

  method list_item: 'b. 'a -> 'b list_item -> 'a =
    fun acc {tag; text} ->
      List.fold ~f:self#text_item ~init:acc text

  method text_item acc = function
  | Raw str -> self#raw acc str
  | Bold text -> self#bold acc text
  | Enumerate list -> self#enumerate acc list
  | Quote doc -> self#quote acc doc

  method private heading acc str = acc
  method private paragraph acc text =
    List.fold ~f:self#text_item ~init:acc text
  method private definition acc list =
    List.fold ~f:self#list_item ~init:acc list

  method private raw acc str = acc
  method private bold acc text =
    List.fold ~f:self#text_item ~init:acc text
  method private enumerate acc list =
    List.fold ~f:self#list_item ~init:acc list
  method private quote acc doc = self#doc acc doc
end

let f :
  < doc : int -> doc -> int;
    list_item : 'a . int -> 'a list_item -> int;
    text_item : int -> text_item -> int >  = new folder2
\end{lstlisting}

The final statement that builds the value \passthrough{\lstinline!f!}
shows how the instantiation of a \passthrough{\lstinline!folder2!}
object has a type that hides the private methods.

To be precise, the private methods are part of the class type, but not
part of the object type. This means, for example, that the object
\passthrough{\lstinline!f!} has no method
\passthrough{\lstinline!bold!}. However, the private methods are
available to subclasses: we can use them to simplify our
\passthrough{\lstinline!counter!} class:

\begin{lstlisting}[language=Caml]
class counter_with_private_method = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt =
    let acc = super#bold acc txt in
    acc + 1
end
\end{lstlisting}

The key property of private methods is that they are visible to
subclasses, but not anywhere else. If you want the stronger guarantee
that a method is \emph{really} private, not even accessible in
subclasses, you can use an explicit class type that omits the method. In
the following code, the private methods are explicitly omitted from the
class type of \passthrough{\lstinline!counter\_with\_sig!} and can't be
invoked in subclasses of \passthrough{\lstinline!counter\_with\_sig!}:

\begin{lstlisting}[language=Caml]
class counter_with_sig : object
  method doc : int -> doc -> int
  method list_item : int -> 'b list_item -> int
  method text_item : int -> text_item -> int
end = object
  inherit [int] folder2 as super

  method list_item acc li = acc

  method private bold acc txt =
    let acc = super#bold acc txt in
    acc + 1
end
\end{lstlisting}

\hypertarget{binary-methods}{%
\subsection{Binary Methods}\label{binary-methods}}

A \emph{binary method} is a method that takes an object of
\passthrough{\lstinline!self!} type. One common example is defining a
method for equality: \index{methods/binary
methods}\index{classes/binary methods for}\index{binary methods}

\begin{lstlisting}[language=Caml]
# class square w = object(self : 'self)
    method width = w
    method area = Float.of_int (self#width * self#width)
    method equals (other : 'self) = other#width = self#width
  end
class square :
  int ->
  object ('a)
    method area : float
    method equals : 'a -> bool
    method width : int
  end
# class circle r = object(self : 'self)
    method radius = r
    method area = 3.14 *. (Float.of_int self#radius) **. 2.0
    method equals (other : 'self) = other#radius = self#radius
  end
class circle :
  int ->
  object ('a)
    method area : float
    method equals : 'a -> bool
    method radius : int
  end
\end{lstlisting}

Note how we can use the type annotation
\passthrough{\lstinline!(self: 'self)!} to obtain the type of the
current object.

We can now test different object instances for equality by using the
\passthrough{\lstinline!equals!} binary method:

\begin{lstlisting}[language=Caml]
# (new square 5)#equals (new square 5)
- : bool = true
# (new circle 10)#equals (new circle 7)
- : bool = false
\end{lstlisting}

This works, but there is a problem lurking here. The method
\passthrough{\lstinline!equals!} takes an object of the exact type
\passthrough{\lstinline!square!} or \passthrough{\lstinline!circle!}.
Because of this, we can't define a common base class
\passthrough{\lstinline!shape!} that also includes an equality method:

\begin{lstlisting}[language=Caml]
# type shape = < equals : shape -> bool; area : float >
type shape = < area : float; equals : shape -> bool >
# (new square 5 :> shape)
Line 1, characters 1-24:
Error: Type square = < area : float; equals : square -> bool; width : int >
       is not a subtype of shape = < area : float; equals : shape -> bool >
       Type shape = < area : float; equals : shape -> bool >
       is not a subtype of
         square = < area : float; equals : square -> bool; width : int >
       The first object type has no method width
\end{lstlisting}

The problem is that a \passthrough{\lstinline!square!} expects to be
compared with a \passthrough{\lstinline!square!}, not an arbitrary
shape; likewise for \passthrough{\lstinline!circle!}. This problem is
fundamental. Many languages solve it either with narrowing (with dynamic
type checking), or by method overloading. Since OCaml has neither of
these, what can we do?
\index{methods/method overloading}\index{dynamic type
checking}\index{narrowing}\index{polymorphism/polymorphic equality}

Since the problematic method is equality, one proposal we could consider
is to just drop it from the base type \passthrough{\lstinline!shape!}
and use polymorphic equality instead. However, the built-in polymorphic
equality has very poor behavior when applied to objects:

\begin{lstlisting}[language=Caml]
# Poly.(=)
    (object method area = 5 end)
  (object method area = 5 end)
- : bool = false
\end{lstlisting}

The problem here is that two objects are considered equal by the
built-in polymorphic equality if and only if they are physically equal.
There are other reasons not to use the built-in polymorphic equality,
but these false negatives are a showstopper.

If we want to define equality for shapes in general, the remaining
solution is to use the same approach as we described for narrowing. That
is, introduce a \emph{representation} type implemented using variants,
and implement the comparison based on the representation type:
\index{representation types}

\begin{lstlisting}[language=Caml]
# type shape_repr =
    | Square of int
  | Circle of int
type shape_repr = Square of int | Circle of int
# type shape =
  < repr : shape_repr; equals : shape -> bool; area : float >
type shape = < area : float; equals : shape -> bool; repr : shape_repr >
# class square w = object(self)
    method width = w
    method area = Float.of_int (self#width * self#width)
    method repr = Square self#width
    method equals (other : shape) = Poly.(=) other#repr self#repr
  end
class square :
  int ->
  object
    method area : float
    method equals : shape -> bool
    method repr : shape_repr
    method width : int
  end
\end{lstlisting}

The binary method \passthrough{\lstinline!equals!} is now implemented in
terms of the concrete type \passthrough{\lstinline!shape\_repr!}. When
using this pattern, you will not be able to hide the
\passthrough{\lstinline!repr!} method, but you can hide the type
definition using the module system:

\begin{lstlisting}[language=Caml]
module Shapes : sig
  type shape_repr
  type shape =
    < repr : shape_repr; equals : shape -> bool; area: float >

  class square : int ->
    object
      method width : int
      method area : float
      method repr : shape_repr
      method equals : shape -> bool
    end
end = struct
  type shape_repr =
  | Square of int
  | Circle of int
  ...
end
\end{lstlisting}

Note that this solution prevents us from adding new kinds of shapes
without adding new constructors to the
\passthrough{\lstinline!shape\_repr!} type, which is quite restrictive.
The objects created by these classes are also in one-to-one
correspondence with members of the representation type, making the
objects seem somewhat redundant.

However, equality is quite an extreme instance of a binary method: it
needs access to all the information of the other object. Many other
binary methods need only partial information about the object. For
instance, a method that compares shapes by their sizes:

\begin{lstlisting}[language=Caml]
class square w = object(self)
  method width = w
  method area = Float.of_int (self#width * self#width)
  method larger other = Float.(self#area > other#area)
end
\end{lstlisting}

In this case, there is no one-to-one correspondence between the objects
and their sizes, and we can still easily define new kinds of shape.

\hypertarget{virtual-classes-and-methods}{%
\subsection{Virtual Classes and
Methods}\label{virtual-classes-and-methods}}

A \emph{virtual} class is a class where some methods or fields are
declared but not implemented. This should not be confused with the word
\passthrough{\lstinline!virtual!} as it is used in C++. A
\passthrough{\lstinline!virtual!} method in C++ uses dynamic dispatch,
while regular, nonvirtual methods are statically dispatched. In OCaml,
\emph{all} methods use dynamic dispatch, but the keyword
\passthrough{\lstinline!virtual!} means that the method or field is not
implemented. A class containing virtual methods must also be flagged
\passthrough{\lstinline!virtual!} and cannot be directly instantiated
(i.e., no object of this class can be created).
\index{dispatching, dynamic vs. static}\index{static
dispatch}\index{dynamic dispatch}\index{virtual methods}\index{methods/and
virtual classes}\index{virtual classes}\index{classes/virtual classes}

To explore this, let's extend our shapes examples to simple, interactive
graphics. We will use the Async concurrency library and the
\href{http://github.com/lpw25/async_graphics/}{Async\_graphics} library,
which provides an asynchronous interface to OCaml's built-in Graphics
library. Concurrent programming with Async will be explored later in
\href{concurrent-programming.html\#concurrent-programming-with-async}{Concurrent
Programming With Async}; for now you can safely ignore the details. You
just need to run \passthrough{\lstinline!opam install async\_graphics!}
to get the library installed on your system.

We will give each shape a \passthrough{\lstinline!draw!} method that
describes how to draw the shape on the
\passthrough{\lstinline!Async\_graphics!} display:

\begin{lstlisting}[language=Caml]
open Core
open Async
open Async_graphics

type drawable = < draw: unit >
\end{lstlisting}

\hypertarget{create-some-simple-shapes}{%
\subsubsection{Create Some Simple
Shapes}\label{create-some-simple-shapes}}

Now let's add classes for making squares and circles. We include an
\passthrough{\lstinline!on\_click!} method for adding event handlers to
the shapes: \index{geometric
shapes}

\begin{lstlisting}[language=Caml]
class square w x y = object(self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' =
    x <= x' && x' <= x + width &&
      y <= y' && y' <= y + width

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev ->
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
\end{lstlisting}

The \passthrough{\lstinline!square!} class is pretty straightforward,
and the \passthrough{\lstinline!circle!} class below also looks very
similar:

\begin{lstlisting}[language=Caml]
class circle r x y = object(self)
  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
      dist <= (Float.of_int radius)

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev ->
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
\end{lstlisting}

These classes have a lot in common, and it would be useful to factor out
this common functionality into a superclass. We can easily move the
definitions of \passthrough{\lstinline!x!} and
\passthrough{\lstinline!y!} into a superclass, but what about
\passthrough{\lstinline!on\_click!}? Its definition depends on
\passthrough{\lstinline!contains!}, which has a different definition in
each class. The solution is to create a \emph{virtual} class. This class
will declare a \passthrough{\lstinline!contains!} method but leave its
definition to the subclasses.

Here is the more succinct definition, starting with a virtual
\passthrough{\lstinline!shape!} class that implements
\passthrough{\lstinline!on\_click!} and
\passthrough{\lstinline!on\_mousedown!}:

\begin{lstlisting}[language=Caml]
class virtual shape x y = object(self)
  method virtual private contains: int -> int -> bool

  val mutable x: int = x
  method x = x

  val mutable y: int = y
  method y = y

  method on_click ?start ?stop f =
    on_click ?start ?stop
      (fun ev ->
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)

  method on_mousedown ?start ?stop f =
    on_mousedown ?start ?stop
      (fun ev ->
         if self#contains ev.mouse_x ev.mouse_y then
           f ev.mouse_x ev.mouse_y)
end
\end{lstlisting}

Now we can define \passthrough{\lstinline!square!} and
\passthrough{\lstinline!circle!} by inheriting from
\passthrough{\lstinline!shape!}:

\begin{lstlisting}[language=Caml]
class square w x y = object
  inherit shape x y

  val mutable width = w
  method width = width

  method draw = fill_rect x y width width

  method private contains x' y' =
    x <= x' && x' <= x + width &&
    y <= y' && y' <= y + width
end

class circle r x y = object
  inherit shape x y

  val mutable radius = r
  method radius = radius

  method draw = fill_circle x y radius

  method private contains x' y' =
    let dx = abs (x' - x) in
    let dy = abs (y' - y) in
    let dist = sqrt (Float.of_int ((dx * dx) + (dy * dy))) in
    dist <= (Float.of_int radius)
end
\end{lstlisting}

One way to view a \passthrough{\lstinline!virtual!} class is that it is
like a functor, where the ``inputs'' are the declared---but not
defined---virtual methods and fields. The functor application is
implemented through inheritance, when virtual methods are given concrete
implementations.

\hypertarget{initializers}{%
\subsection{Initializers}\label{initializers}}

You can execute expressions during the instantiation of a class by
placing them before the object expression or in the initial value of a
field: \index{initializers}\index{classes/initializers for}

\begin{lstlisting}[language=Caml]
# class obj x =
    let () = Stdio.printf "Creating obj %d\n" x in
    object
      val field = Stdio.printf "Initializing field\n"; x
  end
class obj : int -> object val field : int end
# let o = new obj 3
Creating obj 3
Initializing field
val o : obj = <obj>
\end{lstlisting}

However, these expressions are executed before the object has been
created and cannot refer to the methods of the object. If you need to
use an object's methods during instantiation, you can use an
initializer. An initializer is an expression that will be executed
during instantiation but after the object has been created.

For example, suppose we wanted to extend our previous shapes module with
a \passthrough{\lstinline!growing\_circle!} class for circles that
expand when clicked. We could inherit from
\passthrough{\lstinline!circle!} and used the inherited
\passthrough{\lstinline!on\_click!} to add a handler for click events:

\begin{lstlisting}[language=Caml]
class growing_circle r x y = object(self)
  inherit circle r x y

  initializer
    self#on_click (fun _x _y -> radius <- radius * 2)
end
\end{lstlisting}

\hypertarget{multiple-inheritance}{%
\subsection{Multiple Inheritance}\label{multiple-inheritance}}

When a class inherits from more than one superclass, it is using
\emph{multiple inheritance}. Multiple inheritance extends the variety of
ways that classes can be combined, and it can be quite useful,
particularly with virtual classes. However, it can be tricky to use,
particularly when the inheritance hierarchy is a graph rather than a
tree, so it should be used with care.
\index{multiple inheritance/name resolution
in}\index{inheritance}\index{classes/multiple inheritance in}

\hypertarget{how-names-are-resolved}{%
\subsubsection{How Names Are Resolved}\label{how-names-are-resolved}}

The main trickiness of multiple inheritance is due to naming---what
happens when a method or field with some name is defined in more than
one class?

If there is one thing to remember about inheritance in OCaml, it is
this: inheritance is like textual inclusion. If there is more than one
definition for a name, the last definition wins.

For example, consider this class, which inherits from
\passthrough{\lstinline!square!} and defines a new
\passthrough{\lstinline!draw!} method that uses
\passthrough{\lstinline!draw\_rect!} instead of
\passthrough{\lstinline!fill\_rect!} to draw the square:

\begin{lstlisting}[language=Caml]
class square_outline w x y = object
  inherit square w x y
  method draw = draw_rect x y width width
end
\end{lstlisting}

Since the \passthrough{\lstinline!inherit!} declaration comes before the
method definition, the new \passthrough{\lstinline!draw!} method
overrides the old one, and the square is drawn using
\passthrough{\lstinline!draw\_rect!}. But, what if we had defined
\passthrough{\lstinline!square\_outline!} as follows?

\begin{lstlisting}[language=Caml]
class square_outline w x y = object
  method draw = draw_rect x y w w
  inherit square w x y
end
\end{lstlisting}

Here the \passthrough{\lstinline!inherit!} declaration comes after the
method definition, so the \passthrough{\lstinline!draw!} method from
\passthrough{\lstinline!square!} will override the other definition, and
the square will be drawn using \passthrough{\lstinline!fill\_rect!}.

To reiterate, to understand what inheritance means, replace each
\passthrough{\lstinline!inherit!} directive with its definition, and
take the last definition of each method or field. Note that the methods
and fields added by an inheritance are those listed in its class type,
so private methods that are hidden by the type will not be included.

\hypertarget{mixins}{%
\subsubsection{Mixins}\label{mixins}}

When should you use multiple inheritance? If you ask multiple people,
you're likely to get multiple (perhaps heated) answers. Some will argue
that multiple inheritance is overly complicated; others will argue that
inheritance is problematic in general, and one should use object
composition instead. But regardless of who you talk to, you will rarely
hear that multiple inheritance is great and that you should use it
widely. \index{mixin
patterns}\index{multiple inheritance/mixin pattern and}

In any case, if you're programming with objects, there's one general
pattern for multiple inheritance that is both useful and reasonably
simple: the \emph{mixin} pattern. Generically, a \emph{mixin} is just a
virtual class that implements a feature based on another one. If you
have a class that implements methods \emph{A}, and you have a mixin
\emph{M} that provides methods \emph{B} from \emph{A}, then you can
inherit from \emph{M}---``mixing'' it in---to get features \emph{B}.

That's too abstract, so let's give some examples based on our
interactive shapes. We may wish to allow a shape to be dragged by the
mouse. We can define this functionality for any object that has mutable
\passthrough{\lstinline!x!} and \passthrough{\lstinline!y!} fields and
an \passthrough{\lstinline!on\_mousedown!} method for adding event
handlers:

\begin{lstlisting}[language=Caml]
class virtual draggable = object(self)
  method virtual on_mousedown:
    ?start:unit Deferred.t ->
    ?stop:unit Deferred.t ->
    (int -> int -> unit) -> unit
  val virtual mutable x: int
  val virtual mutable y: int

  val mutable dragging = false
  method dragging = dragging

  initializer
    self#on_mousedown
      (fun mouse_x mouse_y ->
         let offset_x = x - mouse_x in
         let offset_y = y - mouse_y in
         let mouse_up = Ivar.create () in
         let stop = Ivar.read mouse_up in
         dragging <- true;
         on_mouseup ~stop
           (fun _ ->
              Ivar.fill mouse_up ();
              dragging <- false);
         on_mousemove ~stop
           (fun ev ->
              x <- ev.mouse_x + offset_x;
              y <- ev.mouse_y + offset_y))
end
\end{lstlisting}

This allows us to create draggable shapes using multiple inheritance:

\begin{lstlisting}[language=Caml]
class small_square = object
  inherit square 20 40 40
  inherit draggable
end
\end{lstlisting}

We can also use mixins to create animated shapes. Each animated shape
has a list of update functions to be called during animation. We create
an \passthrough{\lstinline!animated!} mixin to provide this update list
and ensure that the functions in it are called regular intervals when
the shape is animated: \index{animation/creating with mixins}

\begin{lstlisting}[language=Caml]
class virtual animated span = object(self)
  method virtual on_click:
    ?start:unit Deferred.t ->
    ?stop:unit Deferred.t ->
    (int -> int -> unit) -> unit
  val mutable updates: (int -> unit) list = []
  val mutable step = 0
  val mutable running = false

  method running = running

  method animate =
    step <- 0;
    running <- true;
    let stop =
      Clock.after span
      >>| fun () -> running <- false
    in
    Clock.every ~stop (Time.Span.of_sec (1.0 /. 24.0))
      (fun () ->
         step <- step + 1;
         List.iter ~f:(fun f -> f step) updates
      )

  initializer
    self#on_click (fun _x _y -> if not self#running then self#animate)
end
\end{lstlisting}

We use initializers to add functions to this update list. For example,
this class will produce circles that move to the right for a second when
clicked:

\begin{lstlisting}[language=Caml]
class my_circle = object
  inherit circle 20 50 50
  inherit animated Time.Span.second
  initializer updates <- [fun _ -> x <- x + 5]
end
\end{lstlisting}

These initializers can also be added using mixins:

\begin{lstlisting}[language=Caml]
class virtual linear x' y' = object
  val virtual mutable updates: (int -> unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update _ =
      x <- x + x';
      y <- y + y'
    in
    updates <- update :: updates
end

let pi = (Float.atan 1.0) *. 4.0

class virtual harmonic offset x' y' = object
  val virtual mutable updates: (int -> unit) list
  val virtual mutable x: int
  val virtual mutable y: int

  initializer
    let update step =
      let m = Float.sin (offset +. ((Float.of_int step) *. (pi /. 64.))) in
      let x' = Float.to_int (m *. Float.of_int x') in
      let y' = Float.to_int (m *. Float.of_int y') in
      x <- x + x';
      y <- y + y'
    in
    updates <- update :: updates
end
\end{lstlisting}

Since the \passthrough{\lstinline!linear!} and
\passthrough{\lstinline!harmonic!} mixins are only used for their side
effects, they can be inherited multiple times within the same object to
produce a variety of different animations: \index{linear mixins}

\begin{lstlisting}[language=Caml]
class my_square x y = object
  inherit square 40 x y
  inherit draggable
  inherit animated (Time.Span.of_int_sec 5)
  inherit linear 5 0
  inherit harmonic 0.0 7 ~-10
end

let my_circle = object
  inherit circle 30 250 250
  inherit animated (Time.Span.minute)
  inherit harmonic 0.0 10 0
  inherit harmonic (pi /. 2.0) 0 10
end
\end{lstlisting}

\hypertarget{displaying-the-animated-shapes}{%
\subsubsection{Displaying the Animated
Shapes}\label{displaying-the-animated-shapes}}

We finish our shapes module by creating a \passthrough{\lstinline!main!}
function to draw some shapes on the graphical display and running that
function using the Async scheduler:
\index{animation/displaying animated shapes}\index{multiple inheritance/displaying
animated shapes with}

\begin{lstlisting}[language=Caml]
let main () =
  let shapes = [
     (my_circle :> drawable);
     (new my_square 50 350 :> drawable);
     (new my_square 50 200 :> drawable);
     (new growing_circle 20 70 70 :> drawable);
  ] in
  let repaint () =
    clear_graph ();
    List.iter ~f:(fun s -> s#draw) shapes;
    synchronize ()
  in
    open_graph "";
    auto_synchronize false;
    Clock.every (Time.Span.of_sec (1.0 /. 24.0)) repaint

let () = never_returns (Scheduler.go_main ~main ())
\end{lstlisting}

Our \passthrough{\lstinline!main!} function creates a list of shapes to
be displayed and defines a \passthrough{\lstinline!repaint!} function
that actually draws them on the display. We then open a graphical
display and ask Async to run \passthrough{\lstinline!repaint!} at
regular intervals.

Finally, build the binary by linking against the
\passthrough{\lstinline!async\_graphics!} package, which will pull in
all the other dependencies:

\begin{lstlisting}
(executable
  (name      shapes)
  (modules   shapes)
  (libraries async_graphics))
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ dune build shapes.exe
\end{lstlisting}

When you run the binary, a new graphical window should appear (on Mac OS
X, you will need to install the X11 package first, which you will be
prompted for). Try clicking on the various widgets, and gasp in awe at
the sophisticated animations that unfold as a result.

The graphics library described here is the one built into OCaml and is
more useful as a learning tool than anything else. There are several
third-party libraries that provide more sophisticated bindings to
various graphics subsystems:
\index{js\_of\_ocaml library}\index{LabIGL library}\index{Lablgtk
library}\index{graphics libraries}\index{libraries/for
graphics}\index{external libraries/for graphics}

\begin{description}
\tightlist
\item[\href{http://lablgtk.forge.ocamlcore.org}{Lablgtk}]
A strongly typed interface to the GTK widget library.
\item[\href{https://forge.ocamlcore.org/projects/lablgl/}{LablGL}]
An interface between OCaml and OpenGL, a widely supported standard for
3D rendering.
\item[\href{http://ocsigen.org/js_of_ocaml/api/Js}{js\_of\_ocaml}]
Compiles OCaml code to JavaScript and has bindings to WebGL. This is the
emerging standard for 3D rendering in web browsers.
\end{description}
