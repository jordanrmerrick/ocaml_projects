\hypertarget{imperative-programming-1}{%
\section{Imperative Programming}\label{imperative-programming-1}}

Most of the code shown so far in this book, and indeed, most OCaml code
in general, is \emph{pure}. Pure code works without mutating the
program's internal state, performing I/O, reading the clock, or in any
other way interacting with changeable parts of the world. Thus, a pure
function behaves like a mathematical function, always returning the same
results when given the same inputs, and never affecting the world except
insofar as it returns the value of its computation. \emph{Imperative}
code, on the other hand, operates by side effects that modify a
program's internal state or interact with the outside world. An
imperative function has a new effect, and potentially returns different
results, every time it's called. \index{imperative programming/benefits
of}\index{pure code}\index{programming/immutable vs.
imperative}\protect\hypertarget{PROGimper}{}{programming/imperative
programming}

Pure code is the default in OCaml, and for good reason---it's generally
easier to reason about, less error prone and more composable. But
imperative code is of fundamental importance to any practical
programming language, because real-world tasks require that you interact
with the outside world, which is by its nature imperative. Imperative
programming can also be important for performance. While pure code is
quite efficient in OCaml, there are many algorithms that can only be
implemented efficiently using imperative techniques.

OCaml offers a happy compromise here, making it easy and natural to
program in a pure style, but also providing great support for imperative
programming. This chapter will walk you through OCaml's imperative
features, and help you use them to their fullest.

\hypertarget{example-imperative-dictionaries}{%
\subsection{Example: Imperative
Dictionaries}\label{example-imperative-dictionaries}}

We'll start with the implementation of a simple imperative dictionary,
i.e., a mutable mapping from keys to values. This is really for
illustration purposes; both Core and the standard library provide
imperative dictionaries, and for most real-world tasks, you should use
one of those implementations. There's more advice on using Core's
implementation in particular in
\href{maps-and-hashtables.html\#maps-and-hash-tables}{Maps And Hash
Tables}. \protect\hypertarget{DICTimper}{}{dictionaries,
imperative}\index{Core standard library/imperative
dictionaries in}\protect\hypertarget{IPimpdict}{}{imperative
programming/imperative dictionaries}

The dictionary we'll describe now, like those in Core and the standard
library, will be implemented as a hash table. In particular, we'll use
an \emph{open hashing} scheme, where the hash table will be an array of
buckets, each bucket containing a list of key/value pairs that have been
hashed into that bucket. \index{open hashing}

Here's the interface we'll match, provided as an
\passthrough{\lstinline!mli!}. The type
\passthrough{\lstinline!('a, 'b) t!} represents a dictionary with keys
of type \passthrough{\lstinline!'a!} and data of type
\passthrough{\lstinline!'b!}:

\begin{lstlisting}[language=Caml]
(* file: dictionary.mli *)
open Base

type ('a, 'b) t

val create : unit -> ('a, 'b) t
val length : ('a, 'b) t -> int
val add    : ('a, 'b) t -> key:'a -> data:'b -> unit
val find   : ('a, 'b) t -> 'a -> 'b option
val iter   : ('a, 'b) t -> f:(key:'a -> data:'b -> unit) -> unit
val remove : ('a, 'b) t -> 'a -> unit
\end{lstlisting}

The \passthrough{\lstinline!mli!} also includes a collection of helper
functions whose purpose and behavior should be largely inferrable from
their names and type signatures. Notice that a number of the functions,
in particular, ones like \passthrough{\lstinline!add!} that modify the
dictionary, return \passthrough{\lstinline!unit!}. This is typical of
functions that act by side effect.

We'll now walk through the implementation (contained in the
corresponding \passthrough{\lstinline!ml!} file) piece by piece,
explaining different imperative constructs as they come up.

Our first step is to define the type of a dictionary as a record with
two fields:

\begin{lstlisting}[language=Caml]
(* file: dictionary.ml *)
open Base

type ('a, 'b) t = { mutable length: int;
                    buckets: ('a * 'b) list array;
                  }
\end{lstlisting}

The first field, \passthrough{\lstinline!length!}, is declared as
mutable. In OCaml, records are immutable by default, but individual
fields are mutable when marked as such. The second field,
\passthrough{\lstinline!buckets!}, is immutable but contains an array,
which is itself a mutable data structure. \index{fields/mutability of}

Now we'll start putting together the basic functions for manipulating a
dictionary:

\begin{lstlisting}[language=Caml]
let num_buckets = 17

let hash_bucket key = (Hashtbl.hash key) % num_buckets

let create () =
  { length = 0;
    buckets = Array.create ~len:num_buckets [];
  }

let length t = t.length

let find t key =
  List.find_map t.buckets.(hash_bucket key)
    ~f:(fun (key',data) -> if key' = key then Some data else None)
\end{lstlisting}

Note that \passthrough{\lstinline!num\_buckets!} is a constant, which
means our bucket array is of fixed length. A practical implementation
would need to be able to grow the array as the number of elements in the
dictionary increases, but we'll omit this to simplify the presentation.

The function \passthrough{\lstinline!hash\_bucket!} is used throughout
the rest of the module to choose the position in the array that a given
key should be stored at. It is implemented on top of
\passthrough{\lstinline!Hashtbl.hash!}, which is a hash function
provided by the OCaml runtime that can be applied to values of any type.
Thus, its own type is polymorphic: \passthrough{\lstinline!'a -> int!}.

The other functions defined above are fairly straightforward:

\begin{description}
\tightlist
\item[\texttt{create}]
Creates an empty dictionary.
\item[\texttt{length}]
Grabs the length from the corresponding record field, thus returning the
number of entries stored in the dictionary.
\item[\texttt{find}]
Looks for a matching key in the table and returns the corresponding
value if found as an option.
\end{description}

Another important piece of imperative syntax shows up in
\passthrough{\lstinline!find!}: we write
\passthrough{\lstinline!array.(index)!} to grab a value from an array.
\passthrough{\lstinline!find!} also uses
\passthrough{\lstinline!List.find\_map!}, which you can see the type of
by typing it into the toplevel:

\begin{lstlisting}[language=Caml]
# List.find_map
- : 'a list -> f:('a -> 'b option) -> 'b option = <fun>
\end{lstlisting}

\passthrough{\lstinline!List.find\_map!} iterates over the elements of
the list, calling \passthrough{\lstinline!f!} on each one until a
\passthrough{\lstinline!Some!} is returned by
\passthrough{\lstinline!f!}, at which point that value is returned. If
\passthrough{\lstinline!f!} returns \passthrough{\lstinline!None!} on
all values, then \passthrough{\lstinline!None!} is returned.

Now let's look at the implementation of \passthrough{\lstinline!iter!}:

\begin{lstlisting}[language=Caml]
let iter t ~f =
  for i = 0 to Array.length t.buckets - 1 do
    List.iter t.buckets.(i) ~f:(fun (key, data) -> f ~key ~data)
  done
\end{lstlisting}

\passthrough{\lstinline!iter!} is designed to walk over all the entries
in the dictionary. In particular, \passthrough{\lstinline!iter t \~f!}
will call \passthrough{\lstinline!f!} for each key/value pair in
dictionary \passthrough{\lstinline!t!}. Note that
\passthrough{\lstinline!f!} must return \passthrough{\lstinline!unit!},
since it is expected to work by side effect rather than by returning a
value, and the overall \passthrough{\lstinline!iter!} function returns
\passthrough{\lstinline!unit!} as well.

The code for \passthrough{\lstinline!iter!} uses two forms of iteration:
a \passthrough{\lstinline!for!} loop to walk over the array of buckets;
and within that loop a call to \passthrough{\lstinline!List.iter!} to
walk over the values in a given bucket. We could have done the outer
loop with a recursive function instead of a
\passthrough{\lstinline!for!} loop, but \passthrough{\lstinline!for!}
loops are syntactically convenient, and are more familiar and idiomatic
in imperative contexts.

The following code is for adding and removing mappings from the
dictionary:

\begin{lstlisting}[language=Caml]
let bucket_has_key t i key =
  List.exists t.buckets.(i) ~f:(fun (key',_) -> key' = key)

let add t ~key ~data =
  let i = hash_bucket key in
  let replace = bucket_has_key t i key in
  let filtered_bucket =
    if replace then
      List.filter t.buckets.(i) ~f:(fun (key',_) -> key' <> key)
    else
      t.buckets.(i)
  in
  t.buckets.(i) <- (key, data) :: filtered_bucket;
  if not replace then t.length <- t.length + 1

let remove t key =
  let i = hash_bucket key in
  if bucket_has_key t i key then (
    let filtered_bucket =
      List.filter t.buckets.(i) ~f:(fun (key',_) -> key' <> key)
    in
    t.buckets.(i) <- filtered_bucket;
    t.length <- t.length - 1
  )
\end{lstlisting}

This preceding code is made more complicated by the fact that we need to
detect whether we are overwriting or removing an existing binding, so we
can decide whether \passthrough{\lstinline!t.length!} needs to be
changed. The helper function \passthrough{\lstinline!bucket\_has\_key!}
is used for this purpose.

Another piece of syntax shows up in both \passthrough{\lstinline!add!}
and \passthrough{\lstinline!remove!}: the use of the
\passthrough{\lstinline!<-!} operator to update elements of an array
(\passthrough{\lstinline!array.(i) <- expr!}) and for updating a record
field (\passthrough{\lstinline!record.field <- expression!}).

We also use \passthrough{\lstinline!;!}, the sequencing operator, to
express a sequence of imperative actions. We could have done the same
using \passthrough{\lstinline!let!} bindings:

\begin{lstlisting}[language=Caml]
let () = t.buckets.(i) <- (key, data) :: filtered_bucket in
  if not replace then t.length <- t.length + 1
\end{lstlisting}

but \passthrough{\lstinline!;!} is more concise and idiomatic. More
generally,

\begin{lstlisting}
<expr1>;
<expr2>;
...
<exprN>
\end{lstlisting}

is equivalent to

\begin{lstlisting}
let () = <expr1> in
let () = <expr2> in
...
<exprN>
\end{lstlisting}

When a sequence expression \passthrough{\lstinline!expr1; expr2!} is
evaluated, \passthrough{\lstinline!expr1!} is evaluated first, and then
\passthrough{\lstinline!expr2!}. The expression
\passthrough{\lstinline!expr1!} should have type
\passthrough{\lstinline!unit!} (though this is a warning rather than a
hard restriction. The \passthrough{\lstinline!-strict-sequence!}
compiler flag makes this a hard restriction, which is generally a good
idea), and the value of \passthrough{\lstinline!expr2!} is returned as
the value of the entire sequence. For example, the sequence
\passthrough{\lstinline!print\_string "hello world"; 1 + 2!} first
prints the string \passthrough{\lstinline!"hello world"!}, then returns
the integer \passthrough{\lstinline!3!}.

Note also that we do all of the side-effecting operations at the very
end of each function. This is good practice because it minimizes the
chance that such operations will be interrupted with an exception,
leaving the data structure in an inconsistent state. ~~

\hypertarget{primitive-mutable-data}{%
\subsection{Primitive Mutable Data}\label{primitive-mutable-data}}

Now that we've looked at a complete example, let's take a more
systematic look at imperative programming in OCaml. We encountered two
different forms of mutable data above: records with mutable fields and
arrays. We'll now discuss these in more detail, along with the other
primitive forms of mutable data that are available in OCaml.
\index{array-like data}\index{data
structures/primitive mutable data}\index{mutable data}\index{primitive
mutable data/array-like data}\index{imperative programming/primitive mutable
data}

\hypertarget{array-like-data}{%
\subsubsection{Array-Like Data}\label{array-like-data}}

OCaml supports a number of array-like data structures; i.e., mutable
integer-indexed containers that provide constant-time access to their
elements. We'll discuss several of them in this section.

\hypertarget{ordinary-arrays}{%
\paragraph{Ordinary arrays}\label{ordinary-arrays}}

The \passthrough{\lstinline!array!} type is used for general-purpose
polymorphic arrays. The \passthrough{\lstinline!Array!} module has a
variety of utility functions for interacting with arrays, including a
number of mutating operations. These include
\passthrough{\lstinline!Array.set!}, for setting an individual element,
and \passthrough{\lstinline!Array.blit!}, for efficiently copying values
from one range of indices to another. \index{values/copying with
Array.blit}\index{elements/setting with Array.set}\index{Array
module/Array.blit}\index{Array module/Array.set}

Arrays also come with special syntax for retrieving an element from an
array:

\begin{lstlisting}
<array_expr>.(<index_expr>)
\end{lstlisting}

and for setting an element in an array:

\begin{lstlisting}
<array_expr>.(<index_expr>) <- <value_expr>
\end{lstlisting}

Out-of-bounds accesses for arrays (and indeed for all the array-like
data structures) will lead to an exception being thrown.

Array literals are written using \passthrough{\lstinline![|!} and
\passthrough{\lstinline!|]!} as delimiters. Thus,
\passthrough{\lstinline![| 1; 2; 3 |]!} is a literal integer array.

\hypertarget{strings}{%
\paragraph{Strings}\label{strings}}

Strings are essentially byte arrays which are often used for textual
data. The main advantage of using a \passthrough{\lstinline!string!} in
place of a \passthrough{\lstinline!Char.t array!} (a
\passthrough{\lstinline!Char.t!} is an 8-bit character) is that the
former is considerably more space-efficient; an array uses one word---8
bytes on a 64-bit machine---to store a single entry, whereas strings use
1 byte per character. \index{byte
arrays}\index{strings/vs. Char.t arrays}

Strings also come with their own syntax for getting and setting values:

\begin{lstlisting}
<string_expr>.[<index_expr>]
<string_expr>.[<index_expr>] <- <char_expr>
\end{lstlisting}

And string literals are bounded by quotes. There's also a module
\passthrough{\lstinline!String!} where you'll find useful functions for
working with strings.

\hypertarget{bigarrays}{%
\paragraph{Bigarrays}\label{bigarrays}}

A \passthrough{\lstinline!Bigarray.t!} is a handle to a block of memory
stored outside of the OCaml heap. These are mostly useful for
interacting with C or Fortran libraries, and are discussed in
\href{runtime-memory-layout.html\#memory-representation-of-values}{Memory
Representation Of Values}. Bigarrays too have their own getting and
setting syntax: \index{bigarrays}

\begin{lstlisting}
<bigarray_expr>.{<index_expr>}
<bigarray_expr>.{<index_expr>} <- <value_expr>
\end{lstlisting}

\hypertarget{mutable-record-and-object-fields-and-ref-cells}{%
\subsubsection{Mutable Record and Object Fields and Ref
Cells}\label{mutable-record-and-object-fields-and-ref-cells}}

As we've seen, records are immutable by default, but individual record
fields can be declared as mutable. These mutable fields can be set using
the \passthrough{\lstinline!<-!} operator, i.e.,
\passthrough{\lstinline!record.field <- expr!}.
\index{fields/mutability of}

As we'll see in \href{objects.html\#objects}{Objects}, fields of an
object can similarly be declared as mutable, and can then be modified in
much the same way as record fields.
\index{primitive mutable data/record/object
fields and ref cells}

\hypertarget{ref-cells}{%
\paragraph{Ref cells}\label{ref-cells}}

Variables in OCaml are never mutable---they can refer to mutable data,
but what the variable points to can't be changed. Sometimes, though, you
want to do exactly what you would do with a mutable variable in another
language: define a single, mutable value. In OCaml this is typically
achieved using a \passthrough{\lstinline!ref!}, which is essentially a
container with a single mutable polymorphic field. \index{ref cells}

The definition for the \passthrough{\lstinline!ref!} type is as follows:

\begin{lstlisting}[language=Caml]
# type 'a ref = { mutable contents : 'a }
type 'a ref = { mutable contents : 'a; }
\end{lstlisting}

The standard library defines the following operators for working with
\passthrough{\lstinline!ref!}s.

\begin{description}
\tightlist
\item[\texttt{ref\ expr}]
Constructs a reference cell containing the value defined by the
expression \passthrough{\lstinline!expr!}.
\item[\texttt{!refcell}]
Returns the contents of the reference cell.
\item[\texttt{refcell\ :=\ expr}]
Replaces the contents of the reference cell.
\end{description}

You can see these in action:

\begin{lstlisting}[language=Caml]
# let x = ref 1
val x : int Stdlib.ref = {Base.Ref.contents = 1}
# !x
- : int = 1
# x := !x + 1
- : unit = ()
# !x
- : int = 2
\end{lstlisting}

The preceding are just ordinary OCaml functions, which could be defined
as follows:

\begin{lstlisting}[language=Caml]
# let ref x = { contents = x }
val ref : 'a -> 'a ref = <fun>
# let (!) r = r.contents
val ( ! ) : 'a ref -> 'a = <fun>
# let (:=) r x = r.contents <- x
val ( := ) : 'a ref -> 'a -> unit = <fun>
\end{lstlisting}

\hypertarget{foreign-functions}{%
\subsubsection{Foreign Functions}\label{foreign-functions}}

Another source of imperative operations in OCaml is resources that come
from interfacing with external libraries through OCaml's foreign
function interface (FFI). The FFI opens OCaml up to imperative
constructs that are exported by system calls or other external
libraries. Many of these come built in, like access to the
\passthrough{\lstinline!write!} system call or to the
\passthrough{\lstinline!clock!}, while others come from user libraries,
like LAPACK bindings. OCaml's FFI is discussed in more detail in
\href{foreign-function-interface.html\#foreign-function-interface}{Foreign
Function Interface}.
\index{libraries/interfacing with external}\index{external libraries/interfacing
with}\index{LAPACK bindings}\index{foreign function interface
(FFI)/imperative operations and}\index{primitive mutable data/foreign
functions}

\hypertarget{for-and-while-loops-1}{%
\subsection{for and while Loops}\label{for-and-while-loops-1}}

OCaml provides support for traditional imperative looping constructs, in
particular, \passthrough{\lstinline!for!} and
\passthrough{\lstinline!while!} loops. Neither of these constructs is
strictly necessary, since they can be simulated with recursive
functions. Nonetheless, explicit \passthrough{\lstinline!for!} and
\passthrough{\lstinline!while!} loops are both more concise and more
idiomatic when programming imperatively.
\index{looping constructs}\index{while
loops}\index{for loops}

The \passthrough{\lstinline!for!} loop is the simpler of the two.
Indeed, we've already seen the \passthrough{\lstinline!for!} loop in
action---the \passthrough{\lstinline!iter!} function in
\passthrough{\lstinline!Dictionary!} is built using it. Here's a simple
example of \passthrough{\lstinline!for!}:

\begin{lstlisting}[language=Caml]
# for i = 0 to 3 do printf "i = %d\n" i done
i = 0
i = 1
i = 2
i = 3
- : unit = ()
\end{lstlisting}

As you can see, the upper and lower bounds are inclusive. We can also
use \passthrough{\lstinline!downto!} to iterate in the other direction:

\begin{lstlisting}[language=Caml]
# for i = 3 downto 0 do printf "i = %d\n" i done
i = 3
i = 2
i = 1
i = 0
- : unit = ()
\end{lstlisting}

Note that the loop variable of a \passthrough{\lstinline!for!} loop,
\passthrough{\lstinline!i!} in this case, is immutable in the scope of
the loop and is also local to the loop, i.e., it can't be referenced
outside of the loop.

OCaml also supports \passthrough{\lstinline!while!} loops, which include
a condition and a body. The loop first evaluates the condition, and
then, if it evaluates to true, evaluates the body and starts the loop
again. Here's a simple example of a function for reversing an array in
place:

\begin{lstlisting}[language=Caml]
# let rev_inplace ar =
    let i = ref 0 in
    let j = ref (Array.length ar - 1) in
    (* terminate when the upper and lower indices meet *)
    while !i < !j do
      (* swap the two elements *)
      let tmp = ar.(!i) in
      ar.(!i) <- ar.(!j);
      ar.(!j) <- tmp;
      (* bump the indices *)
      Int.incr i;
      Int.decr j
    done
val rev_inplace : 'a array -> unit = <fun>
# let nums = [|1;2;3;4;5|]
val nums : int array = [|1; 2; 3; 4; 5|]
# rev_inplace nums
- : unit = ()
# nums
- : int array = [|5; 4; 3; 2; 1|]
\end{lstlisting}

In the preceding example, we used \passthrough{\lstinline!incr!} and
\passthrough{\lstinline!decr!}, which are built-in functions for
incrementing and decrementing an \passthrough{\lstinline!int ref!} by
one, respectively.

\hypertarget{example-doubly-linked-lists}{%
\subsection{Example: Doubly Linked
Lists}\label{example-doubly-linked-lists}}

Another common imperative data structure is the doubly linked list.
Doubly linked lists can be traversed in both directions, and elements
can be added and removed from the list in constant time. Core defines a
doubly linked list (the module is called
\passthrough{\lstinline!Doubly\_linked!}), but we'll define our own
linked list library as an illustration.
\index{lists/doubly-linked lists}\index{doubly-linked
lists}\protect\hypertarget{IPdoublink}{}{imperative
programming/doubly-linked lists}

Here's the \passthrough{\lstinline!mli!} of the module we'll build:

\begin{lstlisting}[language=Caml]
(* file: dlist.mli *)
open Base

type 'a t
type 'a element

(** Basic list operations  *)
val create   : unit -> 'a t
val is_empty : 'a t -> bool

(** Navigation using [element]s *)
val first : 'a t -> 'a element option
val next  : 'a element -> 'a element option
val prev  : 'a element -> 'a element option
val value : 'a element -> 'a

(** Whole-data-structure iteration *)
val iter    : 'a t -> f:('a -> unit) -> unit
val find_el : 'a t -> f:('a -> bool) -> 'a element option

(** Mutation *)
val insert_first : 'a t -> 'a -> 'a element
val insert_after : 'a element -> 'a -> 'a element
val remove : 'a t -> 'a element -> unit
\end{lstlisting}

Note that there are two types defined here:
\passthrough{\lstinline!'a t!}, the type of a list; and
\passthrough{\lstinline!'a element!}, the type of an element. Elements
act as pointers to the interior of a list and allow us to navigate the
list and give us a point at which to apply mutating operations.

Now let's look at the implementation. We'll start by defining
\passthrough{\lstinline!'a element!} and \passthrough{\lstinline!'a t!}:

\begin{lstlisting}[language=Caml]
(* file: dlist.ml *)
open Base

type 'a element =
  { value : 'a;
    mutable next : 'a element option;
    mutable prev : 'a element option
  }

type 'a t = 'a element option ref
\end{lstlisting}

An \passthrough{\lstinline!'a element!} is a record containing the value
to be stored in that node as well as optional (and mutable) fields
pointing to the previous and next elements. At the beginning of the
list, the \passthrough{\lstinline!prev!} field is
\passthrough{\lstinline!None!}, and at the end of the list, the
\passthrough{\lstinline!next!} field is \passthrough{\lstinline!None!}.

The type of the list itself, \passthrough{\lstinline!'a t!}, is a
mutable reference to an optional \passthrough{\lstinline!element!}. This
reference is \passthrough{\lstinline!None!} if the list is empty, and
\passthrough{\lstinline!Some!} otherwise.

Now we can define a few basic functions that operate on lists and
elements:

\begin{lstlisting}[language=Caml]
let create () = ref None
let is_empty t = !t = None

let value elt = elt.value

let first t = !t
let next elt = elt.next
let prev elt = elt.prev
\end{lstlisting}

These all follow relatively straightforwardly from our type definitions.

\hypertarget{cyclic-data-structures}{%
\subsubsection{Cyclic Data Structures}\label{cyclic-data-structures}}

Doubly linked lists are a cyclic data structure, meaning that it is
possible to follow a nontrivial sequence of pointers that closes in on
itself. In general, building cyclic data structures requires the use of
side effects. This is done by constructing the data elements first, and
then adding cycles using assignment afterward.
\index{let rec}\index{data
structures/cyclic}\index{cyclic data structures}

There is an exception to this, though: you can construct fixed-size
cyclic data structures using \passthrough{\lstinline!let rec!}:

\begin{lstlisting}[language=Caml]
# let rec endless_loop = 1 :: 2 :: 3 :: endless_loop
val endless_loop : int list = [1; 2; 3; <cycle>]
\end{lstlisting}

This approach is quite limited, however. General-purpose cyclic data
structures require mutation.

\hypertarget{modifying-the-list}{%
\subsubsection{Modifying the List}\label{modifying-the-list}}

Now, we'll start considering operations that mutate the list, starting
with \passthrough{\lstinline!insert\_first!}, which inserts an element
at the front of the list: \index{elements/inserting in lists}

\begin{lstlisting}[language=Caml]
let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -> old_first.prev <- Some new_elt
  | None -> ()
  end;
  t := Some new_elt;
  new_elt
\end{lstlisting}

\passthrough{\lstinline!insert\_first!} first defines a new element
\passthrough{\lstinline!new\_elt!}, and then links it into the list,
finally setting the list itself to point to
\passthrough{\lstinline!new\_elt!}. Note that the precedence of a
\passthrough{\lstinline!match!} expression is very low, so to separate
it from the following assignment
(\passthrough{\lstinline!t := Some new\_elt!}), we surround the match
with \passthrough{\lstinline!begin ... end!}. We could have used
parentheses for the same purpose. Without some kind of bracketing, the
final assignment would incorrectly become part of the
\passthrough{\lstinline!None!} case. \index{elements/defining new}

We can use \passthrough{\lstinline!insert\_after!} to insert elements
later in the list. \passthrough{\lstinline!insert\_after!} takes as
arguments both an \passthrough{\lstinline!element!} after which to
insert the new node and a value to insert:

\begin{lstlisting}[language=Caml]
let insert_after elt value =
  let new_elt = { value; prev = Some elt; next = elt.next } in
  begin match elt.next with
  | Some old_next -> old_next.prev <- Some new_elt
  | None -> ()
  end;
  elt.next <- Some new_elt;
  new_elt
\end{lstlisting}

Finally, we need a \passthrough{\lstinline!remove!} function:

\begin{lstlisting}[language=Caml]
let remove t elt =
  let { prev; next; _ } = elt in
  begin match prev with
  | Some prev -> prev.next <- next
  | None -> t := next
  end;
  begin match next with
  | Some next -> next.prev <- prev;
  | None -> ()
  end;
  elt.prev <- None;
  elt.next <- None
\end{lstlisting}

Note that the preceding code is careful to change the
\passthrough{\lstinline!prev!} pointer of the following element and the
\passthrough{\lstinline!next!} pointer of the previous element, if they
exist. If there's no previous element, then the list pointer itself is
updated. In any case, the next and previous pointers of the element
itself are set to \passthrough{\lstinline!None!}.

These functions are more fragile than they may seem. In particular,
misuse of the interface may lead to corrupted data. For example,
double-removing an element will cause the main list reference to be set
to \passthrough{\lstinline!None!}, thus emptying the list. Similar
problems arise from removing an element from a list it doesn't belong
to.

This shouldn't be a big surprise. Complex imperative data structures can
be quite tricky, considerably trickier than their pure equivalents. The
issues described previously can be dealt with by more careful error
detection, and such error correction is taken care of in modules like
Core's \passthrough{\lstinline!Doubly\_linked!}. You should use
imperative data structures from a well-designed library when you can.
And when you can't, you should make sure to put great care into your
error handling. \index{imperative programming/drawbacks
of}\index{Doubly-linked module}\index{error handling/and imperative data
structures}

\hypertarget{iteration-functions}{%
\subsubsection{Iteration Functions}\label{iteration-functions}}

When defining containers like lists, dictionaries, and trees, you'll
typically want to define a set of iteration functions like
\passthrough{\lstinline!iter!}, \passthrough{\lstinline!map!}, and
\passthrough{\lstinline!fold!}, which let you concisely express common
iteration patterns.
\index{functions/iteration functions}\index{iteration functions}

\passthrough{\lstinline!Dlist!} has two such iterators:
\passthrough{\lstinline!iter!}, the goal of which is to call a
\passthrough{\lstinline!unit!}-producing function on every element of
the list, in order; and \passthrough{\lstinline!find\_el!}, which runs a
provided test function on each value stored in the list, returning the
first \passthrough{\lstinline!element!} that passes the test. Both
\passthrough{\lstinline!iter!} and \passthrough{\lstinline!find\_el!}
are implemented using simple recursive loops that use
\passthrough{\lstinline!next!} to walk from element to element and
\passthrough{\lstinline!value!} to extract the element from a given
node:

\begin{lstlisting}[language=Caml]
let iter t ~f =
  let rec loop = function
    | None -> ()
    | Some el -> f (value el); loop (next el)
  in
  loop !t

let find_el t ~f =
  let rec loop = function
    | None -> None
    | Some elt ->
      if f (value elt) then Some elt
      else loop (next elt)
  in
  loop !t
\end{lstlisting}

This completes our implementation, but there's still considerably more
work to be done to make a really usable doubly linked list. As mentioned
earlier, you're probably better off using something like Core's
\passthrough{\lstinline!Doubly\_linked!} module that has a more complete
interface and has more of the tricky corner cases worked out.
Nonetheless, this example should serve to demonstrate some of the
techniques you can use to build nontrivial imperative data structure in
OCaml, as well as some of the pitfalls.~

\hypertarget{laziness-and-other-benign-effects}{%
\subsection{Laziness and Other Benign
Effects}\label{laziness-and-other-benign-effects}}

There are many instances where you basically want to program in a pure
style, but you want to make limited use of side effects to improve the
performance of your code. Such side effects are sometimes called
\emph{benign effects}, and they are a useful way of leveraging OCaml's
imperative features while still maintaining most of the benefits of pure
programming. \index{lazy
keyword}\index{side effects}\index{laziness}\index{benign
effects/laziness}\index{imperative programming/benign effects and}

One of the simplest benign effects is \emph{laziness}. A lazy value is
one that is not computed until it is actually needed. In OCaml, lazy
values are created using the \passthrough{\lstinline!lazy!} keyword,
which can be used to convert any expression of type
\passthrough{\lstinline!s!} into a lazy value of type
\passthrough{\lstinline!s Lazy.t!}. The evaluation of that expression is
delayed until forced with \passthrough{\lstinline!Lazy.force!}:

\begin{lstlisting}[language=Caml]
# let v = lazy (print_endline "performing lazy computation"; Float.sqrt 16.)
val v : float lazy_t = <lazy>
# Lazy.force v
performing lazy computation
- : float = 4.
# Lazy.force v
- : float = 4.
\end{lstlisting}

You can see from the \passthrough{\lstinline!print!} statement that the
actual computation was performed only once, and only after
\passthrough{\lstinline!force!} had been called.

To better understand how laziness works, let's walk through the
implementation of our own lazy type. We'll start by declaring types to
represent a lazy value:

\begin{lstlisting}[language=Caml]
# type 'a lazy_state =
    | Delayed of (unit -> 'a)
    | Value of 'a
    | Exn of exn
type 'a lazy_state = Delayed of (unit -> 'a) | Value of 'a | Exn of exn
\end{lstlisting}

A \passthrough{\lstinline!lazy\_state!} represents the possible states
of a lazy value. A lazy value is \passthrough{\lstinline!Delayed!}
before it has been run, where \passthrough{\lstinline!Delayed!} holds a
function for computing the value in question. A lazy value is in the
\passthrough{\lstinline!Value!} state when it has been forced and the
computation ended normally. The \passthrough{\lstinline!Exn!} case is
for when the lazy value has been forced, but the computation ended with
an exception. A lazy value is simply a \passthrough{\lstinline!ref!}
containing a \passthrough{\lstinline!lazy\_state!}, where the
\passthrough{\lstinline!ref!} makes it possible to change from being in
the \passthrough{\lstinline!Delayed!} state to being in the
\passthrough{\lstinline!Value!} or \passthrough{\lstinline!Exn!} states.

We can create a lazy value from a thunk, i.e., a function that takes a
unit argument. Wrapping an expression in a thunk is another way to
suspend the computation of an expression: \index{thunks}

\begin{lstlisting}[language=Caml]
# let create_lazy f = ref (Delayed f)
val create_lazy : (unit -> 'a) -> 'a lazy_state ref = <fun>
# let v =
    create_lazy (fun () ->
  print_endline "performing lazy computation"; Float.sqrt 16.)
val v : float lazy_state ref = {Base.Ref.contents = Delayed <fun>}
\end{lstlisting}

Now we just need a way to force a lazy value. The following function
does just that:

\begin{lstlisting}[language=Caml]
# let force v =
    match !v with
    | Value x -> x
    | Exn e -> raise e
    | Delayed f ->
      try
        let x = f () in
        v := Value x;
        x
      with exn ->
        v := Exn exn;
        raise exn
val force : 'a lazy_state ref -> 'a = <fun>
\end{lstlisting}

Which we can use in the same way we used
\passthrough{\lstinline!Lazy.force!}:

\begin{lstlisting}[language=Caml]
# force v
performing lazy computation
- : float = 4.
# force v
- : float = 4.
\end{lstlisting}

The main user-visible difference between our implementation of laziness
and the built-in version is syntax. Rather than writing
\passthrough{\lstinline!create\_lazy (fun () -> sqrt 16.)!}, we can
(with the built-in \passthrough{\lstinline!lazy!}) just write
\passthrough{\lstinline!lazy (sqrt 16.)!}.

\hypertarget{memoization-and-dynamic-programming}{%
\subsubsection{Memoization and Dynamic
Programming}\label{memoization-and-dynamic-programming}}

Another benign effect is \emph{memoization}. A memoized function
remembers the result of previous invocations of the function so that
they can be returned without further computation when the same arguments
are presented again.
\index{memoization/of function}\protect\hypertarget{BEmem}{}{benign
effects/memoization}

Here's a function that takes as an argument an arbitrary single-argument
function and returns a memoized version of that function. Here we'll use
Core's \passthrough{\lstinline!Hashtbl!} module, rather than our toy
\passthrough{\lstinline!Dictionary!}:

\begin{lstlisting}[language=Caml]
# let memoize f =
    let memo_table = Hashtbl.Poly.create () in
    (fun x ->
       Hashtbl.find_or_add memo_table x ~default:(fun () -> f x))
val memoize : ('a -> 'b) -> 'a -> 'b = <fun>
\end{lstlisting}

The preceding code is a bit tricky. \passthrough{\lstinline!memoize!}
takes as its argument a function \passthrough{\lstinline!f!} and then
allocates a polymorphic hash table (called
\passthrough{\lstinline!memo\_table!}), and returns a new function which
is the memoized version of \passthrough{\lstinline!f!}. When called,
this new function uses \passthrough{\lstinline!Hashtbl.find\_or\_add!}
to try to find a value in the \passthrough{\lstinline!memo\_table!}, and
if it fails, to call \passthrough{\lstinline!f!} and store the result.
Note that \passthrough{\lstinline!memo\_table!} is referred to by the
function, and so won't be collected until the function returned by
\passthrough{\lstinline!memoize!} is itself collected.
\index{memoization/benefits and drawbacks of}

Memoization can be useful whenever you have a function that is expensive
to recompute and you don't mind caching old values indefinitely. One
important caution: a memoized function by its nature leaks memory. As
long as you hold on to the memoized function, you're holding every
result it has returned thus far.

Memoization is also useful for efficiently implementing some recursive
algorithms. One good example is the algorithm for computing the
\emph{edit distance} (also called the Levenshtein distance) between two
strings. The edit distance is the number of single-character changes
(including letter switches, insertions, and deletions) required to
{convert} one string to the other. This kind of distance metric can be
useful for a variety of approximate string-matching problems, like
spellcheckers. \index{string matching}\index{Levenshtein
distance}\index{edit distance}

Consider the following code for computing the edit distance.
Understanding the algorithm isn't important here, but you should pay
attention to the structure of the recursive calls:
\index{memoization/example of}

\begin{lstlisting}[language=Caml]
# let rec edit_distance s t =
    match String.length s, String.length t with
    | (0,x) | (x,0) -> x
    | (len_s,len_t) ->
      let s' = String.drop_suffix s 1 in
      let t' = String.drop_suffix t 1 in
      let cost_to_drop_both =
        if Char.(=) s.[len_s - 1] t.[len_t - 1] then 0 else 1
      in
      List.reduce_exn ~f:Int.min
        [ edit_distance s' t  + 1
        ; edit_distance s  t' + 1
        ; edit_distance s' t' + cost_to_drop_both
        ]
val edit_distance : string -> string -> int = <fun>
# edit_distance "OCaml" "ocaml"
- : int = 2
\end{lstlisting}

The thing to note is that if you call
\passthrough{\lstinline!edit\_distance "OCaml" "ocaml"!}, then that will
in turn dispatch the following calls:

And these calls will in turn dispatch other calls:

As you can see, some of these calls are repeats. For example, there are
two different calls to
\passthrough{\lstinline!edit\_distance "OCam" "oca"!}. The number of
redundant calls grows exponentially with the size of the strings,
meaning that our implementation of
\passthrough{\lstinline!edit\_distance!} is brutally slow for large
strings. We can see this by writing a small timing function, using the
\passthrough{\lstinline!Mtime!} package.

\begin{lstlisting}[language=Caml]
# let time f =
    let open Core in
    let start = Time.now () in
    let x = f () in
    let stop = Time.now () in
    printf "Time: %F ms\n" (Time.diff stop start |> Time.Span.to_ms);
    x
val time : (unit -> 'a) -> 'a = <fun>
\end{lstlisting}

And now we can use this to try out some examples:

\begin{lstlisting}[language=Caml]
# time (fun () -> edit_distance "OCaml" "ocaml")
Time: 1.10292434692 ms
- : int = 2
# time (fun () -> edit_distance "OCaml 4.01" "ocaml 4.01")
Time: 3282.86218643 ms
- : int = 2
\end{lstlisting}

Just those few extra characters made it thousands of times slower!

Memoization would be a huge help here, but to fix the problem, we need
to memoize the calls that \passthrough{\lstinline!edit\_distance!} makes
to itself. Such recursive memoization is closely related to a common
algorithmic technique called \emph{dynamic programming}, except that
with dynamic programming, you do the necessary sub-computations
bottom-up, in anticipation of needing them. With recursive memoization,
you go top-down, only doing a sub-computation when you discover that you
need it. \index{memoization/recursive}\index{dynamic
programming}

To see how to do this, let's step away from
\passthrough{\lstinline!edit\_distance!} and instead consider a much
simpler example: computing the \emph{n}th element of the Fibonacci
sequence. The Fibonacci sequence by definition starts out with two
\passthrough{\lstinline!1!}s, with every subsequent element being the
sum of the previous two. The classic recursive definition of Fibonacci
is as follows:

\begin{lstlisting}[language=Caml]
# let rec fib i =
  if i <= 1 then i else fib (i - 1) + fib (i - 2)
val fib : int -> int = <fun>
\end{lstlisting}

This is, however, exponentially slow, for the same reason that
\passthrough{\lstinline!edit\_distance!} was slow: we end up making many
redundant calls to \passthrough{\lstinline!fib!}. It shows up quite
dramatically in the performance:

\begin{lstlisting}[language=Caml]
# time (fun () -> fib 20)
Time: 1.12414360046 ms
- : int = 10946
# time (fun () -> fib 40)
Time: 18263.7000084 ms
- : int = 165580141
\end{lstlisting}

As you can see, \passthrough{\lstinline!fib 40!} takes thousands of
times longer to compute than \passthrough{\lstinline!fib 20!}.

So, how can we use memoization to make this faster? The tricky bit is
that we need to insert the memoization before the recursive calls within
\passthrough{\lstinline!fib!}. We can't just define
\passthrough{\lstinline!fib!} in the ordinary way and memoize it after
the fact and expect the first call to \passthrough{\lstinline!fib!} to
be improved.

\begin{lstlisting}[language=Caml]
# let fib = memoize fib
val fib : int -> int = <fun>
# time (fun () -> fib 40)
Time: 18122.092247 ms
- : int = 165580141
# time (fun () -> fib 40)
Time: 0.00596046447754 ms
- : int = 165580141
\end{lstlisting}

In order to make \passthrough{\lstinline!fib!} fast, our first step will
be to rewrite \passthrough{\lstinline!fib!} in a way that unwinds the
recursion. The following version expects as its first argument a
function (called \passthrough{\lstinline!fib!}) that will be called in
lieu of the usual recursive call.

\begin{lstlisting}[language=Caml]
# let fib_norec fib i =
    if i <= 1 then i
    else fib (i - 1) + fib (i - 2)
val fib_norec : (int -> int) -> int -> int = <fun>
\end{lstlisting}

We can now turn this back into an ordinary Fibonacci function by tying
the recursive knot:

\begin{lstlisting}[language=Caml]
# let rec fib i = fib_norec fib i
val fib : int -> int = <fun>
# fib 20
- : int = 6765
\end{lstlisting}

We can even write a polymorphic function that we'll call
\passthrough{\lstinline!make\_rec!} that can tie the recursive knot for
any function of this form:

\begin{lstlisting}[language=Caml]
# let make_rec f_norec =
    let rec f x = f_norec f x in
    f
val make_rec : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
# let fib = make_rec fib_norec
val fib : int -> int = <fun>
# fib 20
- : int = 6765
\end{lstlisting}

This is a pretty strange piece of code, and it may take a few moments of
thought to figure out what's going on. Like
\passthrough{\lstinline!fib\_norec!}, the function
\passthrough{\lstinline!f\_norec!} passed into
\passthrough{\lstinline!make\_rec!} is a function that isn't recursive
but takes as an argument a function that it will call. What
\passthrough{\lstinline!make\_rec!} does is to essentially feed
\passthrough{\lstinline!f\_norec!} to itself, thus making it a true
recursive function.

This is clever enough, but all we've really done is find a new way to
implement the same old slow Fibonacci function. To make it faster, we
need a variant of \passthrough{\lstinline!make\_rec!} that inserts
memoization when it ties the recursive knot. We'll call that function
\passthrough{\lstinline!memo\_rec!}:

\begin{lstlisting}[language=Caml]
# let memo_rec f_norec x =
    let fref = ref (fun _ -> assert false) in
    let f = memoize (fun x -> f_norec !fref x) in
    fref := f;
    f x
val memo_rec : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
\end{lstlisting}

Note that \passthrough{\lstinline!memo\_rec!} has the same signature as
\passthrough{\lstinline!make\_rec!}.

We're using the reference here as a way of tying the recursive knot
without using a \passthrough{\lstinline!let rec!}, which for reasons
we'll describe later wouldn't work here.

Using \passthrough{\lstinline!memo\_rec!}, we can now build an efficient
version of \passthrough{\lstinline!fib!}:

\begin{lstlisting}[language=Caml]
# let fib = memo_rec fib_norec
val fib : int -> int = <fun>
# time (fun () -> fib 40)
Time: 0.0388622283936 ms
- : int = 102334155
\end{lstlisting}

And as you can see, the exponential time complexity is now gone.

The memory behavior here is important. If you look back at the
definition of \passthrough{\lstinline!memo\_rec!}, you'll see that the
call \passthrough{\lstinline!memo\_rec fib\_norec!} does not trigger a
call to \passthrough{\lstinline!memoize!}. Only when
\passthrough{\lstinline!fib!} is called and thereby the final argument
to \passthrough{\lstinline!memo\_rec!} is presented does
\passthrough{\lstinline!memoize!} get called. The result of that call
falls out of scope when the \passthrough{\lstinline!fib!} call returns,
and so calling \passthrough{\lstinline!memo\_rec!} on a function does
not create a memory leak---the memoization table is collected after the
computation completes.

We can use \passthrough{\lstinline!memo\_rec!} as part of a single
declaration that makes this look like it's little more than a special
form of \passthrough{\lstinline!let rec!}:

\begin{lstlisting}[language=Caml]
# let fib = memo_rec (fun fib i ->
  if i <= 1 then 1 else fib (i - 1) + fib (i - 2))
val fib : int -> int = <fun>
\end{lstlisting}

Memoization is overkill for implementing Fibonacci, and indeed, the
\passthrough{\lstinline!fib!} defined above is not especially efficient,
allocating space linear in the number passed in to
\passthrough{\lstinline!fib!}. It's easy enough to write a Fibonacci
function that takes a constant amount of space.

But memoization is a good approach for optimizing
\passthrough{\lstinline!edit\_distance!}, and we can apply the same
approach we used on \passthrough{\lstinline!fib!} here. We will need to
change \passthrough{\lstinline!edit\_distance!} to take a pair of
strings as a single argument, since \passthrough{\lstinline!memo\_rec!}
only works on single-argument functions. (We can always recover the
original interface with a wrapper function.) With just that change and
the addition of the \passthrough{\lstinline!memo\_rec!} call, we can get
a memoized version of \passthrough{\lstinline!edit\_distance!}:

\begin{lstlisting}[language=Caml]
# let edit_distance = memo_rec (fun edit_distance (s,t) ->
    match String.length s, String.length t with
    | (0,x) | (x,0) -> x
    | (len_s,len_t) ->
      let s' = String.drop_suffix s 1 in
      let t' = String.drop_suffix t 1 in
      let cost_to_drop_both =
        if Char.(=) s.[len_s - 1] t.[len_t - 1] then 0 else 1
      in
      List.reduce_exn ~f:Int.min
        [ edit_distance (s',t ) + 1
        ; edit_distance (s ,t') + 1
        ; edit_distance (s',t') + cost_to_drop_both
  ])
val edit_distance : string * string -> int = <fun>
\end{lstlisting}

This new version of \passthrough{\lstinline!edit\_distance!} is much
more efficient than the one we started with; the following call is many
thousands of times faster than it was without memoization:

\begin{lstlisting}[language=Caml]
# time (fun () -> edit_distance ("OCaml 4.01","ocaml 4.01"))
Time: 0.348091125488 ms
- : int = 2
\end{lstlisting}

\hypertarget{limitations-of-let-rec}{%
\paragraph{Limitations of let rec}\label{limitations-of-let-rec}}

You might wonder why we didn't tie the recursive knot in
\passthrough{\lstinline!memo\_rec!} using
\passthrough{\lstinline!let rec!}, as we did for
\passthrough{\lstinline!make\_rec!} earlier. Here's code that tries to
do just that: \index{let rec}

\begin{lstlisting}[language=Caml]
# let memo_rec f_norec =
    let rec f = memoize (fun x -> f_norec f x) in
    f
Line 2, characters 17-47:
Error: This kind of expression is not allowed as right-hand side of `let rec'
\end{lstlisting}

OCaml rejects the definition because OCaml, as a strict language, has
limits on what it can put on the righthand side of a
\passthrough{\lstinline!let rec!}. In particular, imagine how the
following code snippet would be compiled:

\begin{lstlisting}[language=Caml]
let rec x = x + 1
\end{lstlisting}

Note that \passthrough{\lstinline!x!} is an ordinary value, not a
function. As such, it's not clear how this definition should be handled
by the compiler. You could imagine it compiling down to an infinite
loop, but \passthrough{\lstinline!x!} is of type
\passthrough{\lstinline!int!}, and there's no
\passthrough{\lstinline!int!} that corresponds to an infinite loop. As
such, this construct is effectively impossible to compile.

To avoid such impossible cases, the compiler only allows three possible
constructs to show up on the righthand side of a
\passthrough{\lstinline!let rec!}: a function definition, a constructor,
or the lazy keyword. This excludes some reasonable things, like our
definition of \passthrough{\lstinline!memo\_rec!}, but it also blocks
things that don't make sense, like our definition of
\passthrough{\lstinline!x!}.

It's worth noting that these restrictions don't show up in a lazy
language like Haskell. Indeed, we can make something like our definition
of \passthrough{\lstinline!x!} work if we use OCaml's laziness:

\begin{lstlisting}[language=Caml]
# let rec x = lazy (force x + 1)
val x : int lazy_t = <lazy>
\end{lstlisting}

Of course, actually trying to compute this will fail. OCaml's
\passthrough{\lstinline!lazy!} throws an exception when a lazy value
tries to force itself as part of its own evaluation.

\begin{lstlisting}[language=Caml]
# force x
Exception: Lazy.Undefined
\end{lstlisting}

But we can also create useful recursive definitions with
\passthrough{\lstinline!lazy!}. In particular, we can use laziness to
make our definition of \passthrough{\lstinline!memo\_rec!} work without
explicit mutation:

\begin{lstlisting}[language=Caml]
# let lazy_memo_rec f_norec x =
    let rec f = lazy (memoize (fun x -> f_norec (force f) x)) in
    (force f) x
val lazy_memo_rec : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
# time (fun () -> lazy_memo_rec fib_norec 40)
Time: 0.0441074371338 ms
- : int = 102334155
\end{lstlisting}

Laziness is more constrained than explicit mutation, and so in some
cases can lead to code whose behavior is easier to think about. ~

\hypertarget{input-and-output}{%
\subsection{Input and Output}\label{input-and-output}}

Imperative programming is about more than modifying in-memory data
structures. Any function that doesn't boil down to a deterministic
transformation from its arguments to its return value is imperative in
nature. That includes not only things that mutate your program's data,
but also operations that interact with the world outside of your
program. An important example of this kind of interaction is I/O, i.e.,
operations for reading or writing data to things like files, terminal
input and output, and network sockets.
\index{I/O (input/output) operations/terminal
I/O}\protect\hypertarget{IPinpout}{}{imperative programming/input and
output}

There are multiple I/O libraries in OCaml. In this section we'll discuss
OCaml's buffered I/O library that can be used through the
\passthrough{\lstinline!In\_channel!} and
\passthrough{\lstinline!Out\_channel!} modules in Core. Other I/O
primitives are also available through the \passthrough{\lstinline!Unix!}
module in Core as well as \passthrough{\lstinline!Async!}, the
asynchronous I/O library that is covered in
\href{concurrent-programming.html\#concurrent-programming-with-async}{Concurrent
Programming With Async}. Most of the functionality in Core's
\passthrough{\lstinline!In\_channel!} and
\passthrough{\lstinline!Out\_channel!} (and in Core's
\passthrough{\lstinline!Unix!} module) derives from the standard
library, but we'll use Core's interfaces here.

\hypertarget{terminal-io}{%
\subsubsection{Terminal I/O}\label{terminal-io}}

OCaml's buffered I/O library is organized around two types:
\passthrough{\lstinline!in\_channel!}, for channels you read from, and
\passthrough{\lstinline!out\_channel!}, for channels you write to. The
\passthrough{\lstinline!In\_channel!} and
\passthrough{\lstinline!Out\_channel!} modules only have direct support
for channels corresponding to files and terminals; other kinds of
channels can be created through the \passthrough{\lstinline!Unix!}
module. \index{Out\_channel
module/Out\_channel.stderr}\index{Out\_channel
module/Out\_channel.stdout}\index{In\_channel module}

We'll start our discussion of I/O by focusing on the terminal. Following
the UNIX model, communication with the terminal is organized around
three channels, which correspond to the three standard file descriptors
in Unix:

\begin{description}
\tightlist
\item[\texttt{In\_channel.stdin}]
The ``standard input'' channel. By default, input comes from the
terminal, which handles keyboard input.
\item[\texttt{Out\_channel.stdout}]
The ``standard output'' channel. By default, output written to
\passthrough{\lstinline!stdout!} appears on the user terminal.
\item[\texttt{Out\_channel.stderr}]
The ``standard error'' channel. This is similar to
\passthrough{\lstinline!stdout!} but is intended for error messages.
\end{description}

The values \passthrough{\lstinline!stdin!},
\passthrough{\lstinline!stdout!}, and \passthrough{\lstinline!stderr!}
are useful enough that they are also available in the global namespace
directly, without having to go through the
\passthrough{\lstinline!In\_channel!} and
\passthrough{\lstinline!Out\_channel!} modules.

Let's see this in action in a simple interactive application. The
following program, \passthrough{\lstinline!time\_converter!}, prompts
the user for a time zone, and then prints out the current time in that
time zone. Here, we use Core's \passthrough{\lstinline!Zone!} module for
looking up a time zone, and the \passthrough{\lstinline!Time!} module
for computing the current time and printing it out in the time zone in
question:

\begin{lstlisting}[language=Caml]
open Core

let () =
  Out_channel.output_string stdout "Pick a timezone: ";
  Out_channel.flush stdout;
  match In_channel.input_line stdin with
  | None -> failwith "No timezone provided"
  | Some zone_string ->
    let zone = Time.Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    Out_channel.output_string stdout
      (String.concat
         ["The time in ";Time.Zone.to_string zone;" is ";time_string;".\n"]);
    Out_channel.flush stdout
\end{lstlisting}

We can build this program using \passthrough{\lstinline!dune!} and run
it. You'll see that it prompts you for input, as follows:

\begin{lstlisting}
$ dune build time_converter.bc
$ ./_build/default/time_converter.bc
Pick a timezone:
\end{lstlisting}

You can then type in the name of a time zone and hit Return, and it will
print out the current time in the time zone in question:

\begin{lstlisting}
Pick a timezone: Europe/London
The time in Europe/London is 2013-08-15 00:03:10.666220+01:00.
\end{lstlisting}

We called \passthrough{\lstinline!Out\_channel.flush!} on
\passthrough{\lstinline!stdout!} because
\passthrough{\lstinline!out\_channel!}s are buffered, which is to say
that OCaml doesn't immediately do a write every time you call
\passthrough{\lstinline!output\_string!}. Instead, writes are buffered
until either enough has been written to trigger the flushing of the
buffers, or until a flush is explicitly requested. This greatly
increases the efficiency of the writing process by reducing the number
of system calls.

Note that \passthrough{\lstinline!In\_channel.input\_line!} returns a
\passthrough{\lstinline!string option!}, with
\passthrough{\lstinline!None!} indicating that the input stream has
ended (i.e., an end-of-file condition).
\passthrough{\lstinline!Out\_channel.output\_string!} is used to print
the final output, and \passthrough{\lstinline!Out\_channel.flush!} is
called to flush that output to the screen. The final flush is not
technically required, since the program ends after that instruction, at
which point all remaining output will be flushed anyway, but the
explicit flush is nonetheless good practice.

\hypertarget{formatted-output-with-printf}{%
\subsubsection{Formatted Output with
printf}\label{formatted-output-with-printf}}

Generating output with functions like
\passthrough{\lstinline!Out\_channel.output\_string!} is simple and easy
to understand, but can be a bit verbose. OCaml also supports formatted
output using the \passthrough{\lstinline!printf!} function, which is
modeled after \passthrough{\lstinline!printf!} in the C standard
library. \passthrough{\lstinline!printf!} takes a \emph{format string}
that describes what to print and how to format it, as well as arguments
to be printed, as determined by the formatting directives embedded in
the format string. So, for example, we can write:
\index{strings/format strings}\index{format
strings}\index{printf function}\index{I/O (input/output) operations/formatted
output}

\begin{lstlisting}[language=Caml]
# printf
    "%i is an integer, %F is a float, \"%s\" is a string\n"
  3 4.5 "five"
3 is an integer, 4.5 is a float, "five" is a string
- : unit = ()
\end{lstlisting}

Unlike C's \passthrough{\lstinline!printf!}, the
\passthrough{\lstinline!printf!} in OCaml is type-safe. In particular,
if we provide an argument whose type doesn't match what's presented in
the format string, we'll get a type error:

\begin{lstlisting}[language=Caml]
# printf "An integer: %i\n" 4.5
Line 1, characters 27-30:
Error: This expression has type float but an expression was expected of type
         int
\end{lstlisting}

\hypertarget{understanding-format-strings}{%
\subparagraph{Understanding Format
Strings}\label{understanding-format-strings}}

The format strings used by \passthrough{\lstinline!printf!} turn out to
be quite different from ordinary strings. This difference ties to the
fact that OCaml format strings, unlike their equivalent in C, are
type-safe. In particular, the compiler checks that the types referred to
by the format string match the types of the rest of the arguments passed
to \passthrough{\lstinline!printf!}.

To check this, OCaml needs to analyze the contents of the format string
at compile time, which means the format string needs to be available as
a string literal at compile time. Indeed, if you try to pass an ordinary
string to \passthrough{\lstinline!printf!}, the compiler will complain:

\begin{lstlisting}[language=Caml]
# let fmt = "%i is an integer\n"
val fmt : string = "%i is an integer\n"
# printf fmt 3
Line 1, characters 8-11:
Error: This expression has type string but an expression was expected of type
         ('a -> 'b, out_channel, unit) format =
           ('a -> 'b, out_channel, unit, unit, unit, unit) format6
\end{lstlisting}

If OCaml infers that a given string literal is a format string, then it
parses it at compile time as such, choosing its type in accordance with
the formatting directives it finds. Thus, if we add a type annotation
indicating that the string we're defining is actually a format string,
it will be interpreted as such. (Here, we open the
CamlinternalFormatBasics so that the representation of the format string
that's printed out won't fill the whole page.)

\begin{lstlisting}[language=Caml]
# open CamlinternalFormatBasics
# let fmt : ('a, 'b, 'c) format =
  "%i is an integer\n"
val fmt : (int -> 'c, 'b, 'c) format =
  Format
   (Int (Int_i, No_padding, No_precision,
     String_literal (" is an integer\n", End_of_format)),
   "%i is an integer\n")
\end{lstlisting}

And accordingly, we can pass it to \passthrough{\lstinline!printf!}:

\begin{lstlisting}[language=Caml]
# printf fmt 3
3 is an integer
- : unit = ()
\end{lstlisting}

If this looks different from everything else you've seen so far, that's
because it is. This is really a special case in the type system. Most of
the time, you don't need to know about this special handling of format
strings---you can just use \passthrough{\lstinline!printf!} and not
worry about the details. But it's useful to keep the broad outlines of
the story in the back of your head.

Now let's see how we can rewrite our time conversion program to be a
little more concise using \passthrough{\lstinline!printf!}:

\begin{lstlisting}[language=Caml]
open Core

let () =
  printf "Pick a timezone: %!";
  match In_channel.input_line In_channel.stdin with
  | None -> failwith "No timezone provided"
  | Some zone_string ->
    let zone = Time.Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    printf "The time in %s is %s.\n%!" (Time.Zone.to_string zone) time_string
\end{lstlisting}

In the preceding example, we've used only two formatting directives:
\passthrough{\lstinline!\%s!}, for including a string, and
\passthrough{\lstinline"\%!"} which causes
\passthrough{\lstinline!printf!} to flush the channel.

\passthrough{\lstinline!printf!}'s formatting directives offer a
significant amount of control, allowing you to specify things like:
\index{binary numbers, formatting with
printf}\index{hex numbers, formatting with printf}\index{decimals, formatting
with printf}\index{alignment, formatting with printf}

\begin{itemize}
\item
  Alignment and padding
\item
  Escaping rules for strings
\item
  Whether numbers should be formatted in decimal, hex, or binary
\item
  Precision of float conversions
\end{itemize}

There are also \passthrough{\lstinline!printf!}-style functions that
target outputs other than \passthrough{\lstinline!stdout!}, including:
\index{sprintf function}\index{fprintf function}\index{eprintf
function}

\begin{itemize}
\item
  \passthrough{\lstinline!eprintf!}, which prints to
  \passthrough{\lstinline!stderr!}
\item
  \passthrough{\lstinline!fprintf!}, which prints to an arbitrary
  \passthrough{\lstinline!out\_channel!}
\item
  \passthrough{\lstinline!sprintf!}, which returns a formatted string
\end{itemize}

All of this, and a good deal more, is described in the API documentation
for the \passthrough{\lstinline!Printf!} module in the OCaml Manual.

\hypertarget{file-io}{%
\subsubsection{File I/O}\label{file-io}}

Another common use of \passthrough{\lstinline!in\_channel!}s and
\passthrough{\lstinline!out\_channel!}s is for working with files. Here
are a couple of functions---one that creates a file full of numbers, and
the other that reads in such a file and returns the sum of those
numbers:
\index{files/file I/O}\index{I/O (input/output) operations/file I/O}

\begin{lstlisting}[language=Caml]
# let create_number_file filename numbers =
    let outc = Out_channel.create filename in
    List.iter numbers ~f:(fun x -> Out_channel.fprintf outc "%d\n" x);
    Out_channel.close outc
val create_number_file : string -> int list -> unit = <fun>
# let sum_file filename =
    let file = In_channel.create filename in
    let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
    let sum = List.fold ~init:0 ~f:(+) numbers in
    In_channel.close file;
    sum
val sum_file : string -> int = <fun>
# create_number_file "numbers.txt" [1;2;3;4;5]
- : unit = ()
# sum_file "numbers.txt"
- : int = 15
\end{lstlisting}

For both of these functions, we followed the same basic sequence: we
first create the channel, then use the channel, and finally close the
channel. The closing of the channel is important, since without it, we
won't release resources associated with the file back to the operating
system.

One problem with the preceding code is that if it throws an exception in
the middle of its work, it won't actually close the file. If we try to
read a file that doesn't actually contain numbers, we'll see such an
error:

\begin{lstlisting}[language=Caml]
# sum_file "/etc/hosts"
Exception:
(Failure
 "Int.of_string: \"127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\"").
\end{lstlisting}

And if we do this over and over in a loop, we'll eventually run out of
file descriptors:

\begin{lstlisting}[language=Caml]
# for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -> () done
- : unit = ()
# sum_file "numbers.txt"
Error: I/O error: ...: Too many open files
\end{lstlisting}

And now, you'll need to restart your toplevel if you want to open any
more files!

To avoid this, we need to make sure that our code cleans up after
itself. We can do this using the \passthrough{\lstinline!protect!}
function described in \href{error-handling.html\#error-handling}{Error
Handling}, as follows:

\begin{lstlisting}[language=Caml]
# let sum_file filename =
    let file = In_channel.create filename in
    Exn.protect ~f:(fun () ->
      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
      List.fold ~init:0 ~f:(+) numbers)
      ~finally:(fun () -> In_channel.close file)
val sum_file : string -> int = <fun>
\end{lstlisting}

And now, the file descriptor leak is gone:

\begin{lstlisting}[language=Caml]
# for i = 1 to 10000 do try ignore (sum_file "/etc/hosts" : int) with _ -> () done
- : unit = ()
# sum_file "numbers.txt"
- : int = 15
\end{lstlisting}

This is really an example of a more general issue with imperative
programming and exceptions. If you're changing the internal state of
your program and you're interrupted by an exception, you need to
consider quite carefully if it's safe to continue working from your
current state.

\passthrough{\lstinline!In\_channel!} has functions that automate the
handling of some of these details. For example,
\passthrough{\lstinline!In\_channel.with\_file!} takes a filename and a
function for processing data from an
\passthrough{\lstinline!in\_channel!} and takes care of the bookkeeping
associated with opening and closing the file. We can rewrite
\passthrough{\lstinline!sum\_file!} using this function, as shown here:

\begin{lstlisting}[language=Caml]
# let sum_file filename =
    In_channel.with_file filename ~f:(fun file ->
      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in
      List.fold ~init:0 ~f:(+) numbers)
val sum_file : string -> int = <fun>
\end{lstlisting}

Another misfeature of our implementation of
\passthrough{\lstinline!sum\_file!} is that we read the entire file into
memory before processing it. For a large file, it's more efficient to
process a line at a time. You can use the
\passthrough{\lstinline!In\_channel.fold\_lines!} function to do just
that:

\begin{lstlisting}[language=Caml]
# let sum_file filename =
    In_channel.with_file filename ~f:(fun file ->
      In_channel.fold_lines file ~init:0 ~f:(fun sum line ->
        sum + Int.of_string line))
val sum_file : string -> int = <fun>
\end{lstlisting}

This is just a taste of the functionality of
\passthrough{\lstinline!In\_channel!} and
\passthrough{\lstinline!Out\_channel!}. To get a fuller understanding,
you should review the API documentation for those modules.~

\hypertarget{order-of-evaluation}{%
\subsection{Order of Evaluation}\label{order-of-evaluation}}

The order in which expressions are evaluated is an important part of the
definition of a programming language, and it is particularly important
when programming imperatively. Most programming languages you're likely
to have encountered are \emph{strict}, and OCaml is too. In a strict
language, when you bind an identifier to the result of some expression,
the expression is evaluated before the variable is bound. Similarly, if
you call a function on a set of arguments, those arguments are evaluated
before they are passed to the function.
\index{strict evaluation}\index{expressions, order of
evaluation}\index{evaluation, order of}\index{order of
evaluation}\index{imperative programming/order of evaluation}

Consider the following simple example. Here, we have a collection of
angles, and we want to determine if any of them have a negative
\passthrough{\lstinline!sin!}. The following snippet of code would
answer that question:

\begin{lstlisting}[language=Caml]
# let x = Float.sin 120. in
  let y = Float.sin 75.  in
  let z = Float.sin 128. in
  List.exists ~f:(fun x -> Float.O.(x < 0.)) [x;y;z]
- : bool = true
\end{lstlisting}

In some sense, we don't really need to compute the
\passthrough{\lstinline!sin 128.!} because
\passthrough{\lstinline!sin 75.!} is negative, so we could know the
answer before even computing \passthrough{\lstinline!sin 128.!}.

It doesn't have to be this way. Using the \passthrough{\lstinline!lazy!}
keyword, we can write the original computation so that
\passthrough{\lstinline!sin 128.!} won't ever be computed:

\begin{lstlisting}[language=Caml]
# let x = lazy (Float.sin 120.) in
  let y = lazy (Float.sin 75.)  in
  let z = lazy (Float.sin 128.) in
  List.exists ~f:(fun x -> Float.O.(Lazy.force x < 0.)) [x;y;z]
- : bool = true
\end{lstlisting}

We can confirm that fact by a few well-placed
\passthrough{\lstinline!printf!}s:

\begin{lstlisting}[language=Caml]
# let x = lazy (printf "1\n"; Float.sin 120.) in
  let y = lazy (printf "2\n"; Float.sin 75.)  in
  let z = lazy (printf "3\n"; Float.sin 128.) in
  List.exists ~f:(fun x -> Float.O.(Lazy.force x < 0.)) [x;y;z]
1
2
- : bool = true
\end{lstlisting}

OCaml is strict by default for a good reason: lazy evaluation and
imperative programming generally don't mix well because laziness makes
it harder to reason about when a given side effect is going to occur.
Understanding the order of side effects is essential to reasoning about
the behavior of an imperative program.

Because OCaml is strict, we know that expressions that are bound by a
sequence of \passthrough{\lstinline!let!} bindings will be evaluated in
the order that they're defined. But what about the evaluation order
within a single expression? Officially, the answer is that evaluation
order within an expression is undefined. In practice, OCaml has only one
compiler, and that behavior is a kind of \emph{de facto} standard.
Unfortunately, the evaluation order in this case is often the opposite
of what one might expect.

Consider the following example:

\begin{lstlisting}[language=Caml]
# List.exists ~f:(fun x -> Float.O.(x < 0.))
    [ (printf "1\n"; Float.sin 120.);
      (printf "2\n"; Float.sin 75.);
      (printf "3\n"; Float.sin 128.); ]
3
2
1
- : bool = true
\end{lstlisting}

Here, you can see that the subexpression that came last was actually
evaluated first! This is generally the case for many different kinds of
expressions. If you want to make sure of the evaluation order of
different subexpressions, you should express them as a series of
\passthrough{\lstinline!let!} bindings.

\hypertarget{side-effects-and-weak-polymorphism}{%
\subsection{Side Effects and Weak
Polymorphism}\label{side-effects-and-weak-polymorphism}}

Consider the following simple, imperative function:
\index{polymorphism/weak
polymorphism}\index{weak polymorphism}\index{side effects}\protect\hypertarget{IPsideweak}{}{imperative
programming/side effects/weak polymorphism}

\begin{lstlisting}[language=Caml]
# let remember =
    let cache = ref None in
    (fun x ->
       match !cache with
       | Some y -> y
       | None -> cache := Some x; x)
val remember : '_weak1 -> '_weak1 = <fun>
\end{lstlisting}

\passthrough{\lstinline!remember!} simply caches the first value that's
passed to it, returning that value on every call. That's because
\passthrough{\lstinline!cache!} is created and initialized once and is
shared across invocations of \passthrough{\lstinline!remember!}.

\passthrough{\lstinline!remember!} is not a terribly useful function,
but it raises an interesting question: what is its type?

On its first call, \passthrough{\lstinline!remember!} returns the same
value it's passed, which means its input type and return type should
match. Accordingly, \passthrough{\lstinline!remember!} should have type
\passthrough{\lstinline!t -> t!} for some type
\passthrough{\lstinline!t!}. There's nothing about
\passthrough{\lstinline!remember!} that ties the choice of
\passthrough{\lstinline!t!} to any particular type, so you might expect
OCaml to generalize, replacing \passthrough{\lstinline!t!} with a
polymorphic type variable. It's this kind of generalization that gives
us polymorphic types in the first place. The identity function, as an
example, gets a polymorphic type in this way:

\begin{lstlisting}[language=Caml]
# let identity x = x
val identity : 'a -> 'a = <fun>
# identity 3
- : int = 3
# identity "five"
- : string = "five"
\end{lstlisting}

As you can see, the polymorphic type of
\passthrough{\lstinline!identity!} lets it operate on values with
different types.

This is not what happens with \passthrough{\lstinline!remember!},
though. As you can see from the above examples, the type that OCaml
infers for \passthrough{\lstinline!remember!} looks almost, but not
quite, like the type of the identity function. Here it is again:

\begin{lstlisting}[language=Caml]
val remember : '_a -> '_a = <fun>
\end{lstlisting}

The underscore in the type variable \passthrough{\lstinline!'\_a!} tells
us that the variable is only \emph{weakly polymorphic}, which is to say
that it can be used with any \emph{single} type. That makes sense
because, unlike \passthrough{\lstinline!identity!},
\passthrough{\lstinline!remember!} always returns the value it was
passed on its first invocation, which means its return value must always
have the same type. \index{type variables}

OCaml will convert a weakly polymorphic variable to a concrete type as
soon as it gets a clue as to what concrete type it is to be used as:

\begin{lstlisting}[language=Caml]
# let remember_three () = remember 3
val remember_three : unit -> int = <fun>
# remember
- : int -> int = <fun>
# remember "avocado"
Line 1, characters 10-19:
Error: This expression has type string but an expression was expected of type
         int
\end{lstlisting}

Note that the type of \passthrough{\lstinline!remember!} was settled by
the definition of \passthrough{\lstinline!remember\_three!}, even though
\passthrough{\lstinline!remember\_three!} was never called!

\hypertarget{the-value-restriction}{%
\subsubsection{The Value Restriction}\label{the-value-restriction}}

So, when does the compiler infer weakly polymorphic types? As we've
seen, we need weakly polymorphic types when a value of unknown type is
stored in a persistent mutable cell. Because the type system isn't
precise enough to determine all cases where this might happen, OCaml
uses a rough rule to flag cases that don't introduce any persistent
mutable cells, and to only infer polymorphic types in those cases. This
rule is called \emph{the value restriction}. \index{value restriction}

The core of the value restriction is the observation that some kinds of
expressions, which we'll refer to as \emph{simple values}, by their
nature can't introduce persistent mutable cells, including:

\begin{itemize}
\item
  Constants (i.e., things like integer and floating-point literals)
\item
  Constructors that only contain other simple values
\item
  Function declarations, i.e., expressions that begin with
  \passthrough{\lstinline!fun!} or \passthrough{\lstinline!function!},
  or the equivalent let binding, \passthrough{\lstinline!let f x = ...!}
\item
  \passthrough{\lstinline!let!} bindings of the form
  \passthrough{\lstinline!let!} \emph{\passthrough{\lstinline!var!}}
  \passthrough{\lstinline!=!} \emph{\passthrough{\lstinline!expr1!}}
  \passthrough{\lstinline!in!} \emph{\passthrough{\lstinline!expr2!}},
  where both \emph{\passthrough{\lstinline!expr1!}} and
  \emph{\passthrough{\lstinline!expr2!}} are simple values
\end{itemize}

Thus, the following expression is a simple value, and as a result, the
types of values contained within it are allowed to be polymorphic:

\begin{lstlisting}[language=Caml]
# (fun x -> [x;x])
- : 'a -> 'a list = <fun>
\end{lstlisting}

But, if we write down an expression that isn't a simple value by the
preceding definition, we'll get different results. For example, consider
what happens if we try to memoize the function defined previously.

\begin{lstlisting}[language=Caml]
# memoize (fun x -> [x;x])
- : '_weak2 -> '_weak2 list = <fun>
\end{lstlisting}

The memoized version of the function does in fact need to be restricted
to a single type because it uses mutable state behind the scenes to
cache values returned by previous invocations of the function. But OCaml
would make the same determination even if the function in question did
no such thing. Consider this example:

\begin{lstlisting}[language=Caml]
# identity (fun x -> [x;x])
- : '_weak3 -> '_weak3 list = <fun>
\end{lstlisting}

It would be safe to infer a fully polymorphic variable here, but because
OCaml's type system doesn't distinguish between pure and impure
functions, it can't separate those two cases.

The value restriction doesn't require that there is no mutable state,
only that there is no \emph{persistent} mutable state that could share
values between uses of the same function. Thus, a function that produces
a fresh reference every time it's called can have a fully polymorphic
type:

\begin{lstlisting}[language=Caml]
# let f () = ref None
val f : unit -> 'a option ref = <fun>
\end{lstlisting}

But a function that has a mutable cache that persists across calls, like
\passthrough{\lstinline!memoize!}, can only be weakly polymorphic.

\hypertarget{partial-application-and-the-value-restriction}{%
\subsubsection{Partial Application and the Value
Restriction}\label{partial-application-and-the-value-restriction}}

Most of the time, when the value restriction kicks in, it's for a good
reason, i.e., it's because the value in question can actually only
safely be used with a single type. But sometimes, the value restriction
kicks in when you don't want it. The most common such case is partially
applied functions. A partially applied function, like any function
application, is not a simple value, and as such, functions created by
partial application are sometimes less general than you might expect.
\index{partial application}

Consider the \passthrough{\lstinline!List.init!} function, which is used
for creating lists where each element is created by calling a function
on the index of that element:

\begin{lstlisting}[language=Caml]
# List.init
- : int -> f:(int -> 'a) -> 'a list = <fun>
# List.init 10 ~f:Int.to_string
- : string list = ["0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"]
\end{lstlisting}

Imagine we wanted to create a specialized version of
\passthrough{\lstinline!List.init!} that always created lists of length
10. We could do that using partial application, as follows:

\begin{lstlisting}[language=Caml]
# let list_init_10 = List.init 10
val list_init_10 : f:(int -> '_weak4) -> '_weak4 list = <fun>
\end{lstlisting}

As you can see, we now infer a weakly polymorphic type for the resulting
function. That's because there's nothing that guarantees that
\passthrough{\lstinline!List.init!} isn't creating a persistent
\passthrough{\lstinline!ref!} somewhere inside of it that would be
shared across multiple calls to
\passthrough{\lstinline!list\_init\_10!}. We can eliminate this
possibility, and at the same time get the compiler to infer a
polymorphic type, by avoiding partial application:

\begin{lstlisting}[language=Caml]
# let list_init_10 ~f = List.init 10 ~f
val list_init_10 : f:(int -> 'a) -> 'a list = <fun>
\end{lstlisting}

This transformation is referred to as \emph{eta expansion} and is often
useful to resolve problems that arise from the value restriction.

\hypertarget{relaxing-the-value-restriction}{%
\subsubsection{Relaxing the Value
Restriction}\label{relaxing-the-value-restriction}}

OCaml is actually a little better at inferring polymorphic types than
was suggested previously. The value restriction as we described it is
basically a syntactic check: you can do a few operations that count as
simple values, and anything that's a simple value can be generalized.

But OCaml actually has a relaxed version of the value restriction that
can make use of type information to allow polymorphic types for things
that are not simple values.

For example, we saw that a function application, even a simple
application of the identity function, is not a simple value and thus can
turn a polymorphic value into a weakly polymorphic one:

\begin{lstlisting}[language=Caml]
# identity (fun x -> [x;x])
- : '_weak5 -> '_weak5 list = <fun>
\end{lstlisting}

But that's not always the case. When the type of the returned value is
immutable, then OCaml can typically infer a fully polymorphic type:

\begin{lstlisting}[language=Caml]
# identity []
- : 'a list = []
\end{lstlisting}

On the other hand, if the returned type is mutable, then the result will
be weakly polymorphic:

\begin{lstlisting}[language=Caml]
# [||]
- : 'a array = [||]
# identity [||]
- : '_weak6 array = [||]
\end{lstlisting}

A more important example of this comes up when defining abstract data
types. Consider the following simple data structure for an immutable
list type that supports constant-time concatenation:

\begin{lstlisting}[language=Caml]
# module Concat_list : sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -> 'a t
    val concat  : 'a t -> 'a t -> 'a t  (* constant time *)
    val to_list : 'a t -> 'a list       (* linear time   *)
  end = struct

    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

    let empty = Empty
    let singleton x = Singleton x
    let concat x y = Concat (x,y)

    let rec to_list_with_tail t tail =
      match t with
      | Empty -> tail
      | Singleton x -> x :: tail
      | Concat (x,y) -> to_list_with_tail x (to_list_with_tail y tail)

    let to_list t =
      to_list_with_tail t []

  end
module Concat_list :
  sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -> 'a t
    val concat : 'a t -> 'a t -> 'a t
    val to_list : 'a t -> 'a list
  end
\end{lstlisting}

The details of the implementation don't matter so much, but it's
important to note that a \passthrough{\lstinline!Concat\_list.t!} is
unquestionably an immutable value. However, when it comes to the value
restriction, OCaml treats it as if it were mutable:

\begin{lstlisting}[language=Caml]
# Concat_list.empty
- : 'a Concat_list.t = <abstr>
# identity Concat_list.empty
- : '_weak7 Concat_list.t = <abstr>
\end{lstlisting}

The issue here is that the signature, by virtue of being abstract, has
obscured the fact that \passthrough{\lstinline!Concat\_list.t!} is in
fact an immutable data type. We can resolve this in one of two ways:
either by making the type concrete (i.e., exposing the implementation in
the \passthrough{\lstinline!mli!}), which is often not desirable; or by
marking the type variable in question as \emph{covariant}. We'll learn
more about covariance and contravariance in
\href{objects.html\#objects}{Objects}, but for now, you can think of it
as an annotation that can be put in the interface of a pure data
structure. \index{datatypes/covariant}

In particular, if we replace \passthrough{\lstinline!type 'a t!} in the
interface with \passthrough{\lstinline!type +'a t!}, that will make it
explicit in the interface that the data structure doesn't contain any
persistent references to values of type \passthrough{\lstinline!'a!}, at
which point, OCaml can infer polymorphic types for expressions of this
type that are not simple values:

\begin{lstlisting}[language=Caml]
# module Concat_list : sig
    type +'a t
    val empty : 'a t
    val singleton : 'a -> 'a t
    val concat  : 'a t -> 'a t -> 'a t  (* constant time *)
    val to_list : 'a t -> 'a list       (* linear time   *)
  end = struct

    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

    let empty = Empty
    let singleton x = Singleton x
    let concat x y = Concat (x,y)

    let rec to_list_with_tail t tail =
      match t with
      | Empty -> tail
      | Singleton x -> x :: tail
      | Concat (x,y) -> to_list_with_tail x (to_list_with_tail y tail)

    let to_list t =
      to_list_with_tail t []

  end
module Concat_list :
  sig
    type +'a t
    val empty : 'a t
    val singleton : 'a -> 'a t
    val concat : 'a t -> 'a t -> 'a t
    val to_list : 'a t -> 'a list
  end
\end{lstlisting}

Now, we can apply the identity function to
\passthrough{\lstinline!Concat\_list.empty!} without losing any
polymorphism:

\begin{lstlisting}[language=Caml]
# identity Concat_list.empty
- : 'a Concat_list.t = <abstr>
\end{lstlisting}

\hypertarget{summary}{%
\subsection{Summary}\label{summary}}

This chapter has covered quite a lot of ground, including:
\index{imperative
programming/overview of}

\begin{itemize}
\item
  Discussing the building blocks of mutable data structures as well as
  the basic imperative constructs like \passthrough{\lstinline!for!}
  loops, \passthrough{\lstinline!while!} loops, and the sequencing
  operator \passthrough{\lstinline!;!}
\item
  Walking through the implementation of a couple of classic imperative
  data structures
\item
  Discussing so-called benign effects like memoization and laziness
\item
  Covering OCaml's API for blocking I/O
\item
  Discussing how language-level issues like order of evaluation and weak
  polymorphism interact with OCaml's imperative features
\end{itemize}

The scope and sophistication of the material here is an indication of
the importance of OCaml's imperative features. The fact that OCaml
defaults to immutability shouldn't obscure the fact that imperative
programming is a fundamental part of building any serious application,
and that if you want to be an effective OCaml programmer, you need to
understand OCaml's approach to imperative programming.~
